/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 9);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./Modules/Menu/Resources/assets/admin/js/main.js":
/*!********************************************************!*\
  !*** ./Modules/Menu/Resources/assets/admin/js/main.js ***!
  \********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var nestable2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nestable2 */ \"./Modules/Menu/node_modules/nestable2/jquery.nestable.js\");\n/* harmony import */ var nestable2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(nestable2__WEBPACK_IMPORTED_MODULE_0__);\n\nwindow.admin.removeSubmitButtonOffsetOn('#image');\n$('#type').on('change', function (e) {\n  $('.link-field').addClass('hide');\n  $(\".\".concat(e.currentTarget.value, \"-field\")).removeClass('hide');\n});\n$('.dd').nestable({\n  maxDepth: 15\n});\n$('.dd').on('change', function () {\n  $.ajax({\n    type: 'PUT',\n    url: route('admin.menus.items.order.update'),\n    contentType: 'application/json; charset=utf-8',\n    data: JSON.stringify($('.dd').nestable('serialize')[0]),\n    success: function (_success) {\n      function success() {\n        return _success.apply(this, arguments);\n      }\n\n      success.toString = function () {\n        return _success.toString();\n      };\n\n      return success;\n    }(function () {\n      success(trans('menu::messages.menu_items_order_updated'));\n    }),\n    error: function (_error) {\n      function error(_x) {\n        return _error.apply(this, arguments);\n      }\n\n      error.toString = function () {\n        return _error.toString();\n      };\n\n      return error;\n    }(function (xhr) {\n      error(xhr.responseJSON.message);\n    })\n  });\n});\nvar id;\nvar confirmationModal = $('#confirmation-modal');\n$('.delete-menu-item').on('click', function (e) {\n  id = $(e.currentTarget).closest('.dd-item').data('id');\n  confirmationModal.modal('show');\n});\nconfirmationModal.find('form').on('submit', function (e) {\n  e.preventDefault();\n  confirmationModal.modal('hide');\n  $.ajax({\n    type: 'DELETE',\n    url: route('admin.menus.items.destroy', id),\n    success: function (_success2) {\n      function success() {\n        return _success2.apply(this, arguments);\n      }\n\n      success.toString = function () {\n        return _success2.toString();\n      };\n\n      return success;\n    }(function () {\n      success(trans('menu::messages.menu_item_deleted'));\n      $(\".dd-item[data-id=\\\"\".concat(id, \"\\\"]\")).fadeOut();\n    }),\n    error: function (_error2) {\n      function error(_x2) {\n        return _error2.apply(this, arguments);\n      }\n\n      error.toString = function () {\n        return _error2.toString();\n      };\n\n      return error;\n    }(function (xhr) {\n      error(xhr.responseJSON.message);\n    })\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9Nb2R1bGVzL01lbnUvUmVzb3VyY2VzL2Fzc2V0cy9hZG1pbi9qcy9tYWluLmpzPzIwYTQiXSwibmFtZXMiOlsid2luZG93IiwiYWRtaW4iLCJyZW1vdmVTdWJtaXRCdXR0b25PZmZzZXRPbiIsIiQiLCJvbiIsImUiLCJhZGRDbGFzcyIsImN1cnJlbnRUYXJnZXQiLCJ2YWx1ZSIsInJlbW92ZUNsYXNzIiwibmVzdGFibGUiLCJtYXhEZXB0aCIsImFqYXgiLCJ0eXBlIiwidXJsIiwicm91dGUiLCJjb250ZW50VHlwZSIsImRhdGEiLCJKU09OIiwic3RyaW5naWZ5Iiwic3VjY2VzcyIsInRyYW5zIiwiZXJyb3IiLCJ4aHIiLCJyZXNwb25zZUpTT04iLCJtZXNzYWdlIiwiaWQiLCJjb25maXJtYXRpb25Nb2RhbCIsImNsb3Nlc3QiLCJtb2RhbCIsImZpbmQiLCJwcmV2ZW50RGVmYXVsdCIsImZhZGVPdXQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUFBLE1BQU0sQ0FBQ0MsS0FBUCxDQUFhQywwQkFBYixDQUF3QyxRQUF4QztBQUVBQyxDQUFDLENBQUMsT0FBRCxDQUFELENBQVdDLEVBQVgsQ0FBYyxRQUFkLEVBQXdCLFVBQUNDLENBQUQsRUFBTztBQUMzQkYsR0FBQyxDQUFDLGFBQUQsQ0FBRCxDQUFpQkcsUUFBakIsQ0FBMEIsTUFBMUI7QUFDQUgsR0FBQyxZQUFLRSxDQUFDLENBQUNFLGFBQUYsQ0FBZ0JDLEtBQXJCLFlBQUQsQ0FBcUNDLFdBQXJDLENBQWlELE1BQWpEO0FBQ0gsQ0FIRDtBQUtBTixDQUFDLENBQUMsS0FBRCxDQUFELENBQVNPLFFBQVQsQ0FBa0I7QUFBRUMsVUFBUSxFQUFFO0FBQVosQ0FBbEI7QUFFQVIsQ0FBQyxDQUFDLEtBQUQsQ0FBRCxDQUFTQyxFQUFULENBQVksUUFBWixFQUFzQixZQUFNO0FBQ3hCRCxHQUFDLENBQUNTLElBQUYsQ0FBTztBQUNIQyxRQUFJLEVBQUUsS0FESDtBQUVIQyxPQUFHLEVBQUVDLEtBQUssQ0FBQyxnQ0FBRCxDQUZQO0FBR0hDLGVBQVcsRUFBRSxpQ0FIVjtBQUlIQyxRQUFJLEVBQUVDLElBQUksQ0FBQ0MsU0FBTCxDQUFlaEIsQ0FBQyxDQUFDLEtBQUQsQ0FBRCxDQUFTTyxRQUFULENBQWtCLFdBQWxCLEVBQStCLENBQS9CLENBQWYsQ0FKSDtBQUtIVSxXQUxHO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLGtCQUtPO0FBQ05BLGFBQU8sQ0FBQ0MsS0FBSyxDQUFDLHlDQUFELENBQU4sQ0FBUDtBQUNILEtBUEU7QUFRSEMsU0FSRztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxnQkFRR0MsR0FSSCxFQVFRO0FBQ1BELFdBQUssQ0FBQ0MsR0FBRyxDQUFDQyxZQUFKLENBQWlCQyxPQUFsQixDQUFMO0FBQ0gsS0FWRTtBQUFBLEdBQVA7QUFZSCxDQWJEO0FBZUEsSUFBSUMsRUFBSjtBQUNBLElBQUlDLGlCQUFpQixHQUFHeEIsQ0FBQyxDQUFDLHFCQUFELENBQXpCO0FBRUFBLENBQUMsQ0FBQyxtQkFBRCxDQUFELENBQXVCQyxFQUF2QixDQUEwQixPQUExQixFQUFtQyxVQUFDQyxDQUFELEVBQU87QUFDdENxQixJQUFFLEdBQUd2QixDQUFDLENBQUNFLENBQUMsQ0FBQ0UsYUFBSCxDQUFELENBQW1CcUIsT0FBbkIsQ0FBMkIsVUFBM0IsRUFBdUNYLElBQXZDLENBQTRDLElBQTVDLENBQUw7QUFFQVUsbUJBQWlCLENBQUNFLEtBQWxCLENBQXdCLE1BQXhCO0FBQ0gsQ0FKRDtBQU1BRixpQkFBaUIsQ0FBQ0csSUFBbEIsQ0FBdUIsTUFBdkIsRUFBK0IxQixFQUEvQixDQUFrQyxRQUFsQyxFQUE0QyxVQUFDQyxDQUFELEVBQU87QUFDL0NBLEdBQUMsQ0FBQzBCLGNBQUY7QUFFQUosbUJBQWlCLENBQUNFLEtBQWxCLENBQXdCLE1BQXhCO0FBRUExQixHQUFDLENBQUNTLElBQUYsQ0FBTztBQUNIQyxRQUFJLEVBQUUsUUFESDtBQUVIQyxPQUFHLEVBQUVDLEtBQUssQ0FBQywyQkFBRCxFQUE4QlcsRUFBOUIsQ0FGUDtBQUdITixXQUhHO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLGtCQUdPO0FBQ05BLGFBQU8sQ0FBQ0MsS0FBSyxDQUFDLGtDQUFELENBQU4sQ0FBUDtBQUVBbEIsT0FBQyw4QkFBc0J1QixFQUF0QixTQUFELENBQStCTSxPQUEvQjtBQUNILEtBUEU7QUFRSFYsU0FSRztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxnQkFRR0MsR0FSSCxFQVFRO0FBQ1BELFdBQUssQ0FBQ0MsR0FBRyxDQUFDQyxZQUFKLENBQWlCQyxPQUFsQixDQUFMO0FBQ0gsS0FWRTtBQUFBLEdBQVA7QUFZSCxDQWpCRCIsImZpbGUiOiIuL01vZHVsZXMvTWVudS9SZXNvdXJjZXMvYXNzZXRzL2FkbWluL2pzL21haW4uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJ25lc3RhYmxlMic7XHJcblxyXG53aW5kb3cuYWRtaW4ucmVtb3ZlU3VibWl0QnV0dG9uT2Zmc2V0T24oJyNpbWFnZScpO1xyXG5cclxuJCgnI3R5cGUnKS5vbignY2hhbmdlJywgKGUpID0+IHtcclxuICAgICQoJy5saW5rLWZpZWxkJykuYWRkQ2xhc3MoJ2hpZGUnKTtcclxuICAgICQoYC4ke2UuY3VycmVudFRhcmdldC52YWx1ZX0tZmllbGRgKS5yZW1vdmVDbGFzcygnaGlkZScpO1xyXG59KTtcclxuXHJcbiQoJy5kZCcpLm5lc3RhYmxlKHsgbWF4RGVwdGg6IDE1IH0pO1xyXG5cclxuJCgnLmRkJykub24oJ2NoYW5nZScsICgpID0+IHtcclxuICAgICQuYWpheCh7XHJcbiAgICAgICAgdHlwZTogJ1BVVCcsXHJcbiAgICAgICAgdXJsOiByb3V0ZSgnYWRtaW4ubWVudXMuaXRlbXMub3JkZXIudXBkYXRlJyksXHJcbiAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04JyxcclxuICAgICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeSgkKCcuZGQnKS5uZXN0YWJsZSgnc2VyaWFsaXplJylbMF0pLFxyXG4gICAgICAgIHN1Y2Nlc3MoKSB7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3ModHJhbnMoJ21lbnU6Om1lc3NhZ2VzLm1lbnVfaXRlbXNfb3JkZXJfdXBkYXRlZCcpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVycm9yKHhocikge1xyXG4gICAgICAgICAgICBlcnJvcih4aHIucmVzcG9uc2VKU09OLm1lc3NhZ2UpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxufSk7XHJcblxyXG5sZXQgaWQ7XHJcbmxldCBjb25maXJtYXRpb25Nb2RhbCA9ICQoJyNjb25maXJtYXRpb24tbW9kYWwnKTtcclxuXHJcbiQoJy5kZWxldGUtbWVudS1pdGVtJykub24oJ2NsaWNrJywgKGUpID0+IHtcclxuICAgIGlkID0gJChlLmN1cnJlbnRUYXJnZXQpLmNsb3Nlc3QoJy5kZC1pdGVtJykuZGF0YSgnaWQnKTtcclxuXHJcbiAgICBjb25maXJtYXRpb25Nb2RhbC5tb2RhbCgnc2hvdycpO1xyXG59KTtcclxuXHJcbmNvbmZpcm1hdGlvbk1vZGFsLmZpbmQoJ2Zvcm0nKS5vbignc3VibWl0JywgKGUpID0+IHtcclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICBjb25maXJtYXRpb25Nb2RhbC5tb2RhbCgnaGlkZScpO1xyXG5cclxuICAgICQuYWpheCh7XHJcbiAgICAgICAgdHlwZTogJ0RFTEVURScsXHJcbiAgICAgICAgdXJsOiByb3V0ZSgnYWRtaW4ubWVudXMuaXRlbXMuZGVzdHJveScsIGlkKSxcclxuICAgICAgICBzdWNjZXNzKCkge1xyXG4gICAgICAgICAgICBzdWNjZXNzKHRyYW5zKCdtZW51OjptZXNzYWdlcy5tZW51X2l0ZW1fZGVsZXRlZCcpKTtcclxuXHJcbiAgICAgICAgICAgICQoYC5kZC1pdGVtW2RhdGEtaWQ9XCIke2lkfVwiXWApLmZhZGVPdXQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVycm9yKHhocikge1xyXG4gICAgICAgICAgICBlcnJvcih4aHIucmVzcG9uc2VKU09OLm1lc3NhZ2UpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxufSk7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./Modules/Menu/Resources/assets/admin/js/main.js\n");

/***/ }),

/***/ "./Modules/Menu/node_modules/nestable2/jquery.nestable.js":
/*!****************************************************************!*\
  !*** ./Modules/Menu/node_modules/nestable2/jquery.nestable.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Nestable jQuery Plugin - Copyright (c) 2014 Ramon Smit - https://github.com/RamonSmit/Nestable\n */\n\n(function($, window, document, undefined) {\n    var hasTouch = 'ontouchstart' in document;\n\n    /**\n     * Detect CSS pointer-events property\n     * events are normally disabled on the dragging element to avoid conflicts\n     * https://github.com/ausi/Feature-detection-technique-for-pointer-events/blob/master/modernizr-pointerevents.js\n     */\n    var hasPointerEvents = (function() {\n        var el = document.createElement('div'),\n            docEl = document.documentElement;\n        if (!('pointerEvents' in el.style)) {\n            return false;\n        }\n        el.style.pointerEvents = 'auto';\n        el.style.pointerEvents = 'x';\n        docEl.appendChild(el);\n        var supports = window.getComputedStyle && window.getComputedStyle(el, '').pointerEvents === 'auto';\n        docEl.removeChild(el);\n        return !!supports;\n    })();\n\n    var defaults = {\n        contentCallback: function(item) {return item.content || '' ? item.content : item.id;},\n        listNodeName: 'ol',\n        itemNodeName: 'li',\n        handleNodeName: 'div',\n        contentNodeName: 'span',\n        rootClass: 'dd',\n        listClass: 'dd-list',\n        itemClass: 'dd-item',\n        dragClass: 'dd-dragel',\n        handleClass: 'dd-handle',\n        contentClass: 'dd-content',\n        collapsedClass: 'dd-collapsed',\n        placeClass: 'dd-placeholder',\n        noDragClass: 'dd-nodrag',\n        noChildrenClass: 'dd-nochildren',\n        emptyClass: 'dd-empty',\n        expandBtnHTML: '<button class=\"dd-expand\" data-action=\"expand\" type=\"button\">Expand</button>',\n        collapseBtnHTML: '<button class=\"dd-collapse\" data-action=\"collapse\" type=\"button\">Collapse</button>',\n        group: 0,\n        maxDepth: 5,\n        threshold: 20,\n        fixedDepth: false, //fixed item's depth\n        fixed: false,\n        includeContent: false,\n        scroll: false,\n        scrollSensitivity: 1,\n        scrollSpeed: 5,\n        scrollTriggers: {\n            top: 40,\n            left: 40,\n            right: -40,\n            bottom: -40\n        },\n        effect: {\n            animation: 'none',\n            time: 'slow'\n        },\n        callback: function(l, e, p) {},\n        onDragStart: function(l, e, p) {},\n        beforeDragStop: function(l, e, p) {},\n        listRenderer: function(children, options) {\n            var html = '<' + options.listNodeName + ' class=\"' + options.listClass + '\">';\n            html += children;\n            html += '</' + options.listNodeName + '>';\n\n            return html;\n        },\n        itemRenderer: function(item_attrs, content, children, options, item) {\n            var item_attrs_string = $.map(item_attrs, function(value, key) {\n                return ' ' + key + '=\"' + value + '\"';\n            }).join(' ');\n\n            var html = '<' + options.itemNodeName + item_attrs_string + '>';\n            html += '<' + options.handleNodeName + ' class=\"' + options.handleClass + '\">';\n            html += '<' + options.contentNodeName + ' class=\"' + options.contentClass + '\">';\n            html += content;\n            html += '</' + options.contentNodeName + '>';\n            html += '</' + options.handleNodeName + '>';\n            html += children;\n            html += '</' + options.itemNodeName + '>';\n\n            return html;\n        }\n    };\n\n    function Plugin(element, options) {\n        this.w  = $(document);\n        this.el = $(element);\n        options = options || defaults;\n\n        if (options.rootClass !== undefined && options.rootClass !== 'dd') {\n            options.listClass       = options.listClass ? options.listClass : options.rootClass + '-list';\n            options.itemClass       = options.itemClass ? options.itemClass : options.rootClass + '-item';\n            options.dragClass       = options.dragClass ? options.dragClass : options.rootClass + '-dragel';\n            options.handleClass     = options.handleClass ? options.handleClass : options.rootClass + '-handle';\n            options.collapsedClass  = options.collapsedClass ? options.collapsedClass : options.rootClass + '-collapsed';\n            options.placeClass      = options.placeClass ? options.placeClass : options.rootClass + '-placeholder';\n            options.noDragClass     = options.noDragClass ? options.noDragClass : options.rootClass + '-nodrag';\n            options.noChildrenClass = options.noChildrenClass ? options.noChildrenClass : options.rootClass + '-nochildren';\n            options.emptyClass      = options.emptyClass ? options.emptyClass : options.rootClass + '-empty';\n        }\n\n        this.options = $.extend({}, defaults, options);\n\n        // build HTML from serialized JSON if passed\n        if (this.options.json !== undefined) {\n            this._build();\n        }\n\n        this.init();\n    }\n\n    Plugin.prototype = {\n\n        init: function() {\n            var list = this;\n\n            list.reset();\n            list.el.data('nestable-group', this.options.group);\n            list.placeEl = $('<div class=\"' + list.options.placeClass + '\"/>');\n\n            var items = this.el.find(list.options.itemNodeName);\n            $.each(items, function(k, el) {\n                var item = $(el),\n                    parent = item.parent();\n                list.setParent(item);\n                if (parent.hasClass(list.options.collapsedClass)) {\n                    list.collapseItem(parent.parent());\n                }\n            });\n\n            // Append the .dd-empty div if the list don't have any items on init\n            if (!items.length) {\n                this.appendEmptyElement(this.el);\n            }\n\n            list.el.on('click', 'button', function(e) {\n                if (list.dragEl) {\n                    return;\n                }\n                var target = $(e.currentTarget),\n                    action = target.data('action'),\n                    item = target.parents(list.options.itemNodeName).eq(0);\n                if (action === 'collapse') {\n                    list.collapseItem(item);\n                }\n                if (action === 'expand') {\n                    list.expandItem(item);\n                }\n            });\n\n            var onStartEvent = function(e) {\n                var handle = $(e.target);\n                if (!handle.hasClass(list.options.handleClass)) {\n                    if (handle.closest('.' + list.options.noDragClass).length) {\n                        return;\n                    }\n                    handle = handle.closest('.' + list.options.handleClass);\n                }\n                if (!handle.length || list.dragEl) {\n                    return;\n                }\n\n                list.isTouch = /^touch/.test(e.type);\n                if (list.isTouch && e.touches.length !== 1) {\n                    return;\n                }\n\n                e.preventDefault();\n                list.dragStart(e.touches ? e.touches[0] : e);\n            };\n\n            var onMoveEvent = function(e) {\n                if (list.dragEl) {\n                    e.preventDefault();\n                    list.dragMove(e.touches ? e.touches[0] : e);\n                }\n            };\n\n            var onEndEvent = function(e) {\n                if (list.dragEl) {\n                    e.preventDefault();\n                    list.dragStop(e.touches ? e.changedTouches[0] : e);\n                }\n            };\n\n            if (hasTouch) {\n                list.el[0].addEventListener('touchstart', onStartEvent, false);\n                window.addEventListener('touchmove', onMoveEvent, false);\n                window.addEventListener('touchend', onEndEvent, false);\n                window.addEventListener('touchcancel', onEndEvent, false);\n            }\n\n            list.el.on('mousedown', onStartEvent);\n            list.w.on('mousemove', onMoveEvent);\n            list.w.on('mouseup', onEndEvent);\n\n            var destroyNestable = function()\n            {\n                if (hasTouch) {\n                    list.el[0].removeEventListener('touchstart', onStartEvent, false);\n                    window.removeEventListener('touchmove', onMoveEvent, false);\n                    window.removeEventListener('touchend', onEndEvent, false);\n                    window.removeEventListener('touchcancel', onEndEvent, false);\n                }\n\n                list.el.off('mousedown', onStartEvent);\n                list.w.off('mousemove', onMoveEvent);\n                list.w.off('mouseup', onEndEvent);\n\n                list.el.off('click');\n                list.el.unbind('destroy-nestable');\n\n                list.el.data(\"nestable\", null);\n            };\n\n            list.el.bind('destroy-nestable', destroyNestable);\n\n        },\n\n        destroy: function ()\n        {\n            this.el.trigger('destroy-nestable');\n        },\n\n        add: function (item)\n        {\n            var listClassSelector = '.' + this.options.listClass;\n            var tree = $(this.el).children(listClassSelector);\n\n            if (item.parent_id !== undefined) {\n                tree = tree.find('[data-id=\"' + item.parent_id + '\"]');\n                delete item.parent_id;\n\n                if (tree.children(listClassSelector).length === 0) {\n                    tree = tree.append(this.options.listRenderer('', this.options));\n                }\n\n                tree = tree.find(listClassSelector + ':first');\n                this.setParent(tree.parent());\n            }\n\n            tree.append(this._buildItem(item, this.options));\n        },\n\n        replace: function (item)\n        {\n            var html = this._buildItem(item, this.options);\n\n            this._getItemById(item.id)\n                .replaceWith(html);\n        },\n\n        //removes item and additional elements from list\n        removeItem: function (item){\n            var opts = this.options,\n                el   = this.el;\n\n            // remove item\n            item = item || this;\n            item.remove();\n\n            // remove empty children lists\n            var emptyListsSelector = '.' + opts.listClass\n                + ' .' + opts.listClass + ':not(:has(*))';\n            $(el).find(emptyListsSelector).remove();\n\n            // remove buttons if parents do not have children\n            var buttonsSelector = '[data-action=\"expand\"], [data-action=\"collapse\"]';\n            $(el).find(buttonsSelector).each(function() {\n                var siblings = $(this).siblings('.' + opts.listClass);\n                if (siblings.length === 0) {\n                    $(this).remove();\n                }\n            });\n        },\n\n        //removes item by itemId and run callback at the end\n        remove: function (itemId, callback)\n        {\n            var opts = this.options;\n            var list = this;\n            var item = this._getItemById(itemId);\n\n            //animation style\n            var animation = opts.effect.animation || 'fade';\n\n            //animation time\n            var time = opts.effect.time || 'slow';\n\n            //add fadeOut effect when removing\n            if (animation === 'fade'){\n                item.fadeOut(time, function(){\n                    list.removeItem(item);\n                });\n            }\n            else {\n                this.removeItem(item);\n            }\n\n            if (callback) callback();\n        },\n\n        //removes all items from the list and run callback at the end\n        removeAll: function(callback){\n\n            var list  = this,\n                opts  = this.options,\n                node  = list.el.find(opts.listNodeName).first(),\n                items = node.children(opts.itemNodeName);\n\n            //animation style\n            var animation = opts.effect.animation || 'fade';\n\n            //animation time\n            var time = opts.effect.time || 'slow';\n\n            function remove(){\n                //Removes each item and its children.\n                items.each(function() {\n                    list.removeItem($(this));\n                });\n                //Now we can again show our node element\n                node.show();\n                if (callback) callback();\n            }\n\n            //add fadeOut effect when removing\n            if (animation === 'fade'){\n                node.fadeOut(time, remove);\n            }\n            else {\n                remove();\n            }\n        },\n\n        _getItemById: function(itemId) {\n            return $(this.el).children('.' + this.options.listClass)\n                .find('[data-id=\"' + itemId + '\"]');\n        },\n\n        _build: function() {\n            var json = this.options.json;\n\n            if (typeof json === 'string') {\n                json = JSON.parse(json);\n            }\n\n            $(this.el).html(this._buildList(json, this.options));\n        },\n\n        _buildList: function(items, options) {\n            if (!items) {\n                return '';\n            }\n\n            var children = '';\n            var that = this;\n\n            $.each(items, function(index, sub) {\n                children += that._buildItem(sub, options);\n            });\n\n            return options.listRenderer(children, options);\n        },\n\n        _buildItem: function(item, options) {\n            function escapeHtml(text) {\n                var map = {\n                    '&': '&amp;',\n                    '<': '&lt;',\n                    '>': '&gt;',\n                    '\"': '&quot;',\n                    \"'\": '&#039;'\n                };\n\n                return text + \"\".replace(/[&<>\"']/g, function(m) { return map[m]; });\n            }\n\n            function filterClasses(classes) {\n                var new_classes = {};\n\n                for (var k in classes) {\n                    // Remove duplicates\n                    new_classes[classes[k]] = classes[k];\n                }\n\n                return new_classes;\n            }\n\n            function createClassesString(item, options) {\n                var classes = item.classes || {};\n\n                if (typeof classes === 'string') {\n                    classes = [classes];\n                }\n\n                var item_classes = filterClasses(classes);\n                item_classes[options.itemClass] = options.itemClass;\n\n                // create class string\n                return $.map(item_classes, function(val) {\n                    return val;\n                }).join(' ');\n            }\n\n            function createDataAttrs(attr) {\n                attr = $.extend({}, attr);\n\n                delete attr.children;\n                delete attr.classes;\n                delete attr.content;\n\n                var data_attrs = {};\n\n                $.each(attr, function(key, value) {\n                    if (typeof value === 'object') {\n                        value = JSON.stringify(value);\n                    }\n\n                    data_attrs[\"data-\" + key] = escapeHtml(value);\n                });\n\n                return data_attrs;\n            }\n\n            var item_attrs = createDataAttrs(item);\n            item_attrs[\"class\"] = createClassesString(item, options);\n\n            var content = options.contentCallback(item);\n            var children = this._buildList(item.children, options);\n            var html = $(options.itemRenderer(item_attrs, content, children, options, item));\n\n            this.setParent(html);\n\n            return html[0].outerHTML;\n        },\n\n        serialize: function() {\n            var data, list = this, step = function(level) {\n                var array = [],\n                    items = level.children(list.options.itemNodeName);\n                items.each(function() {\n                    var li = $(this),\n                        item = $.extend({}, li.data()),\n                        sub = li.children(list.options.listNodeName);\n\n                    if (list.options.includeContent) {\n                        var content = li.find('.' + list.options.contentClass).html();\n\n                        if (content) {\n                            item.content = content;\n                        }\n                    }\n\n                    if (sub.length) {\n                        item.children = step(sub);\n                    }\n                    array.push(item);\n                });\n                return array;\n            };\n            data = step(list.el.find(list.options.listNodeName).first());\n            return data;\n        },\n\n        asNestedSet: function() {\n            var list = this, o = list.options, depth = -1, ret = [], lft = 1;\n            var items = list.el.find(o.listNodeName).first().children(o.itemNodeName);\n\n            items.each(function () {\n                lft = traverse(this, depth + 1, lft);\n            });\n\n            ret = ret.sort(function(a,b){ return (a.lft - b.lft); });\n            return ret;\n\n            function traverse(item, depth, lft) {\n                var rgt = lft + 1, id, pid;\n\n                if ($(item).children(o.listNodeName).children(o.itemNodeName).length > 0 ) {\n                    depth++;\n                    $(item).children(o.listNodeName).children(o.itemNodeName).each(function () {\n                        rgt = traverse($(this), depth, rgt);\n                    });\n                    depth--;\n                }\n\n                id = $(item).attr('data-id');\n                if (isInt(id)) {\n                    id = parseInt(id);\n                }\n\n                pid = $(item).parent(o.listNodeName).parent(o.itemNodeName).attr('data-id') || '';\n                if (isInt(pid)) {\n                    id = parseInt(pid);\n                }\n\n                if (id) {\n                    ret.push({\"id\": id, \"parent_id\": pid, \"depth\": depth, \"lft\": lft, \"rgt\": rgt});\n                }\n\n                lft = rgt + 1;\n                return lft;\n            }\n\n            function isInt(value) {\n                return $.isNumeric(value) && Math.floor(value) == value;\n            }\n        },\n\n        returnOptions: function() {\n            return this.options;\n        },\n\n        serialise: function() {\n            return this.serialize();\n        },\n\n        toHierarchy: function(options) {\n\n            var o = $.extend({}, this.options, options),\n                ret = [];\n\n            $(this.element).children(o.items).each(function() {\n                var level = _recursiveItems(this);\n                ret.push(level);\n            });\n\n            return ret;\n\n            function _recursiveItems(item) {\n                var id = ($(item).attr(o.attribute || 'id') || '').match(o.expression || (/(.+)[-=_](.+)/));\n                if (id) {\n                    var currentItem = {\n                        \"id\": id[2]\n                    };\n                    if ($(item).children(o.listType).children(o.items).length > 0) {\n                        currentItem.children = [];\n                        $(item).children(o.listType).children(o.items).each(function() {\n                            var level = _recursiveItems(this);\n                            currentItem.children.push(level);\n                        });\n                    }\n                    return currentItem;\n                }\n            }\n        },\n\n        toArray: function() {\n\n            var o = $.extend({}, this.options, this),\n                sDepth = o.startDepthCount || 0,\n                ret = [],\n                left = 2,\n                list = this,\n                element = list.el.find(list.options.listNodeName).first();\n\n            var items = element.children(list.options.itemNodeName);\n            items.each(function() {\n                left = _recursiveArray($(this), sDepth + 1, left);\n            });\n\n            ret = ret.sort(function(a, b) {\n                return (a.left - b.left);\n            });\n\n            return ret;\n\n            function _recursiveArray(item, depth, left) {\n\n                var right = left + 1,\n                    id,\n                    pid;\n\n                if (item.children(o.options.listNodeName).children(o.options.itemNodeName).length > 0) {\n                    depth++;\n                    item.children(o.options.listNodeName).children(o.options.itemNodeName).each(function() {\n                        right = _recursiveArray($(this), depth, right);\n                    });\n                    depth--;\n                }\n\n                id = item.data().id;\n\n\n                if (depth === sDepth + 1) {\n                    pid = o.rootID;\n                } else {\n\n                    var parentItem = (item.parent(o.options.listNodeName)\n                        .parent(o.options.itemNodeName)\n                        .data());\n                    pid = parentItem.id;\n\n                }\n\n                if (id) {\n                    ret.push({\n                        \"id\": id,\n                        \"parent_id\": pid,\n                        \"depth\": depth,\n                        \"left\": left,\n                        \"right\": right\n                    });\n                }\n\n                left = right + 1;\n                return left;\n            }\n\n        },\n\n        reset: function() {\n            this.mouse = {\n                offsetX: 0,\n                offsetY: 0,\n                startX: 0,\n                startY: 0,\n                lastX: 0,\n                lastY: 0,\n                nowX: 0,\n                nowY: 0,\n                distX: 0,\n                distY: 0,\n                dirAx: 0,\n                dirX: 0,\n                dirY: 0,\n                lastDirX: 0,\n                lastDirY: 0,\n                distAxX: 0,\n                distAxY: 0\n            };\n            this.isTouch = false;\n            this.moving = false;\n            this.dragEl = null;\n            this.dragRootEl = null;\n            this.dragDepth = 0;\n            this.hasNewRoot = false;\n            this.pointEl = null;\n        },\n\n        expandItem: function(li) {\n            li.removeClass(this.options.collapsedClass);\n        },\n\n        collapseItem: function(li) {\n            var lists = li.children(this.options.listNodeName);\n            if (lists.length) {\n                li.addClass(this.options.collapsedClass);\n            }\n        },\n\n        expandAll: function() {\n            var list = this;\n            list.el.find(list.options.itemNodeName).each(function() {\n                list.expandItem($(this));\n            });\n        },\n\n        collapseAll: function() {\n            var list = this;\n            list.el.find(list.options.itemNodeName).each(function() {\n                list.collapseItem($(this));\n            });\n        },\n\n        setParent: function(li) {\n            //Check if li is an element of itemNodeName type and has children\n            if (li.is(this.options.itemNodeName) && li.children(this.options.listNodeName).length) {\n                // make sure NOT showing two or more sets data-action buttons\n                li.children('[data-action]').remove();\n                li.prepend($(this.options.expandBtnHTML));\n                li.prepend($(this.options.collapseBtnHTML));\n            }\n        },\n\n        unsetParent: function(li) {\n            li.removeClass(this.options.collapsedClass);\n            li.children('[data-action]').remove();\n            li.children(this.options.listNodeName).remove();\n        },\n\n        dragStart: function(e) {\n            var mouse = this.mouse,\n                target = $(e.target),\n                dragItem = target.closest(this.options.itemNodeName),\n                position = {\n                    top  : e.pageY,\n                    left : e.pageX\n                };\n\n            var continueExecution = this.options.onDragStart.call(this, this.el, dragItem, position);\n\n            if (typeof continueExecution !== 'undefined' && continueExecution === false) {\n                return;\n            }\n\n            this.placeEl.css('height', dragItem.height());\n\n            mouse.offsetX = e.pageX - dragItem.offset().left;\n            mouse.offsetY = e.pageY - dragItem.offset().top;\n            mouse.startX = mouse.lastX = e.pageX;\n            mouse.startY = mouse.lastY = e.pageY;\n\n            this.dragRootEl = this.el;\n            this.dragEl = $(document.createElement(this.options.listNodeName)).addClass(this.options.listClass + ' ' + this.options.dragClass);\n            this.dragEl.css('width', dragItem.outerWidth());\n\n            this.setIndexOfItem(dragItem);\n\n            // fix for zepto.js\n            //dragItem.after(this.placeEl).detach().appendTo(this.dragEl);\n            dragItem.after(this.placeEl);\n            dragItem[0].parentNode.removeChild(dragItem[0]);\n            dragItem.appendTo(this.dragEl);\n\n            $(document.body).append(this.dragEl);\n            this.dragEl.css({\n                'left': e.pageX - mouse.offsetX,\n                'top': e.pageY - mouse.offsetY\n            });\n            // total depth of dragging item\n            var i, depth,\n                items = this.dragEl.find(this.options.itemNodeName);\n            for (i = 0; i < items.length; i++) {\n                depth = $(items[i]).parents(this.options.listNodeName).length;\n                if (depth > this.dragDepth) {\n                    this.dragDepth = depth;\n                }\n            }\n        },\n\n        //Create sublevel.\n        //  element : element which become parent\n        //  item    : something to place into new sublevel\n        createSubLevel: function(element, item) {\n            var list = $('<' + this.options.listNodeName + '/>').addClass(this.options.listClass);\n            if (item) list.append(item);\n            element.append(list);\n            this.setParent(element);\n            return list;\n        },\n\n        setIndexOfItem: function(item, index) {\n            index = index || [];\n\n            index.unshift(item.index());\n\n            if ($(item[0].parentNode)[0] !== this.dragRootEl[0]) {\n                this.setIndexOfItem($(item[0].parentNode), index);\n            }\n            else {\n                this.dragEl.data('indexOfItem', index);\n            }\n        },\n\n        restoreItemAtIndex: function(dragElement, indexArray) {\n            var currentEl = this.el,\n                lastIndex = indexArray.length - 1;\n\n            //Put drag element at current element position.\n            function placeElement(currentEl, dragElement) {\n                if (indexArray[lastIndex] === 0) {\n                    $(currentEl).prepend(dragElement.clone(true)); //using true saves added to element events.\n                }\n                else {\n                    $(currentEl.children[indexArray[lastIndex] - 1]).after(dragElement.clone(true)); //using true saves added to element events.\n                }\n            }\n            //Diggin through indexArray to get home for dragElement.\n            for (var i = 0; i < indexArray.length; i++) {\n                if (lastIndex === parseInt(i)) {\n                    placeElement(currentEl, dragElement);\n                    return;\n                }\n                //element can have no indexes, so we have to use conditional here to avoid errors.\n                //if element doesn't exist we defenetly need to add new list.\n                var element = (currentEl[0]) ? currentEl[0] : currentEl;\n                var nextEl  = element.children[indexArray[i]];\n                currentEl   = (!nextEl) ? this.createSubLevel($(element)) : nextEl;\n            }\n        },\n\n        dragStop: function(e) {\n            // fix for zepto.js\n            //this.placeEl.replaceWith(this.dragEl.children(this.options.itemNodeName + ':first').detach());\n            var position = {\n                top  : e.pageY,\n                left : e.pageX\n            };\n            //Get indexArray of item at drag start.\n            var srcIndex = this.dragEl.data('indexOfItem');\n\n            var el = this.dragEl.children(this.options.itemNodeName).first();\n\n            el[0].parentNode.removeChild(el[0]);\n\n            this.dragEl.remove(); //Remove dragEl, cause it can affect on indexing in html collection.\n\n            //Before drag stop callback\n            var continueExecution = this.options.beforeDragStop.call(this, this.el, el, this.placeEl.parent());\n            if (typeof continueExecution !== 'undefined' && continueExecution === false) {\n                var parent = this.placeEl.parent();\n                this.placeEl.remove();\n                if (!parent.children().length) {\n                    this.unsetParent(parent.parent());\n                }\n                this.restoreItemAtIndex(el, srcIndex);\n                this.reset();\n                return;\n            }\n\n            this.placeEl.replaceWith(el);\n\n            if (this.hasNewRoot) {\n                if (this.options.fixed === true) {\n                    this.restoreItemAtIndex(el, srcIndex);\n                }\n                else {\n                    this.el.trigger('lostItem');\n                }\n                this.dragRootEl.trigger('gainedItem');\n            }\n            else {\n                this.dragRootEl.trigger('change');\n            }\n\n            this.options.callback.call(this, this.dragRootEl, el, position);\n\n            this.reset();\n        },\n\n        dragMove: function(e) {\n            var list, parent, prev, next, depth,\n                opt = this.options,\n                mouse = this.mouse;\n\n            this.dragEl.css({\n                'left': e.pageX - mouse.offsetX,\n                'top': e.pageY - mouse.offsetY\n            });\n\n            // mouse position last events\n            mouse.lastX = mouse.nowX;\n            mouse.lastY = mouse.nowY;\n            // mouse position this events\n            mouse.nowX = e.pageX;\n            mouse.nowY = e.pageY;\n            // distance mouse moved between events\n            mouse.distX = mouse.nowX - mouse.lastX;\n            mouse.distY = mouse.nowY - mouse.lastY;\n            // direction mouse was moving\n            mouse.lastDirX = mouse.dirX;\n            mouse.lastDirY = mouse.dirY;\n            // direction mouse is now moving (on both axis)\n            mouse.dirX = mouse.distX === 0 ? 0 : mouse.distX > 0 ? 1 : -1;\n            mouse.dirY = mouse.distY === 0 ? 0 : mouse.distY > 0 ? 1 : -1;\n            // axis mouse is now moving on\n            var newAx = Math.abs(mouse.distX) > Math.abs(mouse.distY) ? 1 : 0;\n\n            // do nothing on first move\n            if (!mouse.moving) {\n                mouse.dirAx = newAx;\n                mouse.moving = true;\n                return;\n            }\n\n            // do scrolling if enable\n            if (opt.scroll) {\n                if (typeof window.jQuery.fn.scrollParent !== 'undefined') {\n                    var scrolled = false;\n                    var scrollParent = this.el.scrollParent()[0];\n                    if (scrollParent !== document && scrollParent.tagName !== 'HTML') {\n                        if ((opt.scrollTriggers.bottom + scrollParent.offsetHeight) - e.pageY < opt.scrollSensitivity)\n                            scrollParent.scrollTop = scrolled = scrollParent.scrollTop + opt.scrollSpeed;\n                        else if (e.pageY - opt.scrollTriggers.top < opt.scrollSensitivity)\n                            scrollParent.scrollTop = scrolled = scrollParent.scrollTop - opt.scrollSpeed;\n\n                        if ((opt.scrollTriggers.right + scrollParent.offsetWidth) - e.pageX < opt.scrollSensitivity)\n                            scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + opt.scrollSpeed;\n                        else if (e.pageX - opt.scrollTriggers.left < opt.scrollSensitivity)\n                            scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - opt.scrollSpeed;\n                    } else {\n                        if (e.pageY - $(document).scrollTop() < opt.scrollSensitivity)\n                            scrolled = $(document).scrollTop($(document).scrollTop() - opt.scrollSpeed);\n                        else if ($(window).height() - (e.pageY - $(document).scrollTop()) < opt.scrollSensitivity)\n                            scrolled = $(document).scrollTop($(document).scrollTop() + opt.scrollSpeed);\n\n                        if (e.pageX - $(document).scrollLeft() < opt.scrollSensitivity)\n                            scrolled = $(document).scrollLeft($(document).scrollLeft() - opt.scrollSpeed);\n                        else if ($(window).width() - (e.pageX - $(document).scrollLeft()) < opt.scrollSensitivity)\n                            scrolled = $(document).scrollLeft($(document).scrollLeft() + opt.scrollSpeed);\n                    }\n                } else {\n                    console.warn('To use scrolling you need to have scrollParent() function, check documentation for more information');\n                }\n            }\n\n            if (this.scrollTimer) {\n                clearTimeout(this.scrollTimer);\n            }\n\n            if (opt.scroll && scrolled) {\n                this.scrollTimer = setTimeout(function() {\n                    $(window).trigger(e);\n                }, 10);\n            }\n\n            // calc distance moved on this axis (and direction)\n            if (mouse.dirAx !== newAx) {\n                mouse.distAxX = 0;\n                mouse.distAxY = 0;\n            }\n            else {\n                mouse.distAxX += Math.abs(mouse.distX);\n                if (mouse.dirX !== 0 && mouse.dirX !== mouse.lastDirX) {\n                    mouse.distAxX = 0;\n                }\n                mouse.distAxY += Math.abs(mouse.distY);\n                if (mouse.dirY !== 0 && mouse.dirY !== mouse.lastDirY) {\n                    mouse.distAxY = 0;\n                }\n            }\n            mouse.dirAx = newAx;\n\n            /**\n             * move horizontal\n             */\n            if (mouse.dirAx && mouse.distAxX >= opt.threshold) {\n                // reset move distance on x-axis for new phase\n                mouse.distAxX = 0;\n                prev = this.placeEl.prev(opt.itemNodeName);\n                // increase horizontal level if previous sibling exists, is not collapsed, and can have children\n                if (mouse.distX > 0 && prev.length && !prev.hasClass(opt.collapsedClass) && !prev.hasClass(opt.noChildrenClass)) {\n                    // cannot increase level when item above is collapsed\n                    list = prev.find(opt.listNodeName).last();\n                    // check if depth limit has reached\n                    depth = this.placeEl.parents(opt.listNodeName).length;\n                    if (depth + this.dragDepth <= opt.maxDepth) {\n                        // create new sub-level if one doesn't exist\n                        if (!list.length) {\n                            this.createSubLevel(prev, this.placeEl);\n                        }\n                        else {\n                            // else append to next level up\n                            list = prev.children(opt.listNodeName).last();\n                            list.append(this.placeEl);\n                        }\n                    }\n                }\n                // decrease horizontal level\n                if (mouse.distX < 0) {\n                    // we can't decrease a level if an item preceeds the current one\n                    next = this.placeEl.next(opt.itemNodeName);\n                    if (!next.length) {\n                        parent = this.placeEl.parent();\n                        this.placeEl.closest(opt.itemNodeName).after(this.placeEl);\n                        if (!parent.children().length) {\n                            this.unsetParent(parent.parent());\n                        }\n                    }\n                }\n            }\n\n            var isEmpty = false;\n\n            // find list item under cursor\n            if (!hasPointerEvents) {\n                this.dragEl[0].style.visibility = 'hidden';\n            }\n            this.pointEl = $(document.elementFromPoint(e.pageX - document.body.scrollLeft, e.pageY - (window.pageYOffset || document.documentElement.scrollTop)));\n            if (!hasPointerEvents) {\n                this.dragEl[0].style.visibility = 'visible';\n            }\n            if (this.pointEl.hasClass(opt.handleClass)) {\n                this.pointEl = this.pointEl.closest(opt.itemNodeName);\n            }\n            if (this.pointEl.hasClass(opt.emptyClass)) {\n                isEmpty = true;\n            }\n            else if (!this.pointEl.length || !this.pointEl.hasClass(opt.itemClass)) {\n                return;\n            }\n\n            // find parent list of item under cursor\n            var pointElRoot = this.pointEl.closest('.' + opt.rootClass),\n                isNewRoot = this.dragRootEl.data('nestable-id') !== pointElRoot.data('nestable-id');\n\n            /**\n             * move vertical\n             */\n            if (!mouse.dirAx || isNewRoot || isEmpty) {\n                // check if groups match if dragging over new root\n                if (isNewRoot && opt.group !== pointElRoot.data('nestable-group')) {\n                    return;\n                }\n\n                // fixed item's depth, use for some list has specific type, eg:'Volume, Section, Chapter ...'\n                if (this.options.fixedDepth && this.dragDepth + 1 !== this.pointEl.parents(opt.listNodeName).length) {\n                    return;\n                }\n\n                // check depth limit\n                depth = this.dragDepth - 1 + this.pointEl.parents(opt.listNodeName).length;\n                if (depth > opt.maxDepth) {\n                    return;\n                }\n                var before = e.pageY < (this.pointEl.offset().top + this.pointEl.height() / 2);\n                parent = this.placeEl.parent();\n                // if empty create new list to replace empty placeholder\n                if (isEmpty) {\n                    list = $(document.createElement(opt.listNodeName)).addClass(opt.listClass);\n                    list.append(this.placeEl);\n                    this.pointEl.replaceWith(list);\n                }\n                else if (before) {\n                    this.pointEl.before(this.placeEl);\n                }\n                else {\n                    this.pointEl.after(this.placeEl);\n                }\n                if (!parent.children().length) {\n                    this.unsetParent(parent.parent());\n                }\n                if (!this.dragRootEl.find(opt.itemNodeName).length) {\n                    this.appendEmptyElement(this.dragRootEl);\n                }\n                // parent root list has changed\n                this.dragRootEl = pointElRoot;\n                if (isNewRoot) {\n                    this.hasNewRoot = this.el[0] !== this.dragRootEl[0];\n                }\n            }\n        },\n\n        // Append the .dd-empty div to the list so it can be populated and styled\n        appendEmptyElement: function(element) {\n            element.append('<div class=\"' + this.options.emptyClass + '\"/>');\n        }\n    };\n\n    $.fn.nestable = function(params) {\n        var lists  = this,\n            retval = this,\n            args   = arguments;\n\n        if (!('Nestable' in window)) {\n            window.Nestable = {};\n            Nestable.counter = 0;\n        }\n\n        lists.each(function() {\n            var plugin = $(this).data(\"nestable\");\n\n            if (!plugin) {\n                Nestable.counter++;\n                $(this).data(\"nestable\", new Plugin(this, params));\n                $(this).data(\"nestable-id\", Nestable.counter);\n            }\n            else {\n                if (typeof params === 'string' && typeof plugin[params] === 'function') {\n                    if (args.length > 1){\n                        var pluginArgs = [];\n                        for (var i = 1; i < args.length; i++) {\n                            pluginArgs.push(args[i]);\n                        }\n                        retval = plugin[params].apply(plugin, pluginArgs);\n                    }\n                    else {\n                        retval = plugin[params]();\n                    }\n                }\n            }\n        });\n\n        return retval || lists;\n    };\n\n})(window.jQuery || window.Zepto, window, document);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9Nb2R1bGVzL01lbnUvbm9kZV9tb2R1bGVzL25lc3RhYmxlMi9qcXVlcnkubmVzdGFibGUuanM/Yzg1NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHlDQUF5QyxvREFBb0Q7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHNDQUFzQztBQUN0Qyx5Q0FBeUM7QUFDekMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEM7O0FBRUEsa0VBQWtFLGVBQWUsRUFBRTtBQUNuRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYix5Q0FBeUMsd0JBQXdCLEVBQUU7QUFDbkU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLG1FQUFtRTtBQUNqRzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQSxvR0FBb0c7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpQkFBaUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBLENBQUMiLCJmaWxlIjoiLi9Nb2R1bGVzL01lbnUvbm9kZV9tb2R1bGVzL25lc3RhYmxlMi9qcXVlcnkubmVzdGFibGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE5lc3RhYmxlIGpRdWVyeSBQbHVnaW4gLSBDb3B5cmlnaHQgKGMpIDIwMTQgUmFtb24gU21pdCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9SYW1vblNtaXQvTmVzdGFibGVcbiAqL1xuXG4oZnVuY3Rpb24oJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XG4gICAgdmFyIGhhc1RvdWNoID0gJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgQ1NTIHBvaW50ZXItZXZlbnRzIHByb3BlcnR5XG4gICAgICogZXZlbnRzIGFyZSBub3JtYWxseSBkaXNhYmxlZCBvbiB0aGUgZHJhZ2dpbmcgZWxlbWVudCB0byBhdm9pZCBjb25mbGljdHNcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vYXVzaS9GZWF0dXJlLWRldGVjdGlvbi10ZWNobmlxdWUtZm9yLXBvaW50ZXItZXZlbnRzL2Jsb2IvbWFzdGVyL21vZGVybml6ci1wb2ludGVyZXZlbnRzLmpzXG4gICAgICovXG4gICAgdmFyIGhhc1BvaW50ZXJFdmVudHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIGlmICghKCdwb2ludGVyRXZlbnRzJyBpbiBlbC5zdHlsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xuICAgICAgICBlbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ3gnO1xuICAgICAgICBkb2NFbC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgIHZhciBzdXBwb3J0cyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlICYmIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLCAnJykucG9pbnRlckV2ZW50cyA9PT0gJ2F1dG8nO1xuICAgICAgICBkb2NFbC5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgIHJldHVybiAhIXN1cHBvcnRzO1xuICAgIH0pKCk7XG5cbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgIGNvbnRlbnRDYWxsYmFjazogZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtLmNvbnRlbnQgfHwgJycgPyBpdGVtLmNvbnRlbnQgOiBpdGVtLmlkO30sXG4gICAgICAgIGxpc3ROb2RlTmFtZTogJ29sJyxcbiAgICAgICAgaXRlbU5vZGVOYW1lOiAnbGknLFxuICAgICAgICBoYW5kbGVOb2RlTmFtZTogJ2RpdicsXG4gICAgICAgIGNvbnRlbnROb2RlTmFtZTogJ3NwYW4nLFxuICAgICAgICByb290Q2xhc3M6ICdkZCcsXG4gICAgICAgIGxpc3RDbGFzczogJ2RkLWxpc3QnLFxuICAgICAgICBpdGVtQ2xhc3M6ICdkZC1pdGVtJyxcbiAgICAgICAgZHJhZ0NsYXNzOiAnZGQtZHJhZ2VsJyxcbiAgICAgICAgaGFuZGxlQ2xhc3M6ICdkZC1oYW5kbGUnLFxuICAgICAgICBjb250ZW50Q2xhc3M6ICdkZC1jb250ZW50JyxcbiAgICAgICAgY29sbGFwc2VkQ2xhc3M6ICdkZC1jb2xsYXBzZWQnLFxuICAgICAgICBwbGFjZUNsYXNzOiAnZGQtcGxhY2Vob2xkZXInLFxuICAgICAgICBub0RyYWdDbGFzczogJ2RkLW5vZHJhZycsXG4gICAgICAgIG5vQ2hpbGRyZW5DbGFzczogJ2RkLW5vY2hpbGRyZW4nLFxuICAgICAgICBlbXB0eUNsYXNzOiAnZGQtZW1wdHknLFxuICAgICAgICBleHBhbmRCdG5IVE1MOiAnPGJ1dHRvbiBjbGFzcz1cImRkLWV4cGFuZFwiIGRhdGEtYWN0aW9uPVwiZXhwYW5kXCIgdHlwZT1cImJ1dHRvblwiPkV4cGFuZDwvYnV0dG9uPicsXG4gICAgICAgIGNvbGxhcHNlQnRuSFRNTDogJzxidXR0b24gY2xhc3M9XCJkZC1jb2xsYXBzZVwiIGRhdGEtYWN0aW9uPVwiY29sbGFwc2VcIiB0eXBlPVwiYnV0dG9uXCI+Q29sbGFwc2U8L2J1dHRvbj4nLFxuICAgICAgICBncm91cDogMCxcbiAgICAgICAgbWF4RGVwdGg6IDUsXG4gICAgICAgIHRocmVzaG9sZDogMjAsXG4gICAgICAgIGZpeGVkRGVwdGg6IGZhbHNlLCAvL2ZpeGVkIGl0ZW0ncyBkZXB0aFxuICAgICAgICBmaXhlZDogZmFsc2UsXG4gICAgICAgIGluY2x1ZGVDb250ZW50OiBmYWxzZSxcbiAgICAgICAgc2Nyb2xsOiBmYWxzZSxcbiAgICAgICAgc2Nyb2xsU2Vuc2l0aXZpdHk6IDEsXG4gICAgICAgIHNjcm9sbFNwZWVkOiA1LFxuICAgICAgICBzY3JvbGxUcmlnZ2Vyczoge1xuICAgICAgICAgICAgdG9wOiA0MCxcbiAgICAgICAgICAgIGxlZnQ6IDQwLFxuICAgICAgICAgICAgcmlnaHQ6IC00MCxcbiAgICAgICAgICAgIGJvdHRvbTogLTQwXG4gICAgICAgIH0sXG4gICAgICAgIGVmZmVjdDoge1xuICAgICAgICAgICAgYW5pbWF0aW9uOiAnbm9uZScsXG4gICAgICAgICAgICB0aW1lOiAnc2xvdydcbiAgICAgICAgfSxcbiAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKGwsIGUsIHApIHt9LFxuICAgICAgICBvbkRyYWdTdGFydDogZnVuY3Rpb24obCwgZSwgcCkge30sXG4gICAgICAgIGJlZm9yZURyYWdTdG9wOiBmdW5jdGlvbihsLCBlLCBwKSB7fSxcbiAgICAgICAgbGlzdFJlbmRlcmVyOiBmdW5jdGlvbihjaGlsZHJlbiwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGh0bWwgPSAnPCcgKyBvcHRpb25zLmxpc3ROb2RlTmFtZSArICcgY2xhc3M9XCInICsgb3B0aW9ucy5saXN0Q2xhc3MgKyAnXCI+JztcbiAgICAgICAgICAgIGh0bWwgKz0gY2hpbGRyZW47XG4gICAgICAgICAgICBodG1sICs9ICc8LycgKyBvcHRpb25zLmxpc3ROb2RlTmFtZSArICc+JztcblxuICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgIH0sXG4gICAgICAgIGl0ZW1SZW5kZXJlcjogZnVuY3Rpb24oaXRlbV9hdHRycywgY29udGVudCwgY2hpbGRyZW4sIG9wdGlvbnMsIGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBpdGVtX2F0dHJzX3N0cmluZyA9ICQubWFwKGl0ZW1fYXR0cnMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyAnICsga2V5ICsgJz1cIicgKyB2YWx1ZSArICdcIic7XG4gICAgICAgICAgICB9KS5qb2luKCcgJyk7XG5cbiAgICAgICAgICAgIHZhciBodG1sID0gJzwnICsgb3B0aW9ucy5pdGVtTm9kZU5hbWUgKyBpdGVtX2F0dHJzX3N0cmluZyArICc+JztcbiAgICAgICAgICAgIGh0bWwgKz0gJzwnICsgb3B0aW9ucy5oYW5kbGVOb2RlTmFtZSArICcgY2xhc3M9XCInICsgb3B0aW9ucy5oYW5kbGVDbGFzcyArICdcIj4nO1xuICAgICAgICAgICAgaHRtbCArPSAnPCcgKyBvcHRpb25zLmNvbnRlbnROb2RlTmFtZSArICcgY2xhc3M9XCInICsgb3B0aW9ucy5jb250ZW50Q2xhc3MgKyAnXCI+JztcbiAgICAgICAgICAgIGh0bWwgKz0gY29udGVudDtcbiAgICAgICAgICAgIGh0bWwgKz0gJzwvJyArIG9wdGlvbnMuY29udGVudE5vZGVOYW1lICsgJz4nO1xuICAgICAgICAgICAgaHRtbCArPSAnPC8nICsgb3B0aW9ucy5oYW5kbGVOb2RlTmFtZSArICc+JztcbiAgICAgICAgICAgIGh0bWwgKz0gY2hpbGRyZW47XG4gICAgICAgICAgICBodG1sICs9ICc8LycgKyBvcHRpb25zLml0ZW1Ob2RlTmFtZSArICc+JztcblxuICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gUGx1Z2luKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy53ICA9ICQoZG9jdW1lbnQpO1xuICAgICAgICB0aGlzLmVsID0gJChlbGVtZW50KTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgZGVmYXVsdHM7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucm9vdENsYXNzICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yb290Q2xhc3MgIT09ICdkZCcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubGlzdENsYXNzICAgICAgID0gb3B0aW9ucy5saXN0Q2xhc3MgPyBvcHRpb25zLmxpc3RDbGFzcyA6IG9wdGlvbnMucm9vdENsYXNzICsgJy1saXN0JztcbiAgICAgICAgICAgIG9wdGlvbnMuaXRlbUNsYXNzICAgICAgID0gb3B0aW9ucy5pdGVtQ2xhc3MgPyBvcHRpb25zLml0ZW1DbGFzcyA6IG9wdGlvbnMucm9vdENsYXNzICsgJy1pdGVtJztcbiAgICAgICAgICAgIG9wdGlvbnMuZHJhZ0NsYXNzICAgICAgID0gb3B0aW9ucy5kcmFnQ2xhc3MgPyBvcHRpb25zLmRyYWdDbGFzcyA6IG9wdGlvbnMucm9vdENsYXNzICsgJy1kcmFnZWwnO1xuICAgICAgICAgICAgb3B0aW9ucy5oYW5kbGVDbGFzcyAgICAgPSBvcHRpb25zLmhhbmRsZUNsYXNzID8gb3B0aW9ucy5oYW5kbGVDbGFzcyA6IG9wdGlvbnMucm9vdENsYXNzICsgJy1oYW5kbGUnO1xuICAgICAgICAgICAgb3B0aW9ucy5jb2xsYXBzZWRDbGFzcyAgPSBvcHRpb25zLmNvbGxhcHNlZENsYXNzID8gb3B0aW9ucy5jb2xsYXBzZWRDbGFzcyA6IG9wdGlvbnMucm9vdENsYXNzICsgJy1jb2xsYXBzZWQnO1xuICAgICAgICAgICAgb3B0aW9ucy5wbGFjZUNsYXNzICAgICAgPSBvcHRpb25zLnBsYWNlQ2xhc3MgPyBvcHRpb25zLnBsYWNlQ2xhc3MgOiBvcHRpb25zLnJvb3RDbGFzcyArICctcGxhY2Vob2xkZXInO1xuICAgICAgICAgICAgb3B0aW9ucy5ub0RyYWdDbGFzcyAgICAgPSBvcHRpb25zLm5vRHJhZ0NsYXNzID8gb3B0aW9ucy5ub0RyYWdDbGFzcyA6IG9wdGlvbnMucm9vdENsYXNzICsgJy1ub2RyYWcnO1xuICAgICAgICAgICAgb3B0aW9ucy5ub0NoaWxkcmVuQ2xhc3MgPSBvcHRpb25zLm5vQ2hpbGRyZW5DbGFzcyA/IG9wdGlvbnMubm9DaGlsZHJlbkNsYXNzIDogb3B0aW9ucy5yb290Q2xhc3MgKyAnLW5vY2hpbGRyZW4nO1xuICAgICAgICAgICAgb3B0aW9ucy5lbXB0eUNsYXNzICAgICAgPSBvcHRpb25zLmVtcHR5Q2xhc3MgPyBvcHRpb25zLmVtcHR5Q2xhc3MgOiBvcHRpb25zLnJvb3RDbGFzcyArICctZW1wdHknO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBidWlsZCBIVE1MIGZyb20gc2VyaWFsaXplZCBKU09OIGlmIHBhc3NlZFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmpzb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fYnVpbGQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cblxuICAgIFBsdWdpbi5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbGlzdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIGxpc3QucmVzZXQoKTtcbiAgICAgICAgICAgIGxpc3QuZWwuZGF0YSgnbmVzdGFibGUtZ3JvdXAnLCB0aGlzLm9wdGlvbnMuZ3JvdXApO1xuICAgICAgICAgICAgbGlzdC5wbGFjZUVsID0gJCgnPGRpdiBjbGFzcz1cIicgKyBsaXN0Lm9wdGlvbnMucGxhY2VDbGFzcyArICdcIi8+Jyk7XG5cbiAgICAgICAgICAgIHZhciBpdGVtcyA9IHRoaXMuZWwuZmluZChsaXN0Lm9wdGlvbnMuaXRlbU5vZGVOYW1lKTtcbiAgICAgICAgICAgICQuZWFjaChpdGVtcywgZnVuY3Rpb24oaywgZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9ICQoZWwpLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBpdGVtLnBhcmVudCgpO1xuICAgICAgICAgICAgICAgIGxpc3Quc2V0UGFyZW50KGl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQuaGFzQ2xhc3MobGlzdC5vcHRpb25zLmNvbGxhcHNlZENsYXNzKSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0LmNvbGxhcHNlSXRlbShwYXJlbnQucGFyZW50KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBBcHBlbmQgdGhlIC5kZC1lbXB0eSBkaXYgaWYgdGhlIGxpc3QgZG9uJ3QgaGF2ZSBhbnkgaXRlbXMgb24gaW5pdFxuICAgICAgICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVtcHR5RWxlbWVudCh0aGlzLmVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGlzdC5lbC5vbignY2xpY2snLCAnYnV0dG9uJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0LmRyYWdFbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSAkKGUuY3VycmVudFRhcmdldCksXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9IHRhcmdldC5kYXRhKCdhY3Rpb24nKSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHRhcmdldC5wYXJlbnRzKGxpc3Qub3B0aW9ucy5pdGVtTm9kZU5hbWUpLmVxKDApO1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09ICdjb2xsYXBzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5jb2xsYXBzZUl0ZW0oaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09ICdleHBhbmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QuZXhwYW5kSXRlbShpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIG9uU3RhcnRFdmVudCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlID0gJChlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYW5kbGUuaGFzQ2xhc3MobGlzdC5vcHRpb25zLmhhbmRsZUNsYXNzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlLmNsb3Nlc3QoJy4nICsgbGlzdC5vcHRpb25zLm5vRHJhZ0NsYXNzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSBoYW5kbGUuY2xvc2VzdCgnLicgKyBsaXN0Lm9wdGlvbnMuaGFuZGxlQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZS5sZW5ndGggfHwgbGlzdC5kcmFnRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxpc3QuaXNUb3VjaCA9IC9edG91Y2gvLnRlc3QoZS50eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAobGlzdC5pc1RvdWNoICYmIGUudG91Y2hlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBsaXN0LmRyYWdTdGFydChlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBvbk1vdmVFdmVudCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdC5kcmFnRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBsaXN0LmRyYWdNb3ZlKGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBvbkVuZEV2ZW50ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0LmRyYWdFbCkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QuZHJhZ1N0b3AoZS50b3VjaGVzID8gZS5jaGFuZ2VkVG91Y2hlc1swXSA6IGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChoYXNUb3VjaCkge1xuICAgICAgICAgICAgICAgIGxpc3QuZWxbMF0uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uU3RhcnRFdmVudCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvbk1vdmVFdmVudCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uRW5kRXZlbnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCBvbkVuZEV2ZW50LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpc3QuZWwub24oJ21vdXNlZG93bicsIG9uU3RhcnRFdmVudCk7XG4gICAgICAgICAgICBsaXN0Lncub24oJ21vdXNlbW92ZScsIG9uTW92ZUV2ZW50KTtcbiAgICAgICAgICAgIGxpc3Qudy5vbignbW91c2V1cCcsIG9uRW5kRXZlbnQpO1xuXG4gICAgICAgICAgICB2YXIgZGVzdHJveU5lc3RhYmxlID0gZnVuY3Rpb24oKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChoYXNUb3VjaCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0LmVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblN0YXJ0RXZlbnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uTW92ZUV2ZW50LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uRW5kRXZlbnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgb25FbmRFdmVudCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxpc3QuZWwub2ZmKCdtb3VzZWRvd24nLCBvblN0YXJ0RXZlbnQpO1xuICAgICAgICAgICAgICAgIGxpc3Qudy5vZmYoJ21vdXNlbW92ZScsIG9uTW92ZUV2ZW50KTtcbiAgICAgICAgICAgICAgICBsaXN0Lncub2ZmKCdtb3VzZXVwJywgb25FbmRFdmVudCk7XG5cbiAgICAgICAgICAgICAgICBsaXN0LmVsLm9mZignY2xpY2snKTtcbiAgICAgICAgICAgICAgICBsaXN0LmVsLnVuYmluZCgnZGVzdHJveS1uZXN0YWJsZScpO1xuXG4gICAgICAgICAgICAgICAgbGlzdC5lbC5kYXRhKFwibmVzdGFibGVcIiwgbnVsbCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBsaXN0LmVsLmJpbmQoJ2Rlc3Ryb3ktbmVzdGFibGUnLCBkZXN0cm95TmVzdGFibGUpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5lbC50cmlnZ2VyKCdkZXN0cm95LW5lc3RhYmxlJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkOiBmdW5jdGlvbiAoaXRlbSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGxpc3RDbGFzc1NlbGVjdG9yID0gJy4nICsgdGhpcy5vcHRpb25zLmxpc3RDbGFzcztcbiAgICAgICAgICAgIHZhciB0cmVlID0gJCh0aGlzLmVsKS5jaGlsZHJlbihsaXN0Q2xhc3NTZWxlY3Rvcik7XG5cbiAgICAgICAgICAgIGlmIChpdGVtLnBhcmVudF9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdHJlZSA9IHRyZWUuZmluZCgnW2RhdGEtaWQ9XCInICsgaXRlbS5wYXJlbnRfaWQgKyAnXCJdJyk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGl0ZW0ucGFyZW50X2lkO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRyZWUuY2hpbGRyZW4obGlzdENsYXNzU2VsZWN0b3IpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0cmVlID0gdHJlZS5hcHBlbmQodGhpcy5vcHRpb25zLmxpc3RSZW5kZXJlcignJywgdGhpcy5vcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJlZSA9IHRyZWUuZmluZChsaXN0Q2xhc3NTZWxlY3RvciArICc6Zmlyc3QnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBhcmVudCh0cmVlLnBhcmVudCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJlZS5hcHBlbmQodGhpcy5fYnVpbGRJdGVtKGl0ZW0sIHRoaXMub3B0aW9ucykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlcGxhY2U6IGZ1bmN0aW9uIChpdGVtKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaHRtbCA9IHRoaXMuX2J1aWxkSXRlbShpdGVtLCB0aGlzLm9wdGlvbnMpO1xuXG4gICAgICAgICAgICB0aGlzLl9nZXRJdGVtQnlJZChpdGVtLmlkKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlV2l0aChodG1sKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvL3JlbW92ZXMgaXRlbSBhbmQgYWRkaXRpb25hbCBlbGVtZW50cyBmcm9tIGxpc3RcbiAgICAgICAgcmVtb3ZlSXRlbTogZnVuY3Rpb24gKGl0ZW0pe1xuICAgICAgICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgZWwgICA9IHRoaXMuZWw7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBpdGVtXG4gICAgICAgICAgICBpdGVtID0gaXRlbSB8fCB0aGlzO1xuICAgICAgICAgICAgaXRlbS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGVtcHR5IGNoaWxkcmVuIGxpc3RzXG4gICAgICAgICAgICB2YXIgZW1wdHlMaXN0c1NlbGVjdG9yID0gJy4nICsgb3B0cy5saXN0Q2xhc3NcbiAgICAgICAgICAgICAgICArICcgLicgKyBvcHRzLmxpc3RDbGFzcyArICc6bm90KDpoYXMoKikpJztcbiAgICAgICAgICAgICQoZWwpLmZpbmQoZW1wdHlMaXN0c1NlbGVjdG9yKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGJ1dHRvbnMgaWYgcGFyZW50cyBkbyBub3QgaGF2ZSBjaGlsZHJlblxuICAgICAgICAgICAgdmFyIGJ1dHRvbnNTZWxlY3RvciA9ICdbZGF0YS1hY3Rpb249XCJleHBhbmRcIl0sIFtkYXRhLWFjdGlvbj1cImNvbGxhcHNlXCJdJztcbiAgICAgICAgICAgICQoZWwpLmZpbmQoYnV0dG9uc1NlbGVjdG9yKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzaWJsaW5ncyA9ICQodGhpcykuc2libGluZ3MoJy4nICsgb3B0cy5saXN0Q2xhc3MpO1xuICAgICAgICAgICAgICAgIGlmIChzaWJsaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvL3JlbW92ZXMgaXRlbSBieSBpdGVtSWQgYW5kIHJ1biBjYWxsYmFjayBhdCB0aGUgZW5kXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGl0ZW1JZCwgY2FsbGJhY2spXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgdmFyIGxpc3QgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9nZXRJdGVtQnlJZChpdGVtSWQpO1xuXG4gICAgICAgICAgICAvL2FuaW1hdGlvbiBzdHlsZVxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IG9wdHMuZWZmZWN0LmFuaW1hdGlvbiB8fCAnZmFkZSc7XG5cbiAgICAgICAgICAgIC8vYW5pbWF0aW9uIHRpbWVcbiAgICAgICAgICAgIHZhciB0aW1lID0gb3B0cy5lZmZlY3QudGltZSB8fCAnc2xvdyc7XG5cbiAgICAgICAgICAgIC8vYWRkIGZhZGVPdXQgZWZmZWN0IHdoZW4gcmVtb3ZpbmdcbiAgICAgICAgICAgIGlmIChhbmltYXRpb24gPT09ICdmYWRlJyl7XG4gICAgICAgICAgICAgICAgaXRlbS5mYWRlT3V0KHRpbWUsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QucmVtb3ZlSXRlbShpdGVtKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlSXRlbShpdGVtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vcmVtb3ZlcyBhbGwgaXRlbXMgZnJvbSB0aGUgbGlzdCBhbmQgcnVuIGNhbGxiYWNrIGF0IHRoZSBlbmRcbiAgICAgICAgcmVtb3ZlQWxsOiBmdW5jdGlvbihjYWxsYmFjayl7XG5cbiAgICAgICAgICAgIHZhciBsaXN0ICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgb3B0cyAgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgbm9kZSAgPSBsaXN0LmVsLmZpbmQob3B0cy5saXN0Tm9kZU5hbWUpLmZpcnN0KCksXG4gICAgICAgICAgICAgICAgaXRlbXMgPSBub2RlLmNoaWxkcmVuKG9wdHMuaXRlbU5vZGVOYW1lKTtcblxuICAgICAgICAgICAgLy9hbmltYXRpb24gc3R5bGVcbiAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSBvcHRzLmVmZmVjdC5hbmltYXRpb24gfHwgJ2ZhZGUnO1xuXG4gICAgICAgICAgICAvL2FuaW1hdGlvbiB0aW1lXG4gICAgICAgICAgICB2YXIgdGltZSA9IG9wdHMuZWZmZWN0LnRpbWUgfHwgJ3Nsb3cnO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiByZW1vdmUoKXtcbiAgICAgICAgICAgICAgICAvL1JlbW92ZXMgZWFjaCBpdGVtIGFuZCBpdHMgY2hpbGRyZW4uXG4gICAgICAgICAgICAgICAgaXRlbXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5yZW1vdmVJdGVtKCQodGhpcykpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vTm93IHdlIGNhbiBhZ2FpbiBzaG93IG91ciBub2RlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBub2RlLnNob3coKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vYWRkIGZhZGVPdXQgZWZmZWN0IHdoZW4gcmVtb3ZpbmdcbiAgICAgICAgICAgIGlmIChhbmltYXRpb24gPT09ICdmYWRlJyl7XG4gICAgICAgICAgICAgICAgbm9kZS5mYWRlT3V0KHRpbWUsIHJlbW92ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0SXRlbUJ5SWQ6IGZ1bmN0aW9uKGl0ZW1JZCkge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcy5lbCkuY2hpbGRyZW4oJy4nICsgdGhpcy5vcHRpb25zLmxpc3RDbGFzcylcbiAgICAgICAgICAgICAgICAuZmluZCgnW2RhdGEtaWQ9XCInICsgaXRlbUlkICsgJ1wiXScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9idWlsZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIganNvbiA9IHRoaXMub3B0aW9ucy5qc29uO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAganNvbiA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICQodGhpcy5lbCkuaHRtbCh0aGlzLl9idWlsZExpc3QoanNvbiwgdGhpcy5vcHRpb25zKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2J1aWxkTGlzdDogZnVuY3Rpb24oaXRlbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghaXRlbXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9ICcnO1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICAkLmVhY2goaXRlbXMsIGZ1bmN0aW9uKGluZGV4LCBzdWIpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiArPSB0aGF0Ll9idWlsZEl0ZW0oc3ViLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5saXN0UmVuZGVyZXIoY2hpbGRyZW4sIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9idWlsZEl0ZW06IGZ1bmN0aW9uKGl0ZW0sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGVzY2FwZUh0bWwodGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXAgPSB7XG4gICAgICAgICAgICAgICAgICAgICcmJzogJyZhbXA7JyxcbiAgICAgICAgICAgICAgICAgICAgJzwnOiAnJmx0OycsXG4gICAgICAgICAgICAgICAgICAgICc+JzogJyZndDsnLFxuICAgICAgICAgICAgICAgICAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAgICAgICAgICAgICAgICAgXCInXCI6ICcmIzAzOTsnXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0ICsgXCJcIi5yZXBsYWNlKC9bJjw+XCInXS9nLCBmdW5jdGlvbihtKSB7IHJldHVybiBtYXBbbV07IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBmaWx0ZXJDbGFzc2VzKGNsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3X2NsYXNzZXMgPSB7fTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZHVwbGljYXRlc1xuICAgICAgICAgICAgICAgICAgICBuZXdfY2xhc3Nlc1tjbGFzc2VzW2tdXSA9IGNsYXNzZXNba107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld19jbGFzc2VzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVDbGFzc2VzU3RyaW5nKGl0ZW0sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IGl0ZW0uY2xhc3NlcyB8fCB7fTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2xhc3NlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NlcyA9IFtjbGFzc2VzXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgaXRlbV9jbGFzc2VzID0gZmlsdGVyQ2xhc3NlcyhjbGFzc2VzKTtcbiAgICAgICAgICAgICAgICBpdGVtX2NsYXNzZXNbb3B0aW9ucy5pdGVtQ2xhc3NdID0gb3B0aW9ucy5pdGVtQ2xhc3M7XG5cbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgY2xhc3Mgc3RyaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuICQubWFwKGl0ZW1fY2xhc3NlcywgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgfSkuam9pbignICcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVEYXRhQXR0cnMoYXR0cikge1xuICAgICAgICAgICAgICAgIGF0dHIgPSAkLmV4dGVuZCh7fSwgYXR0cik7XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgYXR0ci5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICBkZWxldGUgYXR0ci5jbGFzc2VzO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyLmNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgZGF0YV9hdHRycyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgJC5lYWNoKGF0dHIsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YV9hdHRyc1tcImRhdGEtXCIgKyBrZXldID0gZXNjYXBlSHRtbCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YV9hdHRycztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGl0ZW1fYXR0cnMgPSBjcmVhdGVEYXRhQXR0cnMoaXRlbSk7XG4gICAgICAgICAgICBpdGVtX2F0dHJzW1wiY2xhc3NcIl0gPSBjcmVhdGVDbGFzc2VzU3RyaW5nKGl0ZW0sIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICB2YXIgY29udGVudCA9IG9wdGlvbnMuY29udGVudENhbGxiYWNrKGl0ZW0pO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fYnVpbGRMaXN0KGl0ZW0uY2hpbGRyZW4sIG9wdGlvbnMpO1xuICAgICAgICAgICAgdmFyIGh0bWwgPSAkKG9wdGlvbnMuaXRlbVJlbmRlcmVyKGl0ZW1fYXR0cnMsIGNvbnRlbnQsIGNoaWxkcmVuLCBvcHRpb25zLCBpdGVtKSk7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0UGFyZW50KGh0bWwpO1xuXG4gICAgICAgICAgICByZXR1cm4gaHRtbFswXS5vdXRlckhUTUw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2VyaWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkYXRhLCBsaXN0ID0gdGhpcywgc3RlcCA9IGZ1bmN0aW9uKGxldmVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFycmF5ID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gbGV2ZWwuY2hpbGRyZW4obGlzdC5vcHRpb25zLml0ZW1Ob2RlTmFtZSk7XG4gICAgICAgICAgICAgICAgaXRlbXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpID0gJCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSAkLmV4dGVuZCh7fSwgbGkuZGF0YSgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YiA9IGxpLmNoaWxkcmVuKGxpc3Qub3B0aW9ucy5saXN0Tm9kZU5hbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0Lm9wdGlvbnMuaW5jbHVkZUNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gbGkuZmluZCgnLicgKyBsaXN0Lm9wdGlvbnMuY29udGVudENsYXNzKS5odG1sKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNoaWxkcmVuID0gc3RlcChzdWIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFycmF5LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRhdGEgPSBzdGVwKGxpc3QuZWwuZmluZChsaXN0Lm9wdGlvbnMubGlzdE5vZGVOYW1lKS5maXJzdCgpKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFzTmVzdGVkU2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcywgbyA9IGxpc3Qub3B0aW9ucywgZGVwdGggPSAtMSwgcmV0ID0gW10sIGxmdCA9IDE7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBsaXN0LmVsLmZpbmQoby5saXN0Tm9kZU5hbWUpLmZpcnN0KCkuY2hpbGRyZW4oby5pdGVtTm9kZU5hbWUpO1xuXG4gICAgICAgICAgICBpdGVtcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBsZnQgPSB0cmF2ZXJzZSh0aGlzLCBkZXB0aCArIDEsIGxmdCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0ID0gcmV0LnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIChhLmxmdCAtIGIubGZ0KTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB0cmF2ZXJzZShpdGVtLCBkZXB0aCwgbGZ0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJndCA9IGxmdCArIDEsIGlkLCBwaWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoJChpdGVtKS5jaGlsZHJlbihvLmxpc3ROb2RlTmFtZSkuY2hpbGRyZW4oby5pdGVtTm9kZU5hbWUpLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgICAgICQoaXRlbSkuY2hpbGRyZW4oby5saXN0Tm9kZU5hbWUpLmNoaWxkcmVuKG8uaXRlbU5vZGVOYW1lKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJndCA9IHRyYXZlcnNlKCQodGhpcyksIGRlcHRoLCByZ3QpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZCA9ICQoaXRlbSkuYXR0cignZGF0YS1pZCcpO1xuICAgICAgICAgICAgICAgIGlmIChpc0ludChpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBwYXJzZUludChpZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGlkID0gJChpdGVtKS5wYXJlbnQoby5saXN0Tm9kZU5hbWUpLnBhcmVudChvLml0ZW1Ob2RlTmFtZSkuYXR0cignZGF0YS1pZCcpIHx8ICcnO1xuICAgICAgICAgICAgICAgIGlmIChpc0ludChwaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gcGFyc2VJbnQocGlkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goe1wiaWRcIjogaWQsIFwicGFyZW50X2lkXCI6IHBpZCwgXCJkZXB0aFwiOiBkZXB0aCwgXCJsZnRcIjogbGZ0LCBcInJndFwiOiByZ3R9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZnQgPSByZ3QgKyAxO1xuICAgICAgICAgICAgICAgIHJldHVybiBsZnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzSW50KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQuaXNOdW1lcmljKHZhbHVlKSAmJiBNYXRoLmZsb29yKHZhbHVlKSA9PSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZXR1cm5PcHRpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2VyaWFsaXNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvSGllcmFyY2h5OiBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIHZhciBvID0gJC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgcmV0ID0gW107XG5cbiAgICAgICAgICAgICQodGhpcy5lbGVtZW50KS5jaGlsZHJlbihvLml0ZW1zKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBsZXZlbCA9IF9yZWN1cnNpdmVJdGVtcyh0aGlzKTtcbiAgICAgICAgICAgICAgICByZXQucHVzaChsZXZlbCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gX3JlY3Vyc2l2ZUl0ZW1zKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSAoJChpdGVtKS5hdHRyKG8uYXR0cmlidXRlIHx8ICdpZCcpIHx8ICcnKS5tYXRjaChvLmV4cHJlc3Npb24gfHwgKC8oLispWy09X10oLispLykpO1xuICAgICAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImlkXCI6IGlkWzJdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICgkKGl0ZW0pLmNoaWxkcmVuKG8ubGlzdFR5cGUpLmNoaWxkcmVuKG8uaXRlbXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJdGVtLmNoaWxkcmVuID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAkKGl0ZW0pLmNoaWxkcmVuKG8ubGlzdFR5cGUpLmNoaWxkcmVuKG8uaXRlbXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxldmVsID0gX3JlY3Vyc2l2ZUl0ZW1zKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJdGVtLmNoaWxkcmVuLnB1c2gobGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJdGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0b0FycmF5OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgdmFyIG8gPSAkLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCB0aGlzKSxcbiAgICAgICAgICAgICAgICBzRGVwdGggPSBvLnN0YXJ0RGVwdGhDb3VudCB8fCAwLFxuICAgICAgICAgICAgICAgIHJldCA9IFtdLFxuICAgICAgICAgICAgICAgIGxlZnQgPSAyLFxuICAgICAgICAgICAgICAgIGxpc3QgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBsaXN0LmVsLmZpbmQobGlzdC5vcHRpb25zLmxpc3ROb2RlTmFtZSkuZmlyc3QoKTtcblxuICAgICAgICAgICAgdmFyIGl0ZW1zID0gZWxlbWVudC5jaGlsZHJlbihsaXN0Lm9wdGlvbnMuaXRlbU5vZGVOYW1lKTtcbiAgICAgICAgICAgIGl0ZW1zLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IF9yZWN1cnNpdmVBcnJheSgkKHRoaXMpLCBzRGVwdGggKyAxLCBsZWZ0KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXQgPSByZXQuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhLmxlZnQgLSBiLmxlZnQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9yZWN1cnNpdmVBcnJheShpdGVtLCBkZXB0aCwgbGVmdCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gbGVmdCArIDEsXG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBwaWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5jaGlsZHJlbihvLm9wdGlvbnMubGlzdE5vZGVOYW1lKS5jaGlsZHJlbihvLm9wdGlvbnMuaXRlbU5vZGVOYW1lKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uY2hpbGRyZW4oby5vcHRpb25zLmxpc3ROb2RlTmFtZSkuY2hpbGRyZW4oby5vcHRpb25zLml0ZW1Ob2RlTmFtZSkuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gX3JlY3Vyc2l2ZUFycmF5KCQodGhpcyksIGRlcHRoLCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlkID0gaXRlbS5kYXRhKCkuaWQ7XG5cblxuICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PT0gc0RlcHRoICsgMSkge1xuICAgICAgICAgICAgICAgICAgICBwaWQgPSBvLnJvb3RJRDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRJdGVtID0gKGl0ZW0ucGFyZW50KG8ub3B0aW9ucy5saXN0Tm9kZU5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAucGFyZW50KG8ub3B0aW9ucy5pdGVtTm9kZU5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGF0YSgpKTtcbiAgICAgICAgICAgICAgICAgICAgcGlkID0gcGFyZW50SXRlbS5pZDtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImlkXCI6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJwYXJlbnRfaWRcIjogcGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkZXB0aFwiOiBkZXB0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibGVmdFwiOiBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJyaWdodFwiOiByaWdodFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZWZ0ID0gcmlnaHQgKyAxO1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5tb3VzZSA9IHtcbiAgICAgICAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgICAgICAgc3RhcnRYOiAwLFxuICAgICAgICAgICAgICAgIHN0YXJ0WTogMCxcbiAgICAgICAgICAgICAgICBsYXN0WDogMCxcbiAgICAgICAgICAgICAgICBsYXN0WTogMCxcbiAgICAgICAgICAgICAgICBub3dYOiAwLFxuICAgICAgICAgICAgICAgIG5vd1k6IDAsXG4gICAgICAgICAgICAgICAgZGlzdFg6IDAsXG4gICAgICAgICAgICAgICAgZGlzdFk6IDAsXG4gICAgICAgICAgICAgICAgZGlyQXg6IDAsXG4gICAgICAgICAgICAgICAgZGlyWDogMCxcbiAgICAgICAgICAgICAgICBkaXJZOiAwLFxuICAgICAgICAgICAgICAgIGxhc3REaXJYOiAwLFxuICAgICAgICAgICAgICAgIGxhc3REaXJZOiAwLFxuICAgICAgICAgICAgICAgIGRpc3RBeFg6IDAsXG4gICAgICAgICAgICAgICAgZGlzdEF4WTogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuaXNUb3VjaCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5tb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0VsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZHJhZ1Jvb3RFbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRyYWdEZXB0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLmhhc05ld1Jvb3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucG9pbnRFbCA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXhwYW5kSXRlbTogZnVuY3Rpb24obGkpIHtcbiAgICAgICAgICAgIGxpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5jb2xsYXBzZWRDbGFzcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29sbGFwc2VJdGVtOiBmdW5jdGlvbihsaSkge1xuICAgICAgICAgICAgdmFyIGxpc3RzID0gbGkuY2hpbGRyZW4odGhpcy5vcHRpb25zLmxpc3ROb2RlTmFtZSk7XG4gICAgICAgICAgICBpZiAobGlzdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGkuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmNvbGxhcHNlZENsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBleHBhbmRBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGxpc3QgPSB0aGlzO1xuICAgICAgICAgICAgbGlzdC5lbC5maW5kKGxpc3Qub3B0aW9ucy5pdGVtTm9kZU5hbWUpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5leHBhbmRJdGVtKCQodGhpcykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29sbGFwc2VBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGxpc3QgPSB0aGlzO1xuICAgICAgICAgICAgbGlzdC5lbC5maW5kKGxpc3Qub3B0aW9ucy5pdGVtTm9kZU5hbWUpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5jb2xsYXBzZUl0ZW0oJCh0aGlzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRQYXJlbnQ6IGZ1bmN0aW9uKGxpKSB7XG4gICAgICAgICAgICAvL0NoZWNrIGlmIGxpIGlzIGFuIGVsZW1lbnQgb2YgaXRlbU5vZGVOYW1lIHR5cGUgYW5kIGhhcyBjaGlsZHJlblxuICAgICAgICAgICAgaWYgKGxpLmlzKHRoaXMub3B0aW9ucy5pdGVtTm9kZU5hbWUpICYmIGxpLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5saXN0Tm9kZU5hbWUpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBOT1Qgc2hvd2luZyB0d28gb3IgbW9yZSBzZXRzIGRhdGEtYWN0aW9uIGJ1dHRvbnNcbiAgICAgICAgICAgICAgICBsaS5jaGlsZHJlbignW2RhdGEtYWN0aW9uXScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGxpLnByZXBlbmQoJCh0aGlzLm9wdGlvbnMuZXhwYW5kQnRuSFRNTCkpO1xuICAgICAgICAgICAgICAgIGxpLnByZXBlbmQoJCh0aGlzLm9wdGlvbnMuY29sbGFwc2VCdG5IVE1MKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5zZXRQYXJlbnQ6IGZ1bmN0aW9uKGxpKSB7XG4gICAgICAgICAgICBsaS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuY29sbGFwc2VkQ2xhc3MpO1xuICAgICAgICAgICAgbGkuY2hpbGRyZW4oJ1tkYXRhLWFjdGlvbl0nKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIGxpLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5saXN0Tm9kZU5hbWUpLnJlbW92ZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRyYWdTdGFydDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIG1vdXNlID0gdGhpcy5tb3VzZSxcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSAkKGUudGFyZ2V0KSxcbiAgICAgICAgICAgICAgICBkcmFnSXRlbSA9IHRhcmdldC5jbG9zZXN0KHRoaXMub3B0aW9ucy5pdGVtTm9kZU5hbWUpLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB0b3AgIDogZS5wYWdlWSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA6IGUucGFnZVhcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgY29udGludWVFeGVjdXRpb24gPSB0aGlzLm9wdGlvbnMub25EcmFnU3RhcnQuY2FsbCh0aGlzLCB0aGlzLmVsLCBkcmFnSXRlbSwgcG9zaXRpb24pO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRpbnVlRXhlY3V0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBjb250aW51ZUV4ZWN1dGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucGxhY2VFbC5jc3MoJ2hlaWdodCcsIGRyYWdJdGVtLmhlaWdodCgpKTtcblxuICAgICAgICAgICAgbW91c2Uub2Zmc2V0WCA9IGUucGFnZVggLSBkcmFnSXRlbS5vZmZzZXQoKS5sZWZ0O1xuICAgICAgICAgICAgbW91c2Uub2Zmc2V0WSA9IGUucGFnZVkgLSBkcmFnSXRlbS5vZmZzZXQoKS50b3A7XG4gICAgICAgICAgICBtb3VzZS5zdGFydFggPSBtb3VzZS5sYXN0WCA9IGUucGFnZVg7XG4gICAgICAgICAgICBtb3VzZS5zdGFydFkgPSBtb3VzZS5sYXN0WSA9IGUucGFnZVk7XG5cbiAgICAgICAgICAgIHRoaXMuZHJhZ1Jvb3RFbCA9IHRoaXMuZWw7XG4gICAgICAgICAgICB0aGlzLmRyYWdFbCA9ICQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm9wdGlvbnMubGlzdE5vZGVOYW1lKSkuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmxpc3RDbGFzcyArICcgJyArIHRoaXMub3B0aW9ucy5kcmFnQ2xhc3MpO1xuICAgICAgICAgICAgdGhpcy5kcmFnRWwuY3NzKCd3aWR0aCcsIGRyYWdJdGVtLm91dGVyV2lkdGgoKSk7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0SW5kZXhPZkl0ZW0oZHJhZ0l0ZW0pO1xuXG4gICAgICAgICAgICAvLyBmaXggZm9yIHplcHRvLmpzXG4gICAgICAgICAgICAvL2RyYWdJdGVtLmFmdGVyKHRoaXMucGxhY2VFbCkuZGV0YWNoKCkuYXBwZW5kVG8odGhpcy5kcmFnRWwpO1xuICAgICAgICAgICAgZHJhZ0l0ZW0uYWZ0ZXIodGhpcy5wbGFjZUVsKTtcbiAgICAgICAgICAgIGRyYWdJdGVtWzBdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZHJhZ0l0ZW1bMF0pO1xuICAgICAgICAgICAgZHJhZ0l0ZW0uYXBwZW5kVG8odGhpcy5kcmFnRWwpO1xuXG4gICAgICAgICAgICAkKGRvY3VtZW50LmJvZHkpLmFwcGVuZCh0aGlzLmRyYWdFbCk7XG4gICAgICAgICAgICB0aGlzLmRyYWdFbC5jc3Moe1xuICAgICAgICAgICAgICAgICdsZWZ0JzogZS5wYWdlWCAtIG1vdXNlLm9mZnNldFgsXG4gICAgICAgICAgICAgICAgJ3RvcCc6IGUucGFnZVkgLSBtb3VzZS5vZmZzZXRZXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHRvdGFsIGRlcHRoIG9mIGRyYWdnaW5nIGl0ZW1cbiAgICAgICAgICAgIHZhciBpLCBkZXB0aCxcbiAgICAgICAgICAgICAgICBpdGVtcyA9IHRoaXMuZHJhZ0VsLmZpbmQodGhpcy5vcHRpb25zLml0ZW1Ob2RlTmFtZSk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZXB0aCA9ICQoaXRlbXNbaV0pLnBhcmVudHModGhpcy5vcHRpb25zLmxpc3ROb2RlTmFtZSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChkZXB0aCA+IHRoaXMuZHJhZ0RlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0RlcHRoID0gZGVwdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vQ3JlYXRlIHN1YmxldmVsLlxuICAgICAgICAvLyAgZWxlbWVudCA6IGVsZW1lbnQgd2hpY2ggYmVjb21lIHBhcmVudFxuICAgICAgICAvLyAgaXRlbSAgICA6IHNvbWV0aGluZyB0byBwbGFjZSBpbnRvIG5ldyBzdWJsZXZlbFxuICAgICAgICBjcmVhdGVTdWJMZXZlbDogZnVuY3Rpb24oZWxlbWVudCwgaXRlbSkge1xuICAgICAgICAgICAgdmFyIGxpc3QgPSAkKCc8JyArIHRoaXMub3B0aW9ucy5saXN0Tm9kZU5hbWUgKyAnLz4nKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMubGlzdENsYXNzKTtcbiAgICAgICAgICAgIGlmIChpdGVtKSBsaXN0LmFwcGVuZChpdGVtKTtcbiAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKGxpc3QpO1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJlbnQoZWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRJbmRleE9mSXRlbTogZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggfHwgW107XG5cbiAgICAgICAgICAgIGluZGV4LnVuc2hpZnQoaXRlbS5pbmRleCgpKTtcblxuICAgICAgICAgICAgaWYgKCQoaXRlbVswXS5wYXJlbnROb2RlKVswXSAhPT0gdGhpcy5kcmFnUm9vdEVsWzBdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbmRleE9mSXRlbSgkKGl0ZW1bMF0ucGFyZW50Tm9kZSksIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0VsLmRhdGEoJ2luZGV4T2ZJdGVtJywgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3RvcmVJdGVtQXRJbmRleDogZnVuY3Rpb24oZHJhZ0VsZW1lbnQsIGluZGV4QXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50RWwgPSB0aGlzLmVsLFxuICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IGluZGV4QXJyYXkubGVuZ3RoIC0gMTtcblxuICAgICAgICAgICAgLy9QdXQgZHJhZyBlbGVtZW50IGF0IGN1cnJlbnQgZWxlbWVudCBwb3NpdGlvbi5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBsYWNlRWxlbWVudChjdXJyZW50RWwsIGRyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4QXJyYXlbbGFzdEluZGV4XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAkKGN1cnJlbnRFbCkucHJlcGVuZChkcmFnRWxlbWVudC5jbG9uZSh0cnVlKSk7IC8vdXNpbmcgdHJ1ZSBzYXZlcyBhZGRlZCB0byBlbGVtZW50IGV2ZW50cy5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICQoY3VycmVudEVsLmNoaWxkcmVuW2luZGV4QXJyYXlbbGFzdEluZGV4XSAtIDFdKS5hZnRlcihkcmFnRWxlbWVudC5jbG9uZSh0cnVlKSk7IC8vdXNpbmcgdHJ1ZSBzYXZlcyBhZGRlZCB0byBlbGVtZW50IGV2ZW50cy5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL0RpZ2dpbiB0aHJvdWdoIGluZGV4QXJyYXkgdG8gZ2V0IGhvbWUgZm9yIGRyYWdFbGVtZW50LlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RJbmRleCA9PT0gcGFyc2VJbnQoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VFbGVtZW50KGN1cnJlbnRFbCwgZHJhZ0VsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vZWxlbWVudCBjYW4gaGF2ZSBubyBpbmRleGVzLCBzbyB3ZSBoYXZlIHRvIHVzZSBjb25kaXRpb25hbCBoZXJlIHRvIGF2b2lkIGVycm9ycy5cbiAgICAgICAgICAgICAgICAvL2lmIGVsZW1lbnQgZG9lc24ndCBleGlzdCB3ZSBkZWZlbmV0bHkgbmVlZCB0byBhZGQgbmV3IGxpc3QuXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSAoY3VycmVudEVsWzBdKSA/IGN1cnJlbnRFbFswXSA6IGN1cnJlbnRFbDtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dEVsICA9IGVsZW1lbnQuY2hpbGRyZW5baW5kZXhBcnJheVtpXV07XG4gICAgICAgICAgICAgICAgY3VycmVudEVsICAgPSAoIW5leHRFbCkgPyB0aGlzLmNyZWF0ZVN1YkxldmVsKCQoZWxlbWVudCkpIDogbmV4dEVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRyYWdTdG9wOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAvLyBmaXggZm9yIHplcHRvLmpzXG4gICAgICAgICAgICAvL3RoaXMucGxhY2VFbC5yZXBsYWNlV2l0aCh0aGlzLmRyYWdFbC5jaGlsZHJlbih0aGlzLm9wdGlvbnMuaXRlbU5vZGVOYW1lICsgJzpmaXJzdCcpLmRldGFjaCgpKTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB0b3AgIDogZS5wYWdlWSxcbiAgICAgICAgICAgICAgICBsZWZ0IDogZS5wYWdlWFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vR2V0IGluZGV4QXJyYXkgb2YgaXRlbSBhdCBkcmFnIHN0YXJ0LlxuICAgICAgICAgICAgdmFyIHNyY0luZGV4ID0gdGhpcy5kcmFnRWwuZGF0YSgnaW5kZXhPZkl0ZW0nKTtcblxuICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5kcmFnRWwuY2hpbGRyZW4odGhpcy5vcHRpb25zLml0ZW1Ob2RlTmFtZSkuZmlyc3QoKTtcblxuICAgICAgICAgICAgZWxbMF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbFswXSk7XG5cbiAgICAgICAgICAgIHRoaXMuZHJhZ0VsLnJlbW92ZSgpOyAvL1JlbW92ZSBkcmFnRWwsIGNhdXNlIGl0IGNhbiBhZmZlY3Qgb24gaW5kZXhpbmcgaW4gaHRtbCBjb2xsZWN0aW9uLlxuXG4gICAgICAgICAgICAvL0JlZm9yZSBkcmFnIHN0b3AgY2FsbGJhY2tcbiAgICAgICAgICAgIHZhciBjb250aW51ZUV4ZWN1dGlvbiA9IHRoaXMub3B0aW9ucy5iZWZvcmVEcmFnU3RvcC5jYWxsKHRoaXMsIHRoaXMuZWwsIGVsLCB0aGlzLnBsYWNlRWwucGFyZW50KCkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250aW51ZUV4ZWN1dGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgY29udGludWVFeGVjdXRpb24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGxhY2VFbC5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsYWNlRWwucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnQuY2hpbGRyZW4oKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnNldFBhcmVudChwYXJlbnQucGFyZW50KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmVJdGVtQXRJbmRleChlbCwgc3JjSW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucGxhY2VFbC5yZXBsYWNlV2l0aChlbCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc05ld1Jvb3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZpeGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZUl0ZW1BdEluZGV4KGVsLCBzcmNJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLnRyaWdnZXIoJ2xvc3RJdGVtJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1Jvb3RFbC50cmlnZ2VyKCdnYWluZWRJdGVtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdSb290RWwudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuZHJhZ1Jvb3RFbCwgZWwsIHBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRyYWdNb3ZlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgbGlzdCwgcGFyZW50LCBwcmV2LCBuZXh0LCBkZXB0aCxcbiAgICAgICAgICAgICAgICBvcHQgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgbW91c2UgPSB0aGlzLm1vdXNlO1xuXG4gICAgICAgICAgICB0aGlzLmRyYWdFbC5jc3Moe1xuICAgICAgICAgICAgICAgICdsZWZ0JzogZS5wYWdlWCAtIG1vdXNlLm9mZnNldFgsXG4gICAgICAgICAgICAgICAgJ3RvcCc6IGUucGFnZVkgLSBtb3VzZS5vZmZzZXRZXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gbW91c2UgcG9zaXRpb24gbGFzdCBldmVudHNcbiAgICAgICAgICAgIG1vdXNlLmxhc3RYID0gbW91c2Uubm93WDtcbiAgICAgICAgICAgIG1vdXNlLmxhc3RZID0gbW91c2Uubm93WTtcbiAgICAgICAgICAgIC8vIG1vdXNlIHBvc2l0aW9uIHRoaXMgZXZlbnRzXG4gICAgICAgICAgICBtb3VzZS5ub3dYID0gZS5wYWdlWDtcbiAgICAgICAgICAgIG1vdXNlLm5vd1kgPSBlLnBhZ2VZO1xuICAgICAgICAgICAgLy8gZGlzdGFuY2UgbW91c2UgbW92ZWQgYmV0d2VlbiBldmVudHNcbiAgICAgICAgICAgIG1vdXNlLmRpc3RYID0gbW91c2Uubm93WCAtIG1vdXNlLmxhc3RYO1xuICAgICAgICAgICAgbW91c2UuZGlzdFkgPSBtb3VzZS5ub3dZIC0gbW91c2UubGFzdFk7XG4gICAgICAgICAgICAvLyBkaXJlY3Rpb24gbW91c2Ugd2FzIG1vdmluZ1xuICAgICAgICAgICAgbW91c2UubGFzdERpclggPSBtb3VzZS5kaXJYO1xuICAgICAgICAgICAgbW91c2UubGFzdERpclkgPSBtb3VzZS5kaXJZO1xuICAgICAgICAgICAgLy8gZGlyZWN0aW9uIG1vdXNlIGlzIG5vdyBtb3ZpbmcgKG9uIGJvdGggYXhpcylcbiAgICAgICAgICAgIG1vdXNlLmRpclggPSBtb3VzZS5kaXN0WCA9PT0gMCA/IDAgOiBtb3VzZS5kaXN0WCA+IDAgPyAxIDogLTE7XG4gICAgICAgICAgICBtb3VzZS5kaXJZID0gbW91c2UuZGlzdFkgPT09IDAgPyAwIDogbW91c2UuZGlzdFkgPiAwID8gMSA6IC0xO1xuICAgICAgICAgICAgLy8gYXhpcyBtb3VzZSBpcyBub3cgbW92aW5nIG9uXG4gICAgICAgICAgICB2YXIgbmV3QXggPSBNYXRoLmFicyhtb3VzZS5kaXN0WCkgPiBNYXRoLmFicyhtb3VzZS5kaXN0WSkgPyAxIDogMDtcblxuICAgICAgICAgICAgLy8gZG8gbm90aGluZyBvbiBmaXJzdCBtb3ZlXG4gICAgICAgICAgICBpZiAoIW1vdXNlLm1vdmluZykge1xuICAgICAgICAgICAgICAgIG1vdXNlLmRpckF4ID0gbmV3QXg7XG4gICAgICAgICAgICAgICAgbW91c2UubW92aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRvIHNjcm9sbGluZyBpZiBlbmFibGVcbiAgICAgICAgICAgIGlmIChvcHQuc2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cualF1ZXJ5LmZuLnNjcm9sbFBhcmVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxQYXJlbnQgPSB0aGlzLmVsLnNjcm9sbFBhcmVudCgpWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsUGFyZW50ICE9PSBkb2N1bWVudCAmJiBzY3JvbGxQYXJlbnQudGFnTmFtZSAhPT0gJ0hUTUwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG9wdC5zY3JvbGxUcmlnZ2Vycy5ib3R0b20gKyBzY3JvbGxQYXJlbnQub2Zmc2V0SGVpZ2h0KSAtIGUucGFnZVkgPCBvcHQuc2Nyb2xsU2Vuc2l0aXZpdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCA9IHNjcm9sbGVkID0gc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCArIG9wdC5zY3JvbGxTcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUucGFnZVkgLSBvcHQuc2Nyb2xsVHJpZ2dlcnMudG9wIDwgb3B0LnNjcm9sbFNlbnNpdGl2aXR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFBhcmVudC5zY3JvbGxUb3AgPSBzY3JvbGxlZCA9IHNjcm9sbFBhcmVudC5zY3JvbGxUb3AgLSBvcHQuc2Nyb2xsU3BlZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgob3B0LnNjcm9sbFRyaWdnZXJzLnJpZ2h0ICsgc2Nyb2xsUGFyZW50Lm9mZnNldFdpZHRoKSAtIGUucGFnZVggPCBvcHQuc2Nyb2xsU2Vuc2l0aXZpdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQgPSBzY3JvbGxlZCA9IHNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0ICsgb3B0LnNjcm9sbFNwZWVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZS5wYWdlWCAtIG9wdC5zY3JvbGxUcmlnZ2Vycy5sZWZ0IDwgb3B0LnNjcm9sbFNlbnNpdGl2aXR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0ID0gc2Nyb2xsZWQgPSBzY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCAtIG9wdC5zY3JvbGxTcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnBhZ2VZIC0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkgPCBvcHQuc2Nyb2xsU2Vuc2l0aXZpdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZWQgPSAkKGRvY3VtZW50KS5zY3JvbGxUb3AoJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkgLSBvcHQuc2Nyb2xsU3BlZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoJCh3aW5kb3cpLmhlaWdodCgpIC0gKGUucGFnZVkgLSAkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSkgPCBvcHQuc2Nyb2xsU2Vuc2l0aXZpdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZWQgPSAkKGRvY3VtZW50KS5zY3JvbGxUb3AoJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkgKyBvcHQuc2Nyb2xsU3BlZWQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5wYWdlWCAtICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoKSA8IG9wdC5zY3JvbGxTZW5zaXRpdml0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxlZCA9ICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpIC0gb3B0LnNjcm9sbFNwZWVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCQod2luZG93KS53aWR0aCgpIC0gKGUucGFnZVggLSAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkpIDwgb3B0LnNjcm9sbFNlbnNpdGl2aXR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgKyBvcHQuc2Nyb2xsU3BlZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUbyB1c2Ugc2Nyb2xsaW5nIHlvdSBuZWVkIHRvIGhhdmUgc2Nyb2xsUGFyZW50KCkgZnVuY3Rpb24sIGNoZWNrIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbFRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2Nyb2xsVGltZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0LnNjcm9sbCAmJiBzY3JvbGxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkKHdpbmRvdykudHJpZ2dlcihlKTtcbiAgICAgICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNhbGMgZGlzdGFuY2UgbW92ZWQgb24gdGhpcyBheGlzIChhbmQgZGlyZWN0aW9uKVxuICAgICAgICAgICAgaWYgKG1vdXNlLmRpckF4ICE9PSBuZXdBeCkge1xuICAgICAgICAgICAgICAgIG1vdXNlLmRpc3RBeFggPSAwO1xuICAgICAgICAgICAgICAgIG1vdXNlLmRpc3RBeFkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbW91c2UuZGlzdEF4WCArPSBNYXRoLmFicyhtb3VzZS5kaXN0WCk7XG4gICAgICAgICAgICAgICAgaWYgKG1vdXNlLmRpclggIT09IDAgJiYgbW91c2UuZGlyWCAhPT0gbW91c2UubGFzdERpclgpIHtcbiAgICAgICAgICAgICAgICAgICAgbW91c2UuZGlzdEF4WCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vdXNlLmRpc3RBeFkgKz0gTWF0aC5hYnMobW91c2UuZGlzdFkpO1xuICAgICAgICAgICAgICAgIGlmIChtb3VzZS5kaXJZICE9PSAwICYmIG1vdXNlLmRpclkgIT09IG1vdXNlLmxhc3REaXJZKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdXNlLmRpc3RBeFkgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vdXNlLmRpckF4ID0gbmV3QXg7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogbW92ZSBob3Jpem9udGFsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChtb3VzZS5kaXJBeCAmJiBtb3VzZS5kaXN0QXhYID49IG9wdC50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAvLyByZXNldCBtb3ZlIGRpc3RhbmNlIG9uIHgtYXhpcyBmb3IgbmV3IHBoYXNlXG4gICAgICAgICAgICAgICAgbW91c2UuZGlzdEF4WCA9IDA7XG4gICAgICAgICAgICAgICAgcHJldiA9IHRoaXMucGxhY2VFbC5wcmV2KG9wdC5pdGVtTm9kZU5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIGluY3JlYXNlIGhvcml6b250YWwgbGV2ZWwgaWYgcHJldmlvdXMgc2libGluZyBleGlzdHMsIGlzIG5vdCBjb2xsYXBzZWQsIGFuZCBjYW4gaGF2ZSBjaGlsZHJlblxuICAgICAgICAgICAgICAgIGlmIChtb3VzZS5kaXN0WCA+IDAgJiYgcHJldi5sZW5ndGggJiYgIXByZXYuaGFzQ2xhc3Mob3B0LmNvbGxhcHNlZENsYXNzKSAmJiAhcHJldi5oYXNDbGFzcyhvcHQubm9DaGlsZHJlbkNsYXNzKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYW5ub3QgaW5jcmVhc2UgbGV2ZWwgd2hlbiBpdGVtIGFib3ZlIGlzIGNvbGxhcHNlZFxuICAgICAgICAgICAgICAgICAgICBsaXN0ID0gcHJldi5maW5kKG9wdC5saXN0Tm9kZU5hbWUpLmxhc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZGVwdGggbGltaXQgaGFzIHJlYWNoZWRcbiAgICAgICAgICAgICAgICAgICAgZGVwdGggPSB0aGlzLnBsYWNlRWwucGFyZW50cyhvcHQubGlzdE5vZGVOYW1lKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCArIHRoaXMuZHJhZ0RlcHRoIDw9IG9wdC5tYXhEZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIG5ldyBzdWItbGV2ZWwgaWYgb25lIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVN1YkxldmVsKHByZXYsIHRoaXMucGxhY2VFbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGFwcGVuZCB0byBuZXh0IGxldmVsIHVwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdCA9IHByZXYuY2hpbGRyZW4ob3B0Lmxpc3ROb2RlTmFtZSkubGFzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QuYXBwZW5kKHRoaXMucGxhY2VFbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZGVjcmVhc2UgaG9yaXpvbnRhbCBsZXZlbFxuICAgICAgICAgICAgICAgIGlmIChtb3VzZS5kaXN0WCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuJ3QgZGVjcmVhc2UgYSBsZXZlbCBpZiBhbiBpdGVtIHByZWNlZWRzIHRoZSBjdXJyZW50IG9uZVxuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gdGhpcy5wbGFjZUVsLm5leHQob3B0Lml0ZW1Ob2RlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHRoaXMucGxhY2VFbC5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGxhY2VFbC5jbG9zZXN0KG9wdC5pdGVtTm9kZU5hbWUpLmFmdGVyKHRoaXMucGxhY2VFbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudC5jaGlsZHJlbigpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5zZXRQYXJlbnQocGFyZW50LnBhcmVudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlzRW1wdHkgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gZmluZCBsaXN0IGl0ZW0gdW5kZXIgY3Vyc29yXG4gICAgICAgICAgICBpZiAoIWhhc1BvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdFbFswXS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBvaW50RWwgPSAkKGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZS5wYWdlWCAtIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCwgZS5wYWdlWSAtICh3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCkpKTtcbiAgICAgICAgICAgIGlmICghaGFzUG9pbnRlckV2ZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0VsWzBdLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wb2ludEVsLmhhc0NsYXNzKG9wdC5oYW5kbGVDbGFzcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50RWwgPSB0aGlzLnBvaW50RWwuY2xvc2VzdChvcHQuaXRlbU5vZGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBvaW50RWwuaGFzQ2xhc3Mob3B0LmVtcHR5Q2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgaXNFbXB0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5wb2ludEVsLmxlbmd0aCB8fCAhdGhpcy5wb2ludEVsLmhhc0NsYXNzKG9wdC5pdGVtQ2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmaW5kIHBhcmVudCBsaXN0IG9mIGl0ZW0gdW5kZXIgY3Vyc29yXG4gICAgICAgICAgICB2YXIgcG9pbnRFbFJvb3QgPSB0aGlzLnBvaW50RWwuY2xvc2VzdCgnLicgKyBvcHQucm9vdENsYXNzKSxcbiAgICAgICAgICAgICAgICBpc05ld1Jvb3QgPSB0aGlzLmRyYWdSb290RWwuZGF0YSgnbmVzdGFibGUtaWQnKSAhPT0gcG9pbnRFbFJvb3QuZGF0YSgnbmVzdGFibGUtaWQnKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBtb3ZlIHZlcnRpY2FsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghbW91c2UuZGlyQXggfHwgaXNOZXdSb290IHx8IGlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBncm91cHMgbWF0Y2ggaWYgZHJhZ2dpbmcgb3ZlciBuZXcgcm9vdFxuICAgICAgICAgICAgICAgIGlmIChpc05ld1Jvb3QgJiYgb3B0Lmdyb3VwICE9PSBwb2ludEVsUm9vdC5kYXRhKCduZXN0YWJsZS1ncm91cCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBmaXhlZCBpdGVtJ3MgZGVwdGgsIHVzZSBmb3Igc29tZSBsaXN0IGhhcyBzcGVjaWZpYyB0eXBlLCBlZzonVm9sdW1lLCBTZWN0aW9uLCBDaGFwdGVyIC4uLidcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZpeGVkRGVwdGggJiYgdGhpcy5kcmFnRGVwdGggKyAxICE9PSB0aGlzLnBvaW50RWwucGFyZW50cyhvcHQubGlzdE5vZGVOYW1lKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGRlcHRoIGxpbWl0XG4gICAgICAgICAgICAgICAgZGVwdGggPSB0aGlzLmRyYWdEZXB0aCAtIDEgKyB0aGlzLnBvaW50RWwucGFyZW50cyhvcHQubGlzdE5vZGVOYW1lKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoID4gb3B0Lm1heERlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGJlZm9yZSA9IGUucGFnZVkgPCAodGhpcy5wb2ludEVsLm9mZnNldCgpLnRvcCArIHRoaXMucG9pbnRFbC5oZWlnaHQoKSAvIDIpO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHRoaXMucGxhY2VFbC5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICAvLyBpZiBlbXB0eSBjcmVhdGUgbmV3IGxpc3QgdG8gcmVwbGFjZSBlbXB0eSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QgPSAkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQob3B0Lmxpc3ROb2RlTmFtZSkpLmFkZENsYXNzKG9wdC5saXN0Q2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICBsaXN0LmFwcGVuZCh0aGlzLnBsYWNlRWwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50RWwucmVwbGFjZVdpdGgobGlzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJlZm9yZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50RWwuYmVmb3JlKHRoaXMucGxhY2VFbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50RWwuYWZ0ZXIodGhpcy5wbGFjZUVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnQuY2hpbGRyZW4oKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnNldFBhcmVudChwYXJlbnQucGFyZW50KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZHJhZ1Jvb3RFbC5maW5kKG9wdC5pdGVtTm9kZU5hbWUpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVtcHR5RWxlbWVudCh0aGlzLmRyYWdSb290RWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBwYXJlbnQgcm9vdCBsaXN0IGhhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnUm9vdEVsID0gcG9pbnRFbFJvb3Q7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmV3Um9vdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc05ld1Jvb3QgPSB0aGlzLmVsWzBdICE9PSB0aGlzLmRyYWdSb290RWxbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEFwcGVuZCB0aGUgLmRkLWVtcHR5IGRpdiB0byB0aGUgbGlzdCBzbyBpdCBjYW4gYmUgcG9wdWxhdGVkIGFuZCBzdHlsZWRcbiAgICAgICAgYXBwZW5kRW1wdHlFbGVtZW50OiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LmFwcGVuZCgnPGRpdiBjbGFzcz1cIicgKyB0aGlzLm9wdGlvbnMuZW1wdHlDbGFzcyArICdcIi8+Jyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgJC5mbi5uZXN0YWJsZSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgbGlzdHMgID0gdGhpcyxcbiAgICAgICAgICAgIHJldHZhbCA9IHRoaXMsXG4gICAgICAgICAgICBhcmdzICAgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgaWYgKCEoJ05lc3RhYmxlJyBpbiB3aW5kb3cpKSB7XG4gICAgICAgICAgICB3aW5kb3cuTmVzdGFibGUgPSB7fTtcbiAgICAgICAgICAgIE5lc3RhYmxlLmNvdW50ZXIgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdHMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwbHVnaW4gPSAkKHRoaXMpLmRhdGEoXCJuZXN0YWJsZVwiKTtcblxuICAgICAgICAgICAgaWYgKCFwbHVnaW4pIHtcbiAgICAgICAgICAgICAgICBOZXN0YWJsZS5jb3VudGVyKys7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5kYXRhKFwibmVzdGFibGVcIiwgbmV3IFBsdWdpbih0aGlzLCBwYXJhbXMpKTtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmRhdGEoXCJuZXN0YWJsZS1pZFwiLCBOZXN0YWJsZS5jb3VudGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgcGx1Z2luW3BhcmFtc10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGx1Z2luQXJncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luQXJncy5wdXNoKGFyZ3NbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gcGx1Z2luW3BhcmFtc10uYXBwbHkocGx1Z2luLCBwbHVnaW5BcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHBsdWdpbltwYXJhbXNdKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXR2YWwgfHwgbGlzdHM7XG4gICAgfTtcblxufSkod2luZG93LmpRdWVyeSB8fCB3aW5kb3cuWmVwdG8sIHdpbmRvdywgZG9jdW1lbnQpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./Modules/Menu/node_modules/nestable2/jquery.nestable.js\n");

/***/ }),

/***/ 9:
/*!**************************************************************!*\
  !*** multi ./Modules/Menu/Resources/assets/admin/js/main.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! C:\xampp\htdocs\asia\Modules\Menu\Resources\assets\admin\js\main.js */"./Modules/Menu/Resources/assets/admin/js/main.js");


/***/ })

/******/ });