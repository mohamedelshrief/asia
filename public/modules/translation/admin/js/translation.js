/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 17);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./Modules/Translation/Resources/assets/admin/js/TranslationEditor.js":
/*!****************************************************************************!*\
  !*** ./Modules/Translation/Resources/assets/admin/js/TranslationEditor.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return _default; });\n/* harmony import */ var _node_modules_x_editable_dist_bootstrap3_editable_js_bootstrap_editable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../node_modules/x-editable/dist/bootstrap3-editable/js/bootstrap-editable */ \"./Modules/Translation/node_modules/x-editable/dist/bootstrap3-editable/js/bootstrap-editable.js\");\n/* harmony import */ var _node_modules_x_editable_dist_bootstrap3_editable_js_bootstrap_editable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_x_editable_dist_bootstrap3_editable_js_bootstrap_editable__WEBPACK_IMPORTED_MODULE_0__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar _default = /*#__PURE__*/function () {\n  function _default() {\n    _classCallCheck(this, _default);\n\n    $('.translation').editable({\n      url: this.update,\n      type: 'text',\n      mode: 'inline',\n      send: 'always'\n    });\n  }\n\n  _createClass(_default, [{\n    key: \"update\",\n    value: function update(data) {\n      $.ajax({\n        url: route('admin.translations.update', this.dataset.key),\n        type: 'PUT',\n        data: {\n          locale: this.dataset.locale,\n          value: data.value\n        },\n        success: function (_success) {\n          function success(_x) {\n            return _success.apply(this, arguments);\n          }\n\n          success.toString = function () {\n            return _success.toString();\n          };\n\n          return success;\n        }(function (message) {\n          success(message);\n        }),\n        error: function (_error) {\n          function error(_x2) {\n            return _error.apply(this, arguments);\n          }\n\n          error.toString = function () {\n            return _error.toString();\n          };\n\n          return error;\n        }(function (xhr) {\n          error(xhr.responseJSON.message);\n        })\n      });\n    }\n  }]);\n\n  return _default;\n}();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9Nb2R1bGVzL1RyYW5zbGF0aW9uL1Jlc291cmNlcy9hc3NldHMvYWRtaW4vanMvVHJhbnNsYXRpb25FZGl0b3IuanM/MzgxZiJdLCJuYW1lcyI6WyIkIiwiZWRpdGFibGUiLCJ1cmwiLCJ1cGRhdGUiLCJ0eXBlIiwibW9kZSIsInNlbmQiLCJkYXRhIiwiYWpheCIsInJvdXRlIiwiZGF0YXNldCIsImtleSIsImxvY2FsZSIsInZhbHVlIiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJlcnJvciIsInhociIsInJlc3BvbnNlSlNPTiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7QUFHSSxzQkFBYztBQUFBOztBQUNWQSxLQUFDLENBQUMsY0FBRCxDQUFELENBQWtCQyxRQUFsQixDQUEyQjtBQUN2QkMsU0FBRyxFQUFFLEtBQUtDLE1BRGE7QUFFdkJDLFVBQUksRUFBRSxNQUZpQjtBQUd2QkMsVUFBSSxFQUFFLFFBSGlCO0FBSXZCQyxVQUFJLEVBQUU7QUFKaUIsS0FBM0I7QUFNSDs7OztXQUVELGdCQUFPQyxJQUFQLEVBQWE7QUFDVFAsT0FBQyxDQUFDUSxJQUFGLENBQU87QUFDSE4sV0FBRyxFQUFFTyxLQUFLLENBQUMsMkJBQUQsRUFBOEIsS0FBS0MsT0FBTCxDQUFhQyxHQUEzQyxDQURQO0FBRUhQLFlBQUksRUFBRSxLQUZIO0FBR0hHLFlBQUksRUFBRTtBQUNGSyxnQkFBTSxFQUFFLEtBQUtGLE9BQUwsQ0FBYUUsTUFEbkI7QUFFRkMsZUFBSyxFQUFFTixJQUFJLENBQUNNO0FBRlYsU0FISDtBQU9IQyxlQVBHO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLG9CQU9LQyxPQVBMLEVBT2M7QUFDYkQsaUJBQU8sQ0FBQ0MsT0FBRCxDQUFQO0FBQ0gsU0FURTtBQVVIQyxhQVZHO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLG9CQVVHQyxHQVZILEVBVVE7QUFDUEQsZUFBSyxDQUFDQyxHQUFHLENBQUNDLFlBQUosQ0FBaUJILE9BQWxCLENBQUw7QUFDSCxTQVpFO0FBQUEsT0FBUDtBQWNIIiwiZmlsZSI6Ii4vTW9kdWxlcy9UcmFuc2xhdGlvbi9SZXNvdXJjZXMvYXNzZXRzL2FkbWluL2pzL1RyYW5zbGF0aW9uRWRpdG9yLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICcuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMveC1lZGl0YWJsZS9kaXN0L2Jvb3RzdHJhcDMtZWRpdGFibGUvanMvYm9vdHN0cmFwLWVkaXRhYmxlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAkKCcudHJhbnNsYXRpb24nKS5lZGl0YWJsZSh7XG4gICAgICAgICAgICB1cmw6IHRoaXMudXBkYXRlLFxuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgbW9kZTogJ2lubGluZScsXG4gICAgICAgICAgICBzZW5kOiAnYWx3YXlzJyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgIHVybDogcm91dGUoJ2FkbWluLnRyYW5zbGF0aW9ucy51cGRhdGUnLCB0aGlzLmRhdGFzZXQua2V5KSxcbiAgICAgICAgICAgIHR5cGU6ICdQVVQnLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGxvY2FsZTogdGhpcy5kYXRhc2V0LmxvY2FsZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YS52YWx1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWNjZXNzKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yKHhocikge1xuICAgICAgICAgICAgICAgIGVycm9yKHhoci5yZXNwb25zZUpTT04ubWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./Modules/Translation/Resources/assets/admin/js/TranslationEditor.js\n");

/***/ }),

/***/ "./Modules/Translation/Resources/assets/admin/js/main.js":
/*!***************************************************************!*\
  !*** ./Modules/Translation/Resources/assets/admin/js/main.js ***!
  \***************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _TranslationEditor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TranslationEditor */ \"./Modules/Translation/Resources/assets/admin/js/TranslationEditor.js\");\n\n$('.translations-table').dataTable({\n  pageLength: 20,\n  lengthMenu: [10, 20, 50, 100, 200],\n  drawCallback: function drawCallback() {\n    new _TranslationEditor__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9Nb2R1bGVzL1RyYW5zbGF0aW9uL1Jlc291cmNlcy9hc3NldHMvYWRtaW4vanMvbWFpbi5qcz82ZDA1Il0sIm5hbWVzIjpbIiQiLCJkYXRhVGFibGUiLCJwYWdlTGVuZ3RoIiwibGVuZ3RoTWVudSIsImRyYXdDYWxsYmFjayIsIlRyYW5zbGF0aW9uRWRpdG9yIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFFQUEsQ0FBQyxDQUFDLHFCQUFELENBQUQsQ0FBeUJDLFNBQXpCLENBQW1DO0FBQy9CQyxZQUFVLEVBQUUsRUFEbUI7QUFFL0JDLFlBQVUsRUFBRSxDQUFDLEVBQUQsRUFBSyxFQUFMLEVBQVMsRUFBVCxFQUFhLEdBQWIsRUFBa0IsR0FBbEIsQ0FGbUI7QUFHL0JDLGNBQVksRUFBRSx3QkFBTTtBQUNoQixRQUFJQywwREFBSjtBQUNIO0FBTDhCLENBQW5DIiwiZmlsZSI6Ii4vTW9kdWxlcy9UcmFuc2xhdGlvbi9SZXNvdXJjZXMvYXNzZXRzL2FkbWluL2pzL21haW4uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVHJhbnNsYXRpb25FZGl0b3IgZnJvbSAnLi9UcmFuc2xhdGlvbkVkaXRvcic7XG5cbiQoJy50cmFuc2xhdGlvbnMtdGFibGUnKS5kYXRhVGFibGUoe1xuICAgIHBhZ2VMZW5ndGg6IDIwLFxuICAgIGxlbmd0aE1lbnU6IFsxMCwgMjAsIDUwLCAxMDAsIDIwMF0sXG4gICAgZHJhd0NhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgIG5ldyBUcmFuc2xhdGlvbkVkaXRvcigpO1xuICAgIH0sXG59KTtcblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./Modules/Translation/Resources/assets/admin/js/main.js\n");

/***/ }),

/***/ "./Modules/Translation/node_modules/x-editable/dist/bootstrap3-editable/js/bootstrap-editable.js":
/*!*******************************************************************************************************!*\
  !*** ./Modules/Translation/node_modules/x-editable/dist/bootstrap3-editable/js/bootstrap-editable.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*! X-editable - v1.5.1 \n* In-place editing with Twitter Bootstrap, jQuery UI or pure jQuery\n* http://github.com/vitalets/x-editable\n* Copyright (c) 2013 Vitaliy Potapov; Licensed MIT */\n/**\nForm with single input element, two buttons and two states: normal/loading.\nApplied as jQuery method to DIV tag (not to form tag!). This is because form can be in loading state when spinner shown.\nEditableform is linked with one of input types, e.g. 'text', 'select' etc.\n\n@class editableform\n@uses text\n@uses textarea\n**/\n(function ($) {\n    \"use strict\";\n    \n    var EditableForm = function (div, options) {\n        this.options = $.extend({}, $.fn.editableform.defaults, options);\n        this.$div = $(div); //div, containing form. Not form tag. Not editable-element.\n        if(!this.options.scope) {\n            this.options.scope = this;\n        }\n        //nothing shown after init\n    };\n\n    EditableForm.prototype = {\n        constructor: EditableForm,\n        initInput: function() {  //called once\n            //take input from options (as it is created in editable-element)\n            this.input = this.options.input;\n            \n            //set initial value\n            //todo: may be add check: typeof str === 'string' ? \n            this.value = this.input.str2value(this.options.value); \n            \n            //prerender: get input.$input\n            this.input.prerender();\n        },\n        initTemplate: function() {\n            this.$form = $($.fn.editableform.template); \n        },\n        initButtons: function() {\n            var $btn = this.$form.find('.editable-buttons');\n            $btn.append($.fn.editableform.buttons);\n            if(this.options.showbuttons === 'bottom') {\n                $btn.addClass('editable-buttons-bottom');\n            }\n        },\n        /**\n        Renders editableform\n\n        @method render\n        **/        \n        render: function() {\n            //init loader\n            this.$loading = $($.fn.editableform.loading);        \n            this.$div.empty().append(this.$loading);\n            \n            //init form template and buttons\n            this.initTemplate();\n            if(this.options.showbuttons) {\n                this.initButtons();\n            } else {\n                this.$form.find('.editable-buttons').remove();\n            }\n\n            //show loading state\n            this.showLoading();            \n            \n            //flag showing is form now saving value to server. \n            //It is needed to wait when closing form.\n            this.isSaving = false;\n            \n            /**        \n            Fired when rendering starts\n            @event rendering \n            @param {Object} event event object\n            **/            \n            this.$div.triggerHandler('rendering');\n            \n            //init input\n            this.initInput();\n            \n            //append input to form\n            this.$form.find('div.editable-input').append(this.input.$tpl);            \n            \n            //append form to container\n            this.$div.append(this.$form);\n            \n            //render input\n            $.when(this.input.render())\n            .then($.proxy(function () {\n                //setup input to submit automatically when no buttons shown\n                if(!this.options.showbuttons) {\n                    this.input.autosubmit(); \n                }\n                 \n                //attach 'cancel' handler\n                this.$form.find('.editable-cancel').click($.proxy(this.cancel, this));\n                \n                if(this.input.error) {\n                    this.error(this.input.error);\n                    this.$form.find('.editable-submit').attr('disabled', true);\n                    this.input.$input.attr('disabled', true);\n                    //prevent form from submitting\n                    this.$form.submit(function(e){ e.preventDefault(); });\n                } else {\n                    this.error(false);\n                    this.input.$input.removeAttr('disabled');\n                    this.$form.find('.editable-submit').removeAttr('disabled');\n                    var value = (this.value === null || this.value === undefined || this.value === '') ? this.options.defaultValue : this.value;\n                    this.input.value2input(value);\n                    //attach submit handler\n                    this.$form.submit($.proxy(this.submit, this));\n                }\n\n                /**        \n                Fired when form is rendered\n                @event rendered\n                @param {Object} event event object\n                **/            \n                this.$div.triggerHandler('rendered');                \n\n                this.showForm();\n                \n                //call postrender method to perform actions required visibility of form\n                if(this.input.postrender) {\n                    this.input.postrender();\n                }                \n            }, this));\n        },\n        cancel: function() {   \n            /**        \n            Fired when form was cancelled by user\n            @event cancel \n            @param {Object} event event object\n            **/              \n            this.$div.triggerHandler('cancel');\n        },\n        showLoading: function() {\n            var w, h;\n            if(this.$form) {\n                //set loading size equal to form\n                w = this.$form.outerWidth();\n                h = this.$form.outerHeight(); \n                if(w) {\n                    this.$loading.width(w);\n                }\n                if(h) {\n                    this.$loading.height(h);\n                }\n                this.$form.hide();\n            } else {\n                //stretch loading to fill container width\n                w = this.$loading.parent().width();\n                if(w) {\n                    this.$loading.width(w);\n                }\n            }\n            this.$loading.show(); \n        },\n\n        showForm: function(activate) {\n            this.$loading.hide();\n            this.$form.show();\n            if(activate !== false) {\n                this.input.activate(); \n            }\n            /**        \n            Fired when form is shown\n            @event show \n            @param {Object} event event object\n            **/                    \n            this.$div.triggerHandler('show');\n        },\n\n        error: function(msg) {\n            var $group = this.$form.find('.control-group'),\n                $block = this.$form.find('.editable-error-block'),\n                lines;\n\n            if(msg === false) {\n                $group.removeClass($.fn.editableform.errorGroupClass);\n                $block.removeClass($.fn.editableform.errorBlockClass).empty().hide(); \n            } else {\n                //convert newline to <br> for more pretty error display\n                if(msg) {\n                    lines = (''+msg).split('\\n');\n                    for (var i = 0; i < lines.length; i++) {\n                        lines[i] = $('<div>').text(lines[i]).html();\n                    }\n                    msg = lines.join('<br>');\n                }\n                $group.addClass($.fn.editableform.errorGroupClass);\n                $block.addClass($.fn.editableform.errorBlockClass).html(msg).show();\n            }\n        },\n\n        submit: function(e) {\n            e.stopPropagation();\n            e.preventDefault();\n            \n            //get new value from input\n            var newValue = this.input.input2value(); \n\n            //validation: if validate returns string or truthy value - means error\n            //if returns object like {newValue: '...'} => submitted value is reassigned to it\n            var error = this.validate(newValue);\n            if ($.type(error) === 'object' && error.newValue !== undefined) {\n                newValue = error.newValue;\n                this.input.value2input(newValue);\n                if(typeof error.msg === 'string') {\n                    this.error(error.msg);\n                    this.showForm();\n                    return;\n                }\n            } else if (error) {\n                this.error(error);\n                this.showForm();\n                return;\n            } \n            \n            //if value not changed --> trigger 'nochange' event and return\n            /*jslint eqeq: true*/\n            if (!this.options.savenochange && this.input.value2str(newValue) == this.input.value2str(this.value)) {\n            /*jslint eqeq: false*/                \n                /**        \n                Fired when value not changed but form is submitted. Requires savenochange = false.\n                @event nochange \n                @param {Object} event event object\n                **/                    \n                this.$div.triggerHandler('nochange');            \n                return;\n            } \n\n            //convert value for submitting to server\n            var submitValue = this.input.value2submit(newValue);\n            \n            this.isSaving = true;\n            \n            //sending data to server\n            $.when(this.save(submitValue))\n            .done($.proxy(function(response) {\n                this.isSaving = false;\n\n                //run success callback\n                var res = typeof this.options.success === 'function' ? this.options.success.call(this.options.scope, response, newValue) : null;\n\n                //if success callback returns false --> keep form open and do not activate input\n                if(res === false) {\n                    this.error(false);\n                    this.showForm(false);\n                    return;\n                }\n\n                //if success callback returns string -->  keep form open, show error and activate input               \n                if(typeof res === 'string') {\n                    this.error(res);\n                    this.showForm();\n                    return;\n                }\n\n                //if success callback returns object like {newValue: <something>} --> use that value instead of submitted\n                //it is usefull if you want to chnage value in url-function\n                if(res && typeof res === 'object' && res.hasOwnProperty('newValue')) {\n                    newValue = res.newValue;\n                }\n\n                //clear error message\n                this.error(false);   \n                this.value = newValue;\n                /**        \n                Fired when form is submitted\n                @event save \n                @param {Object} event event object\n                @param {Object} params additional params\n                @param {mixed} params.newValue raw new value\n                @param {mixed} params.submitValue submitted value as string\n                @param {Object} params.response ajax response\n\n                @example\n                $('#form-div').on('save'), function(e, params){\n                    if(params.newValue === 'username') {...}\n                });\n                **/\n                this.$div.triggerHandler('save', {newValue: newValue, submitValue: submitValue, response: response});\n            }, this))\n            .fail($.proxy(function(xhr) {\n                this.isSaving = false;\n\n                var msg;\n                if(typeof this.options.error === 'function') {\n                    msg = this.options.error.call(this.options.scope, xhr, newValue);\n                } else {\n                    msg = typeof xhr === 'string' ? xhr : xhr.responseText || xhr.statusText || 'Unknown error!';\n                }\n\n                this.error(msg);\n                this.showForm();\n            }, this));\n        },\n\n        save: function(submitValue) {\n            //try parse composite pk defined as json string in data-pk \n            this.options.pk = $.fn.editableutils.tryParseJson(this.options.pk, true); \n            \n            var pk = (typeof this.options.pk === 'function') ? this.options.pk.call(this.options.scope) : this.options.pk,\n            /*\n              send on server in following cases:\n              1. url is function\n              2. url is string AND (pk defined OR send option = always) \n            */\n            send = !!(typeof this.options.url === 'function' || (this.options.url && ((this.options.send === 'always') || (this.options.send === 'auto' && pk !== null && pk !== undefined)))),\n            params;\n\n            if (send) { //send to server\n                this.showLoading();\n\n                //standard params\n                params = {\n                    name: this.options.name || '',\n                    value: submitValue,\n                    pk: pk \n                };\n\n                //additional params\n                if(typeof this.options.params === 'function') {\n                    params = this.options.params.call(this.options.scope, params);  \n                } else {\n                    //try parse json in single quotes (from data-params attribute)\n                    this.options.params = $.fn.editableutils.tryParseJson(this.options.params, true);   \n                    $.extend(params, this.options.params);\n                }\n\n                if(typeof this.options.url === 'function') { //user's function\n                    return this.options.url.call(this.options.scope, params);\n                } else {  \n                    //send ajax to server and return deferred object\n                    return $.ajax($.extend({\n                        url     : this.options.url,\n                        data    : params,\n                        type    : 'POST'\n                    }, this.options.ajaxOptions));\n                }\n            }\n        }, \n\n        validate: function (value) {\n            if (value === undefined) {\n                value = this.value;\n            }\n            if (typeof this.options.validate === 'function') {\n                return this.options.validate.call(this.options.scope, value);\n            }\n        },\n\n        option: function(key, value) {\n            if(key in this.options) {\n                this.options[key] = value;\n            }\n            \n            if(key === 'value') {\n                this.setValue(value);\n            }\n            \n            //do not pass option to input as it is passed in editable-element\n        },\n\n        setValue: function(value, convertStr) {\n            if(convertStr) {\n                this.value = this.input.str2value(value);\n            } else {\n                this.value = value;\n            }\n            \n            //if form is visible, update input\n            if(this.$form && this.$form.is(':visible')) {\n                this.input.value2input(this.value);\n            }            \n        }               \n    };\n\n    /*\n    Initialize editableform. Applied to jQuery object.\n\n    @method $().editableform(options)\n    @params {Object} options\n    @example\n    var $form = $('&lt;div&gt;').editableform({\n        type: 'text',\n        name: 'username',\n        url: '/post',\n        value: 'vitaliy'\n    });\n\n    //to display form you should call 'render' method\n    $form.editableform('render');     \n    */\n    $.fn.editableform = function (option) {\n        var args = arguments;\n        return this.each(function () {\n            var $this = $(this), \n            data = $this.data('editableform'), \n            options = typeof option === 'object' && option; \n            if (!data) {\n                $this.data('editableform', (data = new EditableForm(this, options)));\n            }\n\n            if (typeof option === 'string') { //call method \n                data[option].apply(data, Array.prototype.slice.call(args, 1));\n            } \n        });\n    };\n\n    //keep link to constructor to allow inheritance\n    $.fn.editableform.Constructor = EditableForm;    \n\n    //defaults\n    $.fn.editableform.defaults = {\n        /* see also defaults for input */\n\n        /**\n        Type of input. Can be <code>text|textarea|select|date|checklist</code>\n\n        @property type \n        @type string\n        @default 'text'\n        **/\n        type: 'text',\n        /**\n        Url for submit, e.g. <code>'/post'</code>  \n        If function - it will be called instead of ajax. Function should return deferred object to run fail/done callbacks.\n\n        @property url \n        @type string|function\n        @default null\n        @example\n        url: function(params) {\n            var d = new $.Deferred;\n            if(params.value === 'abc') {\n                return d.reject('error message'); //returning error via deferred object\n            } else {\n                //async saving data in js model\n                someModel.asyncSaveMethod({\n                   ..., \n                   success: function(){\n                      d.resolve();\n                   }\n                }); \n                return d.promise();\n            }\n        } \n        **/        \n        url:null,\n        /**\n        Additional params for submit. If defined as <code>object</code> - it is **appended** to original ajax data (pk, name and value).  \n        If defined as <code>function</code> - returned object **overwrites** original ajax data.\n        @example\n        params: function(params) {\n            //originally params contain pk, name and value\n            params.a = 1;\n            return params;\n        }\n\n        @property params \n        @type object|function\n        @default null\n        **/          \n        params:null,\n        /**\n        Name of field. Will be submitted on server. Can be taken from <code>id</code> attribute\n\n        @property name \n        @type string\n        @default null\n        **/         \n        name: null,\n        /**\n        Primary key of editable object (e.g. record id in database). For composite keys use object, e.g. <code>{id: 1, lang: 'en'}</code>.\n        Can be calculated dynamically via function.\n\n        @property pk \n        @type string|object|function\n        @default null\n        **/         \n        pk: null,\n        /**\n        Initial value. If not defined - will be taken from element's content.\n        For __select__ type should be defined (as it is ID of shown text).\n\n        @property value \n        @type string|object\n        @default null\n        **/        \n        value: null,\n        /**\n        Value that will be displayed in input if original field value is empty (`null|undefined|''`).\n\n        @property defaultValue \n        @type string|object\n        @default null\n        @since 1.4.6\n        **/        \n        defaultValue: null,\n        /**\n        Strategy for sending data on server. Can be `auto|always|never`.\n        When 'auto' data will be sent on server **only if pk and url defined**, otherwise new value will be stored locally.\n\n        @property send \n        @type string\n        @default 'auto'\n        **/          \n        send: 'auto', \n        /**\n        Function for client-side validation. If returns string - means validation not passed and string showed as error.\n        Since 1.5.1 you can modify submitted value by returning object from `validate`: \n        `{newValue: '...'}` or `{newValue: '...', msg: '...'}`\n\n        @property validate \n        @type function\n        @default null\n        @example\n        validate: function(value) {\n            if($.trim(value) == '') {\n                return 'This field is required';\n            }\n        }\n        **/         \n        validate: null,\n        /**\n        Success callback. Called when value successfully sent on server and **response status = 200**.  \n        Usefull to work with json response. For example, if your backend response can be <code>{success: true}</code>\n        or <code>{success: false, msg: \"server error\"}</code> you can check it inside this callback.  \n        If it returns **string** - means error occured and string is shown as error message.  \n        If it returns **object like** <code>{newValue: &lt;something&gt;}</code> - it overwrites value, submitted by user.  \n        Otherwise newValue simply rendered into element.\n        \n        @property success \n        @type function\n        @default null\n        @example\n        success: function(response, newValue) {\n            if(!response.success) return response.msg;\n        }\n        **/          \n        success: null,\n        /**\n        Error callback. Called when request failed (response status != 200).  \n        Usefull when you want to parse error response and display a custom message.\n        Must return **string** - the message to be displayed in the error block.\n                \n        @property error \n        @type function\n        @default null\n        @since 1.4.4\n        @example\n        error: function(response, newValue) {\n            if(response.status === 500) {\n                return 'Service unavailable. Please try later.';\n            } else {\n                return response.responseText;\n            }\n        }\n        **/          \n        error: null,\n        /**\n        Additional options for submit ajax request.\n        List of values: http://api.jquery.com/jQuery.ajax\n        \n        @property ajaxOptions \n        @type object\n        @default null\n        @since 1.1.1        \n        @example \n        ajaxOptions: {\n            type: 'put',\n            dataType: 'json'\n        }        \n        **/        \n        ajaxOptions: null,\n        /**\n        Where to show buttons: left(true)|bottom|false  \n        Form without buttons is auto-submitted.\n\n        @property showbuttons \n        @type boolean|string\n        @default true\n        @since 1.1.1\n        **/         \n        showbuttons: true,\n        /**\n        Scope for callback methods (success, validate).  \n        If <code>null</code> means editableform instance itself. \n\n        @property scope \n        @type DOMElement|object\n        @default null\n        @since 1.2.0\n        @private\n        **/            \n        scope: null,\n        /**\n        Whether to save or cancel value when it was not changed but form was submitted\n\n        @property savenochange \n        @type boolean\n        @default false\n        @since 1.2.0\n        **/\n        savenochange: false\n    };   \n\n    /*\n    Note: following params could redefined in engine: bootstrap or jqueryui:\n    Classes 'control-group' and 'editable-error-block' must always present!\n    */      \n    $.fn.editableform.template = '<form class=\"form-inline editableform\">'+\n    '<div class=\"control-group\">' + \n    '<div><div class=\"editable-input\"></div><div class=\"editable-buttons\"></div></div>'+\n    '<div class=\"editable-error-block\"></div>' + \n    '</div>' + \n    '</form>';\n\n    //loading div\n    $.fn.editableform.loading = '<div class=\"editableform-loading\"></div>';\n\n    //buttons\n    $.fn.editableform.buttons = '<button type=\"submit\" class=\"editable-submit\">ok</button>'+\n    '<button type=\"button\" class=\"editable-cancel\">cancel</button>';      \n\n    //error class attached to control-group\n    $.fn.editableform.errorGroupClass = null;  \n\n    //error class attached to editable-error-block\n    $.fn.editableform.errorBlockClass = 'editable-error';\n    \n    //engine\n    $.fn.editableform.engine = 'jquery';\n}(window.jQuery));\n\n/**\n* EditableForm utilites\n*/\n(function ($) {\n    \"use strict\";\n    \n    //utils\n    $.fn.editableutils = {\n        /**\n        * classic JS inheritance function\n        */  \n        inherit: function (Child, Parent) {\n            var F = function() { };\n            F.prototype = Parent.prototype;\n            Child.prototype = new F();\n            Child.prototype.constructor = Child;\n            Child.superclass = Parent.prototype;\n        },\n\n        /**\n        * set caret position in input\n        * see http://stackoverflow.com/questions/499126/jquery-set-cursor-position-in-text-area\n        */        \n        setCursorPosition: function(elem, pos) {\n            if (elem.setSelectionRange) {\n                elem.setSelectionRange(pos, pos);\n            } else if (elem.createTextRange) {\n                var range = elem.createTextRange();\n                range.collapse(true);\n                range.moveEnd('character', pos);\n                range.moveStart('character', pos);\n                range.select();\n            }\n        },\n\n        /**\n        * function to parse JSON in *single* quotes. (jquery automatically parse only double quotes)\n        * That allows such code as: <a data-source=\"{'a': 'b', 'c': 'd'}\">\n        * safe = true --> means no exception will be thrown\n        * for details see http://stackoverflow.com/questions/7410348/how-to-set-json-format-to-html5-data-attributes-in-the-jquery\n        */\n        tryParseJson: function(s, safe) {\n            if (typeof s === 'string' && s.length && s.match(/^[\\{\\[].*[\\}\\]]$/)) {\n                if (safe) {\n                    try {\n                        /*jslint evil: true*/\n                        s = (new Function('return ' + s))();\n                        /*jslint evil: false*/\n                    } catch (e) {} finally {\n                        return s;\n                    }\n                } else {\n                    /*jslint evil: true*/\n                    s = (new Function('return ' + s))();\n                    /*jslint evil: false*/\n                }\n            }\n            return s;\n        },\n\n        /**\n        * slice object by specified keys\n        */\n        sliceObj: function(obj, keys, caseSensitive /* default: false */) {\n            var key, keyLower, newObj = {};\n\n            if (!$.isArray(keys) || !keys.length) {\n                return newObj;\n            }\n\n            for (var i = 0; i < keys.length; i++) {\n                key = keys[i];\n                if (obj.hasOwnProperty(key)) {\n                    newObj[key] = obj[key];\n                }\n\n                if(caseSensitive === true) {\n                    continue;\n                }\n\n                //when getting data-* attributes via $.data() it's converted to lowercase.\n                //details: http://stackoverflow.com/questions/7602565/using-data-attributes-with-jquery\n                //workaround is code below.\n                keyLower = key.toLowerCase();\n                if (obj.hasOwnProperty(keyLower)) {\n                    newObj[key] = obj[keyLower];\n                }\n            }\n\n            return newObj;\n        },\n\n        /*\n        exclude complex objects from $.data() before pass to config\n        */\n        getConfigData: function($element) {\n            var data = {};\n            $.each($element.data(), function(k, v) {\n                if(typeof v !== 'object' || (v && typeof v === 'object' && (v.constructor === Object || v.constructor === Array))) {\n                    data[k] = v;\n                }\n            });\n            return data;\n        },\n\n        /*\n         returns keys of object\n        */\n        objectKeys: function(o) {\n            if (Object.keys) {\n                return Object.keys(o);  \n            } else {\n                if (o !== Object(o)) {\n                    throw new TypeError('Object.keys called on a non-object');\n                }\n                var k=[], p;\n                for (p in o) {\n                    if (Object.prototype.hasOwnProperty.call(o,p)) {\n                        k.push(p);\n                    }\n                }\n                return k;\n            }\n\n        },\n        \n       /**\n        method to escape html.\n       **/\n       escape: function(str) {\n           return $('<div>').text(str).html();\n       },\n       \n       /*\n        returns array items from sourceData having value property equal or inArray of 'value'\n       */\n       itemsByValue: function(value, sourceData, valueProp) {\n           if(!sourceData || value === null) {\n               return [];\n           }\n           \n           if (typeof(valueProp) !== \"function\") {\n               var idKey = valueProp || 'value';\n               valueProp = function (e) { return e[idKey]; };\n           }\n                      \n           var isValArray = $.isArray(value),\n           result = [], \n           that = this;\n\n           $.each(sourceData, function(i, o) {\n               if(o.children) {\n                   result = result.concat(that.itemsByValue(value, o.children, valueProp));\n               } else {\n                   /*jslint eqeq: true*/\n                   if(isValArray) {\n                       if($.grep(value, function(v){  return v == (o && typeof o === 'object' ? valueProp(o) : o); }).length) {\n                           result.push(o); \n                       }\n                   } else {\n                       var itemValue = (o && (typeof o === 'object')) ? valueProp(o) : o;\n                       if(value == itemValue) {\n                           result.push(o); \n                       }\n                   }\n                   /*jslint eqeq: false*/\n               }\n           });\n           \n           return result;\n       },\n       \n       /*\n       Returns input by options: type, mode. \n       */\n       createInput: function(options) {\n           var TypeConstructor, typeOptions, input,\n           type = options.type;\n\n           //`date` is some kind of virtual type that is transformed to one of exact types\n           //depending on mode and core lib\n           if(type === 'date') {\n               //inline\n               if(options.mode === 'inline') {\n                   if($.fn.editabletypes.datefield) {\n                       type = 'datefield';\n                   } else if($.fn.editabletypes.dateuifield) {\n                       type = 'dateuifield';\n                   }\n               //popup\n               } else {\n                   if($.fn.editabletypes.date) {\n                       type = 'date';\n                   } else if($.fn.editabletypes.dateui) {\n                       type = 'dateui';\n                   }\n               }\n               \n               //if type still `date` and not exist in types, replace with `combodate` that is base input\n               if(type === 'date' && !$.fn.editabletypes.date) {\n                   type = 'combodate';\n               } \n           }\n           \n           //`datetime` should be datetimefield in 'inline' mode\n           if(type === 'datetime' && options.mode === 'inline') {\n             type = 'datetimefield';  \n           }           \n\n           //change wysihtml5 to textarea for jquery UI and plain versions\n           if(type === 'wysihtml5' && !$.fn.editabletypes[type]) {\n               type = 'textarea';\n           }\n\n           //create input of specified type. Input will be used for converting value, not in form\n           if(typeof $.fn.editabletypes[type] === 'function') {\n               TypeConstructor = $.fn.editabletypes[type];\n               typeOptions = this.sliceObj(options, this.objectKeys(TypeConstructor.defaults));\n               input = new TypeConstructor(typeOptions);\n               return input;\n           } else {\n               $.error('Unknown type: '+ type);\n               return false; \n           }  \n       },\n       \n       //see http://stackoverflow.com/questions/7264899/detect-css-transitions-using-javascript-and-without-modernizr\n       supportsTransitions: function () {\n           var b = document.body || document.documentElement,\n               s = b.style,\n               p = 'transition',\n               v = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];\n               \n           if(typeof s[p] === 'string') {\n               return true; \n           }\n\n           // Tests for vendor specific prop\n           p = p.charAt(0).toUpperCase() + p.substr(1);\n           for(var i=0; i<v.length; i++) {\n               if(typeof s[v[i] + p] === 'string') { \n                   return true; \n               }\n           }\n           return false;\n       }            \n       \n    };      \n}(window.jQuery));\n\n/**\nAttaches stand-alone container with editable-form to HTML element. Element is used only for positioning, value is not stored anywhere.<br>\nThis method applied internally in <code>$().editable()</code>. You should subscribe on it's events (save / cancel) to get profit of it.<br>\nFinal realization can be different: bootstrap-popover, jqueryui-tooltip, poshytip, inline-div. It depends on which js file you include.<br>\nApplied as jQuery method.\n\n@class editableContainer\n@uses editableform\n**/\n(function ($) {\n    \"use strict\";\n\n    var Popup = function (element, options) {\n        this.init(element, options);\n    };\n    \n    var Inline = function (element, options) {\n        this.init(element, options);\n    };    \n\n    //methods\n    Popup.prototype = {\n        containerName: null, //method to call container on element\n        containerDataName: null, //object name in element's .data()\n        innerCss: null, //tbd in child class\n        containerClass: 'editable-container editable-popup', //css class applied to container element\n        defaults: {}, //container itself defaults\n        \n        init: function(element, options) {\n            this.$element = $(element);\n            //since 1.4.1 container do not use data-* directly as they already merged into options.\n            this.options = $.extend({}, $.fn.editableContainer.defaults, options);         \n            this.splitOptions();\n            \n            //set scope of form callbacks to element\n            this.formOptions.scope = this.$element[0]; \n            \n            this.initContainer();\n            \n            //flag to hide container, when saving value will finish\n            this.delayedHide = false;\n\n            //bind 'destroyed' listener to destroy container when element is removed from dom\n            this.$element.on('destroyed', $.proxy(function(){\n                this.destroy();\n            }, this)); \n            \n            //attach document handler to close containers on click / escape\n            if(!$(document).data('editable-handlers-attached')) {\n                //close all on escape\n                $(document).on('keyup.editable', function (e) {\n                    if (e.which === 27) {\n                        $('.editable-open').editableContainer('hide');\n                        //todo: return focus on element \n                    }\n                });\n\n                //close containers when click outside \n                //(mousedown could be better than click, it closes everything also on drag drop)\n                $(document).on('click.editable', function(e) {\n                    var $target = $(e.target), i,\n                        exclude_classes = ['.editable-container', \n                                           '.ui-datepicker-header', \n                                           '.datepicker', //in inline mode datepicker is rendered into body\n                                           '.modal-backdrop', \n                                           '.bootstrap-wysihtml5-insert-image-modal', \n                                           '.bootstrap-wysihtml5-insert-link-modal'\n                                           ];\n                    \n                    //check if element is detached. It occurs when clicking in bootstrap datepicker\n                    if (!$.contains(document.documentElement, e.target)) {\n                      return;\n                    }\n\n                    //for some reason FF 20 generates extra event (click) in select2 widget with e.target = document\n                    //we need to filter it via construction below. See https://github.com/vitalets/x-editable/issues/199\n                    //Possibly related to http://stackoverflow.com/questions/10119793/why-does-firefox-react-differently-from-webkit-and-ie-to-click-event-on-selec\n                    if($target.is(document)) {\n                       return; \n                    }\n                    \n                    //if click inside one of exclude classes --> no nothing\n                    for(i=0; i<exclude_classes.length; i++) {\n                         if($target.is(exclude_classes[i]) || $target.parents(exclude_classes[i]).length) {\n                             return;\n                         }\n                    }\n                      \n                    //close all open containers (except one - target)\n                    Popup.prototype.closeOthers(e.target);\n                });\n                \n                $(document).data('editable-handlers-attached', true);\n            }                        \n        },\n\n        //split options on containerOptions and formOptions\n        splitOptions: function() {\n            this.containerOptions = {};\n            this.formOptions = {};\n            \n            if(!$.fn[this.containerName]) {\n                throw new Error(this.containerName + ' not found. Have you included corresponding js file?');   \n            }\n            \n            //keys defined in container defaults go to container, others go to form\n            for(var k in this.options) {\n              if(k in this.defaults) {\n                 this.containerOptions[k] = this.options[k];\n              } else {\n                 this.formOptions[k] = this.options[k];\n              } \n            }\n        },\n        \n        /*\n        Returns jquery object of container\n        @method tip()\n        */         \n        tip: function() {\n            return this.container() ? this.container().$tip : null;\n        },\n\n        /* returns container object */\n        container: function() {\n            var container;\n            //first, try get it by `containerDataName`\n            if(this.containerDataName) {\n                if(container = this.$element.data(this.containerDataName)) {\n                    return container;\n                }\n            }\n            //second, try `containerName`\n            container = this.$element.data(this.containerName);\n            return container;\n        },\n\n        /* call native method of underlying container, e.g. this.$element.popover('method') */ \n        call: function() {\n            this.$element[this.containerName].apply(this.$element, arguments); \n        },        \n        \n        initContainer: function(){\n            this.call(this.containerOptions);\n        },\n\n        renderForm: function() {\n            this.$form\n            .editableform(this.formOptions)\n            .on({\n                save: $.proxy(this.save, this), //click on submit button (value changed)\n                nochange: $.proxy(function(){ this.hide('nochange'); }, this), //click on submit button (value NOT changed)                \n                cancel: $.proxy(function(){ this.hide('cancel'); }, this), //click on calcel button\n                show: $.proxy(function() {\n                    if(this.delayedHide) {\n                        this.hide(this.delayedHide.reason);\n                        this.delayedHide = false;\n                    } else {\n                        this.setPosition();\n                    }\n                }, this), //re-position container every time form is shown (occurs each time after loading state)\n                rendering: $.proxy(this.setPosition, this), //this allows to place container correctly when loading shown\n                resize: $.proxy(this.setPosition, this), //this allows to re-position container when form size is changed \n                rendered: $.proxy(function(){\n                    /**        \n                    Fired when container is shown and form is rendered (for select will wait for loading dropdown options).  \n                    **Note:** Bootstrap popover has own `shown` event that now cannot be separated from x-editable's one.\n                    The workaround is to check `arguments.length` that is always `2` for x-editable.                     \n                    \n                    @event shown \n                    @param {Object} event event object\n                    @example\n                    $('#username').on('shown', function(e, editable) {\n                        editable.input.$input.val('overwriting value of input..');\n                    });                     \n                    **/                      \n                    /*\n                     TODO: added second param mainly to distinguish from bootstrap's shown event. It's a hotfix that will be solved in future versions via namespaced events.  \n                    */\n                    this.$element.triggerHandler('shown', $(this.options.scope).data('editable')); \n                }, this) \n            })\n            .editableform('render');\n        },        \n\n        /**\n        Shows container with form\n        @method show()\n        @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.\n        **/\n        /* Note: poshytip owerwrites this method totally! */          \n        show: function (closeAll) {\n            this.$element.addClass('editable-open');\n            if(closeAll !== false) {\n                //close all open containers (except this)\n                this.closeOthers(this.$element[0]);  \n            }\n            \n            //show container itself\n            this.innerShow();\n            this.tip().addClass(this.containerClass);\n\n            /*\n            Currently, form is re-rendered on every show. \n            The main reason is that we dont know, what will container do with content when closed:\n            remove(), detach() or just hide() - it depends on container.\n            \n            Detaching form itself before hide and re-insert before show is good solution, \n            but visually it looks ugly --> container changes size before hide.  \n            */             \n            \n            //if form already exist - delete previous data \n            if(this.$form) {\n                //todo: destroy prev data!\n                //this.$form.destroy();\n            }\n\n            this.$form = $('<div>');\n            \n            //insert form into container body\n            if(this.tip().is(this.innerCss)) {\n                //for inline container\n                this.tip().append(this.$form); \n            } else {\n                this.tip().find(this.innerCss).append(this.$form);\n            } \n            \n            //render form\n            this.renderForm();\n        },\n\n        /**\n        Hides container with form\n        @method hide()\n        @param {string} reason Reason caused hiding. Can be <code>save|cancel|onblur|nochange|undefined (=manual)</code>\n        **/         \n        hide: function(reason) {  \n            if(!this.tip() || !this.tip().is(':visible') || !this.$element.hasClass('editable-open')) {\n                return;\n            }\n            \n            //if form is saving value, schedule hide\n            if(this.$form.data('editableform').isSaving) {\n                this.delayedHide = {reason: reason};\n                return;    \n            } else {\n                this.delayedHide = false;\n            }\n\n            this.$element.removeClass('editable-open');   \n            this.innerHide();\n\n            /**\n            Fired when container was hidden. It occurs on both save or cancel.  \n            **Note:** Bootstrap popover has own `hidden` event that now cannot be separated from x-editable's one.\n            The workaround is to check `arguments.length` that is always `2` for x-editable. \n\n            @event hidden \n            @param {object} event event object\n            @param {string} reason Reason caused hiding. Can be <code>save|cancel|onblur|nochange|manual</code>\n            @example\n            $('#username').on('hidden', function(e, reason) {\n                if(reason === 'save' || reason === 'cancel') {\n                    //auto-open next editable\n                    $(this).closest('tr').next().find('.editable').editable('show');\n                } \n            });\n            **/\n            this.$element.triggerHandler('hidden', reason || 'manual');   \n        },\n\n        /* internal show method. To be overwritten in child classes */\n        innerShow: function () {\n             \n        },        \n\n        /* internal hide method. To be overwritten in child classes */\n        innerHide: function () {\n\n        },\n        \n        /**\n        Toggles container visibility (show / hide)\n        @method toggle()\n        @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.\n        **/          \n        toggle: function(closeAll) {\n            if(this.container() && this.tip() && this.tip().is(':visible')) {\n                this.hide();\n            } else {\n                this.show(closeAll);\n            } \n        },\n\n        /*\n        Updates the position of container when content changed.\n        @method setPosition()\n        */       \n        setPosition: function() {\n            //tbd in child class\n        },\n\n        save: function(e, params) {\n            /**        \n            Fired when new value was submitted. You can use <code>$(this).data('editableContainer')</code> inside handler to access to editableContainer instance\n            \n            @event save \n            @param {Object} event event object\n            @param {Object} params additional params\n            @param {mixed} params.newValue submitted value\n            @param {Object} params.response ajax response\n            @example\n            $('#username').on('save', function(e, params) {\n                //assuming server response: '{success: true}'\n                var pk = $(this).data('editableContainer').options.pk;\n                if(params.response && params.response.success) {\n                    alert('value: ' + params.newValue + ' with pk: ' + pk + ' saved!');\n                } else {\n                    alert('error!'); \n                } \n            });\n            **/             \n            this.$element.triggerHandler('save', params);\n            \n            //hide must be after trigger, as saving value may require methods of plugin, applied to input\n            this.hide('save');\n        },\n\n        /**\n        Sets new option\n        \n        @method option(key, value)\n        @param {string} key \n        @param {mixed} value \n        **/         \n        option: function(key, value) {\n            this.options[key] = value;\n            if(key in this.containerOptions) {\n                this.containerOptions[key] = value;\n                this.setContainerOption(key, value); \n            } else {\n                this.formOptions[key] = value;\n                if(this.$form) {\n                    this.$form.editableform('option', key, value);  \n                }\n            }\n        },\n        \n        setContainerOption: function(key, value) {\n            this.call('option', key, value);\n        },\n\n        /**\n        Destroys the container instance\n        @method destroy()\n        **/        \n        destroy: function() {\n            this.hide();\n            this.innerDestroy();\n            this.$element.off('destroyed');\n            this.$element.removeData('editableContainer');\n        },\n        \n        /* to be overwritten in child classes */\n        innerDestroy: function() {\n            \n        }, \n        \n        /*\n        Closes other containers except one related to passed element. \n        Other containers can be cancelled or submitted (depends on onblur option)\n        */\n        closeOthers: function(element) {\n            $('.editable-open').each(function(i, el){\n                //do nothing with passed element and it's children\n                if(el === element || $(el).find(element).length) {\n                    return;\n                }\n\n                //otherwise cancel or submit all open containers \n                var $el = $(el),\n                ec = $el.data('editableContainer');\n\n                if(!ec) {\n                    return;  \n                }\n                \n                if(ec.options.onblur === 'cancel') {\n                    $el.data('editableContainer').hide('onblur');\n                } else if(ec.options.onblur === 'submit') {\n                    $el.data('editableContainer').tip().find('form').submit();\n                }\n            });\n\n        },\n        \n        /**\n        Activates input of visible container (e.g. set focus)\n        @method activate()\n        **/         \n        activate: function() {\n            if(this.tip && this.tip().is(':visible') && this.$form) {\n               this.$form.data('editableform').input.activate(); \n            }\n        } \n\n    };\n\n    /**\n    jQuery method to initialize editableContainer.\n    \n    @method $().editableContainer(options)\n    @params {Object} options\n    @example\n    $('#edit').editableContainer({\n        type: 'text',\n        url: '/post',\n        pk: 1,\n        value: 'hello'\n    });\n    **/  \n    $.fn.editableContainer = function (option) {\n        var args = arguments;\n        return this.each(function () {\n            var $this = $(this),\n            dataKey = 'editableContainer', \n            data = $this.data(dataKey),\n            options = typeof option === 'object' && option,\n            Constructor = (options.mode === 'inline') ? Inline : Popup;             \n\n            if (!data) {\n                $this.data(dataKey, (data = new Constructor(this, options)));\n            }\n\n            if (typeof option === 'string') { //call method \n                data[option].apply(data, Array.prototype.slice.call(args, 1));\n            }            \n        });\n    };     \n\n    //store constructors\n    $.fn.editableContainer.Popup = Popup;\n    $.fn.editableContainer.Inline = Inline;\n\n    //defaults\n    $.fn.editableContainer.defaults = {\n        /**\n        Initial value of form input\n\n        @property value \n        @type mixed\n        @default null\n        @private\n        **/        \n        value: null,\n        /**\n        Placement of container relative to element. Can be <code>top|right|bottom|left</code>. Not used for inline container.\n\n        @property placement \n        @type string\n        @default 'top'\n        **/        \n        placement: 'top',\n        /**\n        Whether to hide container on save/cancel.\n\n        @property autohide \n        @type boolean\n        @default true\n        @private \n        **/        \n        autohide: true,\n        /**\n        Action when user clicks outside the container. Can be <code>cancel|submit|ignore</code>.  \n        Setting <code>ignore</code> allows to have several containers open. \n\n        @property onblur \n        @type string\n        @default 'cancel'\n        @since 1.1.1\n        **/        \n        onblur: 'cancel',\n        \n        /**\n        Animation speed (inline mode only)\n        @property anim \n        @type string\n        @default false\n        **/        \n        anim: false,\n        \n        /**\n        Mode of editable, can be `popup` or `inline` \n        \n        @property mode \n        @type string         \n        @default 'popup'\n        @since 1.4.0        \n        **/        \n        mode: 'popup'        \n    };\n\n    /* \n    * workaround to have 'destroyed' event to destroy popover when element is destroyed\n    * see http://stackoverflow.com/questions/2200494/jquery-trigger-event-when-an-element-is-removed-from-the-dom\n    */\n    jQuery.event.special.destroyed = {\n        remove: function(o) {\n            if (o.handler) {\n                o.handler();\n            }\n        }\n    };    \n\n}(window.jQuery));\n\n/**\n* Editable Inline \n* ---------------------\n*/\n(function ($) {\n    \"use strict\";\n    \n    //copy prototype from EditableContainer\n    //extend methods\n    $.extend($.fn.editableContainer.Inline.prototype, $.fn.editableContainer.Popup.prototype, {\n        containerName: 'editableform',\n        innerCss: '.editable-inline',\n        containerClass: 'editable-container editable-inline', //css class applied to container element\n                 \n        initContainer: function(){\n            //container is <span> element\n            this.$tip = $('<span></span>');\n            \n            //convert anim to miliseconds (int)\n            if(!this.options.anim) {\n                this.options.anim = 0;\n            }         \n        },\n        \n        splitOptions: function() {\n            //all options are passed to form\n            this.containerOptions = {};\n            this.formOptions = this.options;\n        },\n        \n        tip: function() {\n           return this.$tip; \n        },\n        \n        innerShow: function () {\n            this.$element.hide();\n            this.tip().insertAfter(this.$element).show();\n        }, \n        \n        innerHide: function () {\n            this.$tip.hide(this.options.anim, $.proxy(function() {\n                this.$element.show();\n                this.innerDestroy();\n            }, this)); \n        },\n        \n        innerDestroy: function() {\n            if(this.tip()) {\n                this.tip().empty().remove();\n            }\n        } \n    });\n\n}(window.jQuery));\n/**\nMakes editable any HTML element on the page. Applied as jQuery method.\n\n@class editable\n@uses editableContainer\n**/\n(function ($) {\n    \"use strict\";\n\n    var Editable = function (element, options) {\n        this.$element = $(element);\n        //data-* has more priority over js options: because dynamically created elements may change data-* \n        this.options = $.extend({}, $.fn.editable.defaults, options, $.fn.editableutils.getConfigData(this.$element));  \n        if(this.options.selector) {\n            this.initLive();\n        } else {\n            this.init();\n        }\n        \n        //check for transition support\n        if(this.options.highlight && !$.fn.editableutils.supportsTransitions()) {\n            this.options.highlight = false;\n        }\n    };\n\n    Editable.prototype = {\n        constructor: Editable, \n        init: function () {\n            var isValueByText = false, \n                doAutotext, finalize;\n\n            //name\n            this.options.name = this.options.name || this.$element.attr('id');\n             \n            //create input of specified type. Input needed already here to convert value for initial display (e.g. show text by id for select)\n            //also we set scope option to have access to element inside input specific callbacks (e. g. source as function)\n            this.options.scope = this.$element[0]; \n            this.input = $.fn.editableutils.createInput(this.options);\n            if(!this.input) {\n                return; \n            }            \n\n            //set value from settings or by element's text\n            if (this.options.value === undefined || this.options.value === null) {\n                this.value = this.input.html2value($.trim(this.$element.html()));\n                isValueByText = true;\n            } else {\n                /*\n                  value can be string when received from 'data-value' attribute\n                  for complext objects value can be set as json string in data-value attribute, \n                  e.g. data-value=\"{city: 'Moscow', street: 'Lenina'}\"\n                */\n                this.options.value = $.fn.editableutils.tryParseJson(this.options.value, true); \n                if(typeof this.options.value === 'string') {\n                    this.value = this.input.str2value(this.options.value);\n                } else {\n                    this.value = this.options.value;\n                }\n            }\n            \n            //add 'editable' class to every editable element\n            this.$element.addClass('editable');\n            \n            //specifically for \"textarea\" add class .editable-pre-wrapped to keep linebreaks\n            if(this.input.type === 'textarea') {\n                this.$element.addClass('editable-pre-wrapped');\n            }\n            \n            //attach handler activating editable. In disabled mode it just prevent default action (useful for links)\n            if(this.options.toggle !== 'manual') {\n                this.$element.addClass('editable-click');\n                this.$element.on(this.options.toggle + '.editable', $.proxy(function(e){\n                    //prevent following link if editable enabled\n                    if(!this.options.disabled) {\n                        e.preventDefault();\n                    }\n                    \n                    //stop propagation not required because in document click handler it checks event target\n                    //e.stopPropagation();\n                    \n                    if(this.options.toggle === 'mouseenter') {\n                        //for hover only show container\n                        this.show();\n                    } else {\n                        //when toggle='click' we should not close all other containers as they will be closed automatically in document click listener\n                        var closeAll = (this.options.toggle !== 'click');\n                        this.toggle(closeAll);\n                    }\n                }, this));\n            } else {\n                this.$element.attr('tabindex', -1); //do not stop focus on element when toggled manually\n            }\n            \n            //if display is function it's far more convinient to have autotext = always to render correctly on init\n            //see https://github.com/vitalets/x-editable-yii/issues/34\n            if(typeof this.options.display === 'function') {\n                this.options.autotext = 'always';\n            }\n            \n            //check conditions for autotext:\n            switch(this.options.autotext) {\n              case 'always':\n               doAutotext = true;\n              break;\n              case 'auto':\n                //if element text is empty and value is defined and value not generated by text --> run autotext\n                doAutotext = !$.trim(this.$element.text()).length && this.value !== null && this.value !== undefined && !isValueByText;\n              break;\n              default:\n               doAutotext = false;\n            }\n\n            //depending on autotext run render() or just finilize init\n            $.when(doAutotext ? this.render() : true).then($.proxy(function() {\n                if(this.options.disabled) {\n                    this.disable();\n                } else {\n                    this.enable(); \n                }\n               /**        \n               Fired when element was initialized by `$().editable()` method. \n               Please note that you should setup `init` handler **before** applying `editable`. \n                              \n               @event init \n               @param {Object} event event object\n               @param {Object} editable editable instance (as here it cannot accessed via data('editable'))\n               @since 1.2.0\n               @example\n               $('#username').on('init', function(e, editable) {\n                   alert('initialized ' + editable.options.name);\n               });\n               $('#username').editable();\n               **/                  \n                this.$element.triggerHandler('init', this);\n            }, this));\n        },\n\n        /*\n         Initializes parent element for live editables \n        */\n        initLive: function() {\n           //store selector \n           var selector = this.options.selector;\n           //modify options for child elements\n           this.options.selector = false; \n           this.options.autotext = 'never';\n           //listen toggle events\n           this.$element.on(this.options.toggle + '.editable', selector, $.proxy(function(e){\n               var $target = $(e.target);\n               if(!$target.data('editable')) {\n                   //if delegated element initially empty, we need to clear it's text (that was manually set to `empty` by user)\n                   //see https://github.com/vitalets/x-editable/issues/137 \n                   if($target.hasClass(this.options.emptyclass)) {\n                      $target.empty();\n                   }\n                   $target.editable(this.options).trigger(e);\n               }\n           }, this)); \n        },\n        \n        /*\n        Renders value into element's text.\n        Can call custom display method from options.\n        Can return deferred object.\n        @method render()\n        @param {mixed} response server response (if exist) to pass into display function\n        */          \n        render: function(response) {\n            //do not display anything\n            if(this.options.display === false) {\n                return;\n            }\n            \n            //if input has `value2htmlFinal` method, we pass callback in third param to be called when source is loaded\n            if(this.input.value2htmlFinal) {\n                return this.input.value2html(this.value, this.$element[0], this.options.display, response); \n            //if display method defined --> use it    \n            } else if(typeof this.options.display === 'function') {\n                return this.options.display.call(this.$element[0], this.value, response);\n            //else use input's original value2html() method    \n            } else {\n                return this.input.value2html(this.value, this.$element[0]); \n            }\n        },\n        \n        /**\n        Enables editable\n        @method enable()\n        **/          \n        enable: function() {\n            this.options.disabled = false;\n            this.$element.removeClass('editable-disabled');\n            this.handleEmpty(this.isEmpty);\n            if(this.options.toggle !== 'manual') {\n                if(this.$element.attr('tabindex') === '-1') {    \n                    this.$element.removeAttr('tabindex');                                \n                }\n            }\n        },\n        \n        /**\n        Disables editable\n        @method disable()\n        **/         \n        disable: function() {\n            this.options.disabled = true; \n            this.hide();           \n            this.$element.addClass('editable-disabled');\n            this.handleEmpty(this.isEmpty);\n            //do not stop focus on this element\n            this.$element.attr('tabindex', -1);                \n        },\n        \n        /**\n        Toggles enabled / disabled state of editable element\n        @method toggleDisabled()\n        **/         \n        toggleDisabled: function() {\n            if(this.options.disabled) {\n                this.enable();\n            } else { \n                this.disable(); \n            }\n        },  \n        \n        /**\n        Sets new option\n        \n        @method option(key, value)\n        @param {string|object} key option name or object with several options\n        @param {mixed} value option new value\n        @example\n        $('.editable').editable('option', 'pk', 2);\n        **/          \n        option: function(key, value) {\n            //set option(s) by object\n            if(key && typeof key === 'object') {\n               $.each(key, $.proxy(function(k, v){\n                  this.option($.trim(k), v); \n               }, this)); \n               return;\n            }\n\n            //set option by string             \n            this.options[key] = value;                          \n            \n            //disabled\n            if(key === 'disabled') {\n               return value ? this.disable() : this.enable();\n            } \n            \n            //value\n            if(key === 'value') {\n                this.setValue(value);\n            }\n            \n            //transfer new option to container! \n            if(this.container) {\n                this.container.option(key, value);  \n            }\n             \n            //pass option to input directly (as it points to the same in form)\n            if(this.input.option) {\n                this.input.option(key, value);\n            }\n            \n        },              \n        \n        /*\n        * set emptytext if element is empty\n        */\n        handleEmpty: function (isEmpty) {\n            //do not handle empty if we do not display anything\n            if(this.options.display === false) {\n                return;\n            }\n\n            /* \n            isEmpty may be set directly as param of method.\n            It is required when we enable/disable field and can't rely on content \n            as node content is text: \"Empty\" that is not empty %)\n            */\n            if(isEmpty !== undefined) { \n                this.isEmpty = isEmpty;\n            } else {\n                //detect empty\n                //for some inputs we need more smart check\n                //e.g. wysihtml5 may have <br>, <p></p>, <img>\n                if(typeof(this.input.isEmpty) === 'function') {\n                    this.isEmpty = this.input.isEmpty(this.$element);                    \n                } else {\n                    this.isEmpty = $.trim(this.$element.html()) === '';\n                }\n            }           \n            \n            //emptytext shown only for enabled\n            if(!this.options.disabled) {\n                if (this.isEmpty) {\n                    this.$element.html(this.options.emptytext);\n                    if(this.options.emptyclass) {\n                        this.$element.addClass(this.options.emptyclass);\n                    }\n                } else if(this.options.emptyclass) {\n                    this.$element.removeClass(this.options.emptyclass);\n                }\n            } else {\n                //below required if element disable property was changed\n                if(this.isEmpty) {\n                    this.$element.empty();\n                    if(this.options.emptyclass) {\n                        this.$element.removeClass(this.options.emptyclass);\n                    }\n                }\n            }\n        },        \n        \n        /**\n        Shows container with form\n        @method show()\n        @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.\n        **/  \n        show: function (closeAll) {\n            if(this.options.disabled) {\n                return;\n            }\n            \n            //init editableContainer: popover, tooltip, inline, etc..\n            if(!this.container) {\n                var containerOptions = $.extend({}, this.options, {\n                    value: this.value,\n                    input: this.input //pass input to form (as it is already created)\n                });\n                this.$element.editableContainer(containerOptions);\n                //listen `save` event \n                this.$element.on(\"save.internal\", $.proxy(this.save, this));\n                this.container = this.$element.data('editableContainer'); \n            } else if(this.container.tip().is(':visible')) {\n                return;\n            }      \n            \n            //show container\n            this.container.show(closeAll);\n        },\n        \n        /**\n        Hides container with form\n        @method hide()\n        **/       \n        hide: function () {   \n            if(this.container) {  \n                this.container.hide();\n            }\n        },\n        \n        /**\n        Toggles container visibility (show / hide)\n        @method toggle()\n        @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.\n        **/  \n        toggle: function(closeAll) {\n            if(this.container && this.container.tip().is(':visible')) {\n                this.hide();\n            } else {\n                this.show(closeAll);\n            }\n        },\n        \n        /*\n        * called when form was submitted\n        */          \n        save: function(e, params) {\n            //mark element with unsaved class if needed\n            if(this.options.unsavedclass) {\n                /*\n                 Add unsaved css to element if:\n                  - url is not user's function \n                  - value was not sent to server\n                  - params.response === undefined, that means data was not sent\n                  - value changed \n                */\n                var sent = false;\n                sent = sent || typeof this.options.url === 'function';\n                sent = sent || this.options.display === false; \n                sent = sent || params.response !== undefined; \n                sent = sent || (this.options.savenochange && this.input.value2str(this.value) !== this.input.value2str(params.newValue)); \n                \n                if(sent) {\n                    this.$element.removeClass(this.options.unsavedclass); \n                } else {\n                    this.$element.addClass(this.options.unsavedclass);                    \n                }\n            }\n            \n            //highlight when saving\n            if(this.options.highlight) {\n                var $e = this.$element,\n                    bgColor = $e.css('background-color');\n                    \n                $e.css('background-color', this.options.highlight);\n                setTimeout(function(){\n                    if(bgColor === 'transparent') {\n                        bgColor = ''; \n                    }\n                    $e.css('background-color', bgColor);\n                    $e.addClass('editable-bg-transition');\n                    setTimeout(function(){\n                       $e.removeClass('editable-bg-transition');  \n                    }, 1700);\n                }, 10);\n            }\n            \n            //set new value\n            this.setValue(params.newValue, false, params.response);\n            \n            /**        \n            Fired when new value was submitted. You can use <code>$(this).data('editable')</code> to access to editable instance\n            \n            @event save \n            @param {Object} event event object\n            @param {Object} params additional params\n            @param {mixed} params.newValue submitted value\n            @param {Object} params.response ajax response\n            @example\n            $('#username').on('save', function(e, params) {\n                alert('Saved value: ' + params.newValue);\n            });\n            **/\n            //event itself is triggered by editableContainer. Description here is only for documentation              \n        },\n\n        validate: function () {\n            if (typeof this.options.validate === 'function') {\n                return this.options.validate.call(this, this.value);\n            }\n        },\n        \n        /**\n        Sets new value of editable\n        @method setValue(value, convertStr)\n        @param {mixed} value new value \n        @param {boolean} convertStr whether to convert value from string to internal format\n        **/         \n        setValue: function(value, convertStr, response) {\n            if(convertStr) {\n                this.value = this.input.str2value(value);\n            } else {\n                this.value = value;\n            }\n            if(this.container) {\n                this.container.option('value', this.value);\n            }\n            $.when(this.render(response))\n            .then($.proxy(function() {\n                this.handleEmpty();\n            }, this));\n        },\n        \n        /**\n        Activates input of visible container (e.g. set focus)\n        @method activate()\n        **/         \n        activate: function() {\n            if(this.container) {\n               this.container.activate(); \n            }\n        },\n        \n        /**\n        Removes editable feature from element\n        @method destroy()\n        **/        \n        destroy: function() {\n            this.disable();\n            \n            if(this.container) {\n               this.container.destroy(); \n            }\n            \n            this.input.destroy();\n\n            if(this.options.toggle !== 'manual') {\n                this.$element.removeClass('editable-click');\n                this.$element.off(this.options.toggle + '.editable');\n            } \n            \n            this.$element.off(\"save.internal\");\n            \n            this.$element.removeClass('editable editable-open editable-disabled');\n            this.$element.removeData('editable');\n        }        \n    };\n\n    /* EDITABLE PLUGIN DEFINITION\n    * ======================= */\n\n    /**\n    jQuery method to initialize editable element.\n    \n    @method $().editable(options)\n    @params {Object} options\n    @example\n    $('#username').editable({\n        type: 'text',\n        url: '/post',\n        pk: 1\n    });\n    **/\n    $.fn.editable = function (option) {\n        //special API methods returning non-jquery object\n        var result = {}, args = arguments, datakey = 'editable';\n        switch (option) {\n            /**\n            Runs client-side validation for all matched editables\n            \n            @method validate()\n            @returns {Object} validation errors map\n            @example\n            $('#username, #fullname').editable('validate');\n            // possible result:\n            {\n              username: \"username is required\",\n              fullname: \"fullname should be minimum 3 letters length\"\n            }\n            **/\n            case 'validate':\n                this.each(function () {\n                    var $this = $(this), data = $this.data(datakey), error;\n                    if (data && (error = data.validate())) {\n                        result[data.options.name] = error;\n                    }\n                });\n            return result;\n\n            /**\n            Returns current values of editable elements.   \n            Note that it returns an **object** with name-value pairs, not a value itself. It allows to get data from several elements.    \n            If value of some editable is `null` or `undefined` it is excluded from result object.\n            When param `isSingle` is set to **true** - it is supposed you have single element and will return value of editable instead of object.   \n             \n            @method getValue()\n            @param {bool} isSingle whether to return just value of single element\n            @returns {Object} object of element names and values\n            @example\n            $('#username, #fullname').editable('getValue');\n            //result:\n            {\n            username: \"superuser\",\n            fullname: \"John\"\n            }\n            //isSingle = true\n            $('#username').editable('getValue', true);\n            //result \"superuser\" \n            **/\n            case 'getValue':\n                if(arguments.length === 2 && arguments[1] === true) { //isSingle = true\n                    result = this.eq(0).data(datakey).value;\n                } else {\n                    this.each(function () {\n                        var $this = $(this), data = $this.data(datakey);\n                        if (data && data.value !== undefined && data.value !== null) {\n                            result[data.options.name] = data.input.value2submit(data.value);\n                        }\n                    });\n                }\n            return result;\n\n            /**\n            This method collects values from several editable elements and submit them all to server.   \n            Internally it runs client-side validation for all fields and submits only in case of success.  \n            See <a href=\"#newrecord\">creating new records</a> for details.  \n            Since 1.5.1 `submit` can be applied to single element to send data programmatically. In that case\n            `url`, `success` and `error` is taken from initial options and you can just call `$('#username').editable('submit')`. \n            \n            @method submit(options)\n            @param {object} options \n            @param {object} options.url url to submit data \n            @param {object} options.data additional data to submit\n            @param {object} options.ajaxOptions additional ajax options\n            @param {function} options.error(obj) error handler \n            @param {function} options.success(obj,config) success handler\n            @returns {Object} jQuery object\n            **/\n            case 'submit':  //collects value, validate and submit to server for creating new record\n                var config = arguments[1] || {},\n                $elems = this,\n                errors = this.editable('validate');\n\n                // validation ok\n                if($.isEmptyObject(errors)) {\n                    var ajaxOptions = {};\n                                                      \n                    // for single element use url, success etc from options\n                    if($elems.length === 1) {\n                        var editable = $elems.data('editable');\n                        //standard params\n                        var params = {\n                            name: editable.options.name || '',\n                            value: editable.input.value2submit(editable.value),\n                            pk: (typeof editable.options.pk === 'function') ? \n                                editable.options.pk.call(editable.options.scope) : \n                                editable.options.pk \n                        };\n\n                        //additional params\n                        if(typeof editable.options.params === 'function') {\n                            params = editable.options.params.call(editable.options.scope, params);  \n                        } else {\n                            //try parse json in single quotes (from data-params attribute)\n                            editable.options.params = $.fn.editableutils.tryParseJson(editable.options.params, true);   \n                            $.extend(params, editable.options.params);\n                        }\n\n                        ajaxOptions = {\n                            url: editable.options.url,\n                            data: params,\n                            type: 'POST'  \n                        };\n                        \n                        // use success / error from options \n                        config.success = config.success || editable.options.success;\n                        config.error = config.error || editable.options.error;\n                        \n                    // multiple elements\n                    } else {\n                        var values = this.editable('getValue'); \n                        \n                        ajaxOptions = {\n                            url: config.url,\n                            data: values, \n                            type: 'POST'\n                        };                        \n                    }                    \n\n                    // ajax success callabck (response 200 OK)\n                    ajaxOptions.success = typeof config.success === 'function' ? function(response) {\n                            config.success.call($elems, response, config);\n                        } : $.noop;\n                                  \n                    // ajax error callabck\n                    ajaxOptions.error = typeof config.error === 'function' ? function() {\n                             config.error.apply($elems, arguments);\n                        } : $.noop;\n                       \n                    // extend ajaxOptions    \n                    if(config.ajaxOptions) { \n                        $.extend(ajaxOptions, config.ajaxOptions);\n                    }\n                    \n                    // extra data \n                    if(config.data) {\n                        $.extend(ajaxOptions.data, config.data);\n                    }                     \n                    \n                    // perform ajax request\n                    $.ajax(ajaxOptions);\n                } else { //client-side validation error\n                    if(typeof config.error === 'function') {\n                        config.error.call($elems, errors);\n                    }\n                }\n            return this;\n        }\n\n        //return jquery object\n        return this.each(function () {\n            var $this = $(this), \n                data = $this.data(datakey), \n                options = typeof option === 'object' && option;\n\n            //for delegated targets do not store `editable` object for element\n            //it's allows several different selectors.\n            //see: https://github.com/vitalets/x-editable/issues/312    \n            if(options && options.selector) {\n                data = new Editable(this, options);\n                return; \n            }    \n            \n            if (!data) {\n                $this.data(datakey, (data = new Editable(this, options)));\n            }\n\n            if (typeof option === 'string') { //call method \n                data[option].apply(data, Array.prototype.slice.call(args, 1));\n            } \n        });\n    };    \n            \n\n    $.fn.editable.defaults = {\n        /**\n        Type of input. Can be <code>text|textarea|select|date|checklist</code> and more\n\n        @property type \n        @type string\n        @default 'text'\n        **/\n        type: 'text',        \n        /**\n        Sets disabled state of editable\n\n        @property disabled \n        @type boolean\n        @default false\n        **/         \n        disabled: false,\n        /**\n        How to toggle editable. Can be <code>click|dblclick|mouseenter|manual</code>.   \n        When set to <code>manual</code> you should manually call <code>show/hide</code> methods of editable.    \n        **Note**: if you call <code>show</code> or <code>toggle</code> inside **click** handler of some DOM element, \n        you need to apply <code>e.stopPropagation()</code> because containers are being closed on any click on document.\n        \n        @example\n        $('#edit-button').click(function(e) {\n            e.stopPropagation();\n            $('#username').editable('toggle');\n        });\n\n        @property toggle \n        @type string\n        @default 'click'\n        **/          \n        toggle: 'click',\n        /**\n        Text shown when element is empty.\n\n        @property emptytext \n        @type string\n        @default 'Empty'\n        **/         \n        emptytext: 'Empty',\n        /**\n        Allows to automatically set element's text based on it's value. Can be <code>auto|always|never</code>. Useful for select and date.\n        For example, if dropdown list is <code>{1: 'a', 2: 'b'}</code> and element's value set to <code>1</code>, it's html will be automatically set to <code>'a'</code>.  \n        <code>auto</code> - text will be automatically set only if element is empty.  \n        <code>always|never</code> - always(never) try to set element's text.\n\n        @property autotext \n        @type string\n        @default 'auto'\n        **/          \n        autotext: 'auto', \n        /**\n        Initial value of input. If not set, taken from element's text.  \n        Note, that if element's text is empty - text is automatically generated from value and can be customized (see `autotext` option).  \n        For example, to display currency sign:\n        @example\n        <a id=\"price\" data-type=\"text\" data-value=\"100\"></a>\n        <script>\n        $('#price').editable({\n            ...\n            display: function(value) {\n              $(this).text(value + '$');\n            } \n        }) \n        </script>\n                \n        @property value \n        @type mixed\n        @default element's text\n        **/\n        value: null,\n        /**\n        Callback to perform custom displaying of value in element's text.  \n        If `null`, default input's display used.  \n        If `false`, no displaying methods will be called, element's text will never change.  \n        Runs under element's scope.  \n        _**Parameters:**_  \n        \n        * `value` current value to be displayed\n        * `response` server response (if display called after ajax submit), since 1.4.0\n         \n        For _inputs with source_ (select, checklist) parameters are different:  \n          \n        * `value` current value to be displayed\n        * `sourceData` array of items for current input (e.g. dropdown items) \n        * `response` server response (if display called after ajax submit), since 1.4.0\n                  \n        To get currently selected items use `$.fn.editableutils.itemsByValue(value, sourceData)`.\n        \n        @property display \n        @type function|boolean\n        @default null\n        @since 1.2.0\n        @example\n        display: function(value, sourceData) {\n           //display checklist as comma-separated values\n           var html = [],\n               checked = $.fn.editableutils.itemsByValue(value, sourceData);\n               \n           if(checked.length) {\n               $.each(checked, function(i, v) { html.push($.fn.editableutils.escape(v.text)); });\n               $(this).html(html.join(', '));\n           } else {\n               $(this).empty(); \n           }\n        }\n        **/          \n        display: null,\n        /**\n        Css class applied when editable text is empty.\n\n        @property emptyclass \n        @type string\n        @since 1.4.1        \n        @default editable-empty\n        **/        \n        emptyclass: 'editable-empty',\n        /**\n        Css class applied when value was stored but not sent to server (`pk` is empty or `send = 'never'`).  \n        You may set it to `null` if you work with editables locally and submit them together.  \n\n        @property unsavedclass \n        @type string\n        @since 1.4.1        \n        @default editable-unsaved\n        **/        \n        unsavedclass: 'editable-unsaved',\n        /**\n        If selector is provided, editable will be delegated to the specified targets.  \n        Usefull for dynamically generated DOM elements.  \n        **Please note**, that delegated targets can't be initialized with `emptytext` and `autotext` options, \n        as they actually become editable only after first click.  \n        You should manually set class `editable-click` to these elements.  \n        Also, if element originally empty you should add class `editable-empty`, set `data-value=\"\"` and write emptytext into element:\n\n        @property selector \n        @type string\n        @since 1.4.1        \n        @default null\n        @example\n        <div id=\"user\">\n          <!-- empty -->\n          <a href=\"#\" data-name=\"username\" data-type=\"text\" class=\"editable-click editable-empty\" data-value=\"\" title=\"Username\">Empty</a>\n          <!-- non-empty -->\n          <a href=\"#\" data-name=\"group\" data-type=\"select\" data-source=\"/groups\" data-value=\"1\" class=\"editable-click\" title=\"Group\">Operator</a>\n        </div>     \n        \n        <script>\n        $('#user').editable({\n            selector: 'a',\n            url: '/post',\n            pk: 1\n        });\n        </script>\n        **/         \n        selector: null,\n        /**\n        Color used to highlight element after update. Implemented via CSS3 transition, works in modern browsers.\n        \n        @property highlight \n        @type string|boolean\n        @since 1.4.5        \n        @default #FFFF80 \n        **/\n        highlight: '#FFFF80'\n    };\n    \n}(window.jQuery));\n\n/**\nAbstractInput - base class for all editable inputs.\nIt defines interface to be implemented by any input type.\nTo create your own input you can inherit from this class.\n\n@class abstractinput\n**/\n(function ($) {\n    \"use strict\";\n\n    //types\n    $.fn.editabletypes = {};\n\n    var AbstractInput = function () { };\n\n    AbstractInput.prototype = {\n       /**\n        Initializes input\n\n        @method init() \n        **/\n       init: function(type, options, defaults) {\n           this.type = type;\n           this.options = $.extend({}, defaults, options);\n       },\n\n       /*\n       this method called before render to init $tpl that is inserted in DOM\n       */\n       prerender: function() {\n           this.$tpl = $(this.options.tpl); //whole tpl as jquery object    \n           this.$input = this.$tpl;         //control itself, can be changed in render method\n           this.$clear = null;              //clear button\n           this.error = null;               //error message, if input cannot be rendered           \n       },\n       \n       /**\n        Renders input from tpl. Can return jQuery deferred object.\n        Can be overwritten in child objects\n\n        @method render()\n       **/\n       render: function() {\n\n       }, \n\n       /**\n        Sets element's html by value. \n\n        @method value2html(value, element)\n        @param {mixed} value\n        @param {DOMElement} element\n       **/\n       value2html: function(value, element) {\n           $(element)[this.options.escape ? 'text' : 'html']($.trim(value));\n       },\n\n       /**\n        Converts element's html to value\n\n        @method html2value(html)\n        @param {string} html\n        @returns {mixed}\n       **/\n       html2value: function(html) {\n           return $('<div>').html(html).text();\n       },\n\n       /**\n        Converts value to string (for internal compare). For submitting to server used value2submit().\n\n        @method value2str(value) \n        @param {mixed} value\n        @returns {string}\n       **/\n       value2str: function(value) {\n           return value;\n       }, \n\n       /**\n        Converts string received from server into value. Usually from `data-value` attribute.\n\n        @method str2value(str)\n        @param {string} str\n        @returns {mixed}\n       **/\n       str2value: function(str) {\n           return str;\n       }, \n       \n       /**\n        Converts value for submitting to server. Result can be string or object.\n\n        @method value2submit(value) \n        @param {mixed} value\n        @returns {mixed}\n       **/\n       value2submit: function(value) {\n           return value;\n       },\n\n       /**\n        Sets value of input.\n\n        @method value2input(value) \n        @param {mixed} value\n       **/\n       value2input: function(value) {\n           this.$input.val(value);\n       },\n\n       /**\n        Returns value of input. Value can be object (e.g. datepicker)\n\n        @method input2value() \n       **/\n       input2value: function() { \n           return this.$input.val();\n       }, \n\n       /**\n        Activates input. For text it sets focus.\n\n        @method activate() \n       **/\n       activate: function() {\n           if(this.$input.is(':visible')) {\n               this.$input.focus();\n           }\n       },\n\n       /**\n        Creates input.\n\n        @method clear() \n       **/        \n       clear: function() {\n           this.$input.val(null);\n       },\n\n       /**\n        method to escape html.\n       **/\n       escape: function(str) {\n           return $('<div>').text(str).html();\n       },\n       \n       /**\n        attach handler to automatically submit form when value changed (useful when buttons not shown)\n       **/\n       autosubmit: function() {\n        \n       },\n       \n       /**\n       Additional actions when destroying element \n       **/\n       destroy: function() {\n       },\n\n       // -------- helper functions --------\n       setClass: function() {          \n           if(this.options.inputclass) {\n               this.$input.addClass(this.options.inputclass); \n           } \n       },\n\n       setAttr: function(attr) {\n           if (this.options[attr] !== undefined && this.options[attr] !== null) {\n               this.$input.attr(attr, this.options[attr]);\n           } \n       },\n       \n       option: function(key, value) {\n            this.options[key] = value;\n       }\n       \n    };\n        \n    AbstractInput.defaults = {  \n        /**\n        HTML template of input. Normally you should not change it.\n\n        @property tpl \n        @type string\n        @default ''\n        **/   \n        tpl: '',\n        /**\n        CSS class automatically applied to input\n        \n        @property inputclass \n        @type string\n        @default null\n        **/         \n        inputclass: null,\n        \n        /**\n        If `true` - html will be escaped in content of element via $.text() method.  \n        If `false` - html will not be escaped, $.html() used.  \n        When you use own `display` function, this option obviosly has no effect.\n        \n        @property escape \n        @type boolean\n        @since 1.5.0\n        @default true\n        **/         \n        escape: true,\n                \n        //scope for external methods (e.g. source defined as function)\n        //for internal use only\n        scope: null,\n        \n        //need to re-declare showbuttons here to get it's value from common config (passed only options existing in defaults)\n        showbuttons: true \n    };\n    \n    $.extend($.fn.editabletypes, {abstractinput: AbstractInput});\n        \n}(window.jQuery));\n\n/**\nList - abstract class for inputs that have source option loaded from js array or via ajax\n\n@class list\n@extends abstractinput\n**/\n(function ($) {\n    \"use strict\";\n    \n    var List = function (options) {\n       \n    };\n\n    $.fn.editableutils.inherit(List, $.fn.editabletypes.abstractinput);\n\n    $.extend(List.prototype, {\n        render: function () {\n            var deferred = $.Deferred();\n\n            this.error = null;\n            this.onSourceReady(function () {\n                this.renderList();\n                deferred.resolve();\n            }, function () {\n                this.error = this.options.sourceError;\n                deferred.resolve();\n            });\n\n            return deferred.promise();\n        },\n\n        html2value: function (html) {\n            return null; //can't set value by text\n        },\n        \n        value2html: function (value, element, display, response) {\n            var deferred = $.Deferred(),\n                success = function () {\n                    if(typeof display === 'function') {\n                        //custom display method\n                        display.call(element, value, this.sourceData, response); \n                    } else {\n                        this.value2htmlFinal(value, element);\n                    }\n                    deferred.resolve();\n               };\n            \n            //for null value just call success without loading source\n            if(value === null) {\n               success.call(this);   \n            } else {\n               this.onSourceReady(success, function () { deferred.resolve(); });\n            }\n\n            return deferred.promise();\n        },  \n\n        // ------------- additional functions ------------\n\n        onSourceReady: function (success, error) {\n            //run source if it function\n            var source;\n            if ($.isFunction(this.options.source)) {\n                source = this.options.source.call(this.options.scope);\n                this.sourceData = null;\n                //note: if function returns the same source as URL - sourceData will be taken from cahce and no extra request performed\n            } else {\n                source = this.options.source;\n            }            \n            \n            //if allready loaded just call success\n            if(this.options.sourceCache && $.isArray(this.sourceData)) {\n                success.call(this);\n                return; \n            }\n\n            //try parse json in single quotes (for double quotes jquery does automatically)\n            try {\n                source = $.fn.editableutils.tryParseJson(source, false);\n            } catch (e) {\n                error.call(this);\n                return;\n            }\n\n            //loading from url\n            if (typeof source === 'string') {\n                //try to get sourceData from cache\n                if(this.options.sourceCache) {\n                    var cacheID = source,\n                    cache;\n\n                    if (!$(document).data(cacheID)) {\n                        $(document).data(cacheID, {});\n                    }\n                    cache = $(document).data(cacheID);\n\n                    //check for cached data\n                    if (cache.loading === false && cache.sourceData) { //take source from cache\n                        this.sourceData = cache.sourceData;\n                        this.doPrepend();\n                        success.call(this);\n                        return;\n                    } else if (cache.loading === true) { //cache is loading, put callback in stack to be called later\n                        cache.callbacks.push($.proxy(function () {\n                            this.sourceData = cache.sourceData;\n                            this.doPrepend();\n                            success.call(this);\n                        }, this));\n\n                        //also collecting error callbacks\n                        cache.err_callbacks.push($.proxy(error, this));\n                        return;\n                    } else { //no cache yet, activate it\n                        cache.loading = true;\n                        cache.callbacks = [];\n                        cache.err_callbacks = [];\n                    }\n                }\n                \n                //ajaxOptions for source. Can be overwritten bt options.sourceOptions\n                var ajaxOptions = $.extend({\n                    url: source,\n                    type: 'get',\n                    cache: false,\n                    dataType: 'json',\n                    success: $.proxy(function (data) {\n                        if(cache) {\n                            cache.loading = false;\n                        }\n                        this.sourceData = this.makeArray(data);\n                        if($.isArray(this.sourceData)) {\n                            if(cache) {\n                                //store result in cache\n                                cache.sourceData = this.sourceData;\n                                //run success callbacks for other fields waiting for this source\n                                $.each(cache.callbacks, function () { this.call(); }); \n                            }\n                            this.doPrepend();\n                            success.call(this);\n                        } else {\n                            error.call(this);\n                            if(cache) {\n                                //run error callbacks for other fields waiting for this source\n                                $.each(cache.err_callbacks, function () { this.call(); }); \n                            }\n                        }\n                    }, this),\n                    error: $.proxy(function () {\n                        error.call(this);\n                        if(cache) {\n                             cache.loading = false;\n                             //run error callbacks for other fields\n                             $.each(cache.err_callbacks, function () { this.call(); }); \n                        }\n                    }, this)\n                }, this.options.sourceOptions);\n                \n                //loading sourceData from server\n                $.ajax(ajaxOptions);\n                \n            } else { //options as json/array\n                this.sourceData = this.makeArray(source);\n                    \n                if($.isArray(this.sourceData)) {\n                    this.doPrepend();\n                    success.call(this);   \n                } else {\n                    error.call(this);\n                }\n            }\n        },\n\n        doPrepend: function () {\n            if(this.options.prepend === null || this.options.prepend === undefined) {\n                return;  \n            }\n            \n            if(!$.isArray(this.prependData)) {\n                //run prepend if it is function (once)\n                if ($.isFunction(this.options.prepend)) {\n                    this.options.prepend = this.options.prepend.call(this.options.scope);\n                }\n              \n                //try parse json in single quotes\n                this.options.prepend = $.fn.editableutils.tryParseJson(this.options.prepend, true);\n                \n                //convert prepend from string to object\n                if (typeof this.options.prepend === 'string') {\n                    this.options.prepend = {'': this.options.prepend};\n                }\n                \n                this.prependData = this.makeArray(this.options.prepend);\n            }\n\n            if($.isArray(this.prependData) && $.isArray(this.sourceData)) {\n                this.sourceData = this.prependData.concat(this.sourceData);\n            }\n        },\n\n        /*\n         renders input list\n        */\n        renderList: function() {\n            // this method should be overwritten in child class\n        },\n       \n         /*\n         set element's html by value\n        */\n        value2htmlFinal: function(value, element) {\n            // this method should be overwritten in child class\n        },        \n\n        /**\n        * convert data to array suitable for sourceData, e.g. [{value: 1, text: 'abc'}, {...}]\n        */\n        makeArray: function(data) {\n            var count, obj, result = [], item, iterateItem;\n            if(!data || typeof data === 'string') {\n                return null; \n            }\n\n            if($.isArray(data)) { //array\n                /* \n                   function to iterate inside item of array if item is object.\n                   Caclulates count of keys in item and store in obj. \n                */\n                iterateItem = function (k, v) {\n                    obj = {value: k, text: v};\n                    if(count++ >= 2) {\n                        return false;// exit from `each` if item has more than one key.\n                    }\n                };\n            \n                for(var i = 0; i < data.length; i++) {\n                    item = data[i]; \n                    if(typeof item === 'object') {\n                        count = 0; //count of keys inside item\n                        $.each(item, iterateItem);\n                        //case: [{val1: 'text1'}, {val2: 'text2} ...]\n                        if(count === 1) { \n                            result.push(obj); \n                            //case: [{value: 1, text: 'text1'}, {value: 2, text: 'text2'}, ...]\n                        } else if(count > 1) {\n                            //removed check of existance: item.hasOwnProperty('value') && item.hasOwnProperty('text')\n                            if(item.children) {\n                                item.children = this.makeArray(item.children);   \n                            }\n                            result.push(item);\n                        }\n                    } else {\n                        //case: ['text1', 'text2' ...]\n                        result.push({value: item, text: item}); \n                    }\n                }\n            } else {  //case: {val1: 'text1', val2: 'text2, ...}\n                $.each(data, function (k, v) {\n                    result.push({value: k, text: v});\n                });  \n            }\n            return result;\n        },\n        \n        option: function(key, value) {\n            this.options[key] = value;\n            if(key === 'source') {\n                this.sourceData = null;\n            }\n            if(key === 'prepend') {\n                this.prependData = null;\n            }            \n        }        \n\n    });      \n\n    List.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        Source data for list.  \n        If **array** - it should be in format: `[{value: 1, text: \"text1\"}, {value: 2, text: \"text2\"}, ...]`  \n        For compability, object format is also supported: `{\"1\": \"text1\", \"2\": \"text2\" ...}` but it does not guarantee elements order.\n        \n        If **string** - considered ajax url to load items. In that case results will be cached for fields with the same source and name. See also `sourceCache` option.\n          \n        If **function**, it should return data in format above (since 1.4.0).\n        \n        Since 1.4.1 key `children` supported to render OPTGROUP (for **select** input only).  \n        `[{text: \"group1\", children: [{value: 1, text: \"text1\"}, {value: 2, text: \"text2\"}]}, ...]` \n\n\t\t\n        @property source \n        @type string | array | object | function\n        @default null\n        **/         \n        source: null, \n        /**\n        Data automatically prepended to the beginning of dropdown list.\n        \n        @property prepend \n        @type string | array | object | function\n        @default false\n        **/         \n        prepend: false,\n        /**\n        Error message when list cannot be loaded (e.g. ajax error)\n        \n        @property sourceError \n        @type string\n        @default Error when loading list\n        **/          \n        sourceError: 'Error when loading list',\n        /**\n        if <code>true</code> and source is **string url** - results will be cached for fields with the same source.    \n        Usefull for editable column in grid to prevent extra requests.\n        \n        @property sourceCache \n        @type boolean\n        @default true\n        @since 1.2.0\n        **/        \n        sourceCache: true,\n        /**\n        Additional ajax options to be used in $.ajax() when loading list from server.\n        Useful to send extra parameters (`data` key) or change request method (`type` key).\n        \n        @property sourceOptions \n        @type object|function\n        @default null\n        @since 1.5.0\n        **/        \n        sourceOptions: null\n    });\n\n    $.fn.editabletypes.list = List;      \n\n}(window.jQuery));\n\n/**\nText input\n\n@class text\n@extends abstractinput\n@final\n@example\n<a href=\"#\" id=\"username\" data-type=\"text\" data-pk=\"1\">awesome</a>\n<script>\n$(function(){\n    $('#username').editable({\n        url: '/post',\n        title: 'Enter username'\n    });\n});\n</script>\n**/\n(function ($) {\n    \"use strict\";\n    \n    var Text = function (options) {\n        this.init('text', options, Text.defaults);\n    };\n\n    $.fn.editableutils.inherit(Text, $.fn.editabletypes.abstractinput);\n\n    $.extend(Text.prototype, {\n        render: function() {\n           this.renderClear();\n           this.setClass();\n           this.setAttr('placeholder');\n        },\n        \n        activate: function() {\n            if(this.$input.is(':visible')) {\n                this.$input.focus();\n                $.fn.editableutils.setCursorPosition(this.$input.get(0), this.$input.val().length);\n                if(this.toggleClear) {\n                    this.toggleClear();\n                }\n            }\n        },\n        \n        //render clear button\n        renderClear:  function() {\n           if (this.options.clear) {\n               this.$clear = $('<span class=\"editable-clear-x\"></span>');\n               this.$input.after(this.$clear)\n                          .css('padding-right', 24)\n                          .keyup($.proxy(function(e) {\n                              //arrows, enter, tab, etc\n                              if(~$.inArray(e.keyCode, [40,38,9,13,27])) {\n                                return;\n                              }                            \n\n                              clearTimeout(this.t);\n                              var that = this;\n                              this.t = setTimeout(function() {\n                                that.toggleClear(e);\n                              }, 100);\n                              \n                          }, this))\n                          .parent().css('position', 'relative');\n                          \n               this.$clear.click($.proxy(this.clear, this));                       \n           }            \n        },\n        \n        postrender: function() {\n            /*\n            //now `clear` is positioned via css\n            if(this.$clear) {\n                //can position clear button only here, when form is shown and height can be calculated\n//                var h = this.$input.outerHeight(true) || 20,\n                var h = this.$clear.parent().height(),\n                    delta = (h - this.$clear.height()) / 2;\n                    \n                //this.$clear.css({bottom: delta, right: delta});\n            }\n            */ \n        },\n        \n        //show / hide clear button\n        toggleClear: function(e) {\n            if(!this.$clear) {\n                return;\n            }\n            \n            var len = this.$input.val().length,\n                visible = this.$clear.is(':visible');\n                 \n            if(len && !visible) {\n                this.$clear.show();\n            } \n            \n            if(!len && visible) {\n                this.$clear.hide();\n            } \n        },\n        \n        clear: function() {\n           this.$clear.hide();\n           this.$input.val('').focus();\n        }          \n    });\n\n    Text.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <input type=\"text\">\n        **/         \n        tpl: '<input type=\"text\">',\n        /**\n        Placeholder attribute of input. Shown when input is empty.\n\n        @property placeholder \n        @type string\n        @default null\n        **/             \n        placeholder: null,\n        \n        /**\n        Whether to show `clear` button \n        \n        @property clear \n        @type boolean\n        @default true        \n        **/\n        clear: true\n    });\n\n    $.fn.editabletypes.text = Text;\n\n}(window.jQuery));\n\n/**\nTextarea input\n\n@class textarea\n@extends abstractinput\n@final\n@example\n<a href=\"#\" id=\"comments\" data-type=\"textarea\" data-pk=\"1\">awesome comment!</a>\n<script>\n$(function(){\n    $('#comments').editable({\n        url: '/post',\n        title: 'Enter comments',\n        rows: 10\n    });\n});\n</script>\n**/\n(function ($) {\n    \"use strict\";\n    \n    var Textarea = function (options) {\n        this.init('textarea', options, Textarea.defaults);\n    };\n\n    $.fn.editableutils.inherit(Textarea, $.fn.editabletypes.abstractinput);\n\n    $.extend(Textarea.prototype, {\n        render: function () {\n            this.setClass();\n            this.setAttr('placeholder');\n            this.setAttr('rows');                        \n            \n            //ctrl + enter\n            this.$input.keydown(function (e) {\n                if (e.ctrlKey && e.which === 13) {\n                    $(this).closest('form').submit();\n                }\n            });\n        },\n        \n       //using `white-space: pre-wrap` solves \\n  <--> BR conversion very elegant!\n       /* \n       value2html: function(value, element) {\n            var html = '', lines;\n            if(value) {\n                lines = value.split(\"\\n\");\n                for (var i = 0; i < lines.length; i++) {\n                    lines[i] = $('<div>').text(lines[i]).html();\n                }\n                html = lines.join('<br>');\n            }\n            $(element).html(html);\n        },\n       \n        html2value: function(html) {\n            if(!html) {\n                return '';\n            }\n\n            var regex = new RegExp(String.fromCharCode(10), 'g');\n            var lines = html.split(/<br\\s*\\/?>/i);\n            for (var i = 0; i < lines.length; i++) {\n                var text = $('<div>').html(lines[i]).text();\n\n                // Remove newline characters (\\n) to avoid them being converted by value2html() method\n                // thus adding extra <br> tags\n                text = text.replace(regex, '');\n\n                lines[i] = text;\n            }\n            return lines.join(\"\\n\");\n        },\n         */\n        activate: function() {\n            $.fn.editabletypes.text.prototype.activate.call(this);\n        }\n    });\n\n    Textarea.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl\n        @default <textarea></textarea>\n        **/\n        tpl:'<textarea></textarea>',\n        /**\n        @property inputclass\n        @default input-large\n        **/\n        inputclass: 'input-large',\n        /**\n        Placeholder attribute of input. Shown when input is empty.\n\n        @property placeholder\n        @type string\n        @default null\n        **/\n        placeholder: null,\n        /**\n        Number of rows in textarea\n\n        @property rows\n        @type integer\n        @default 7\n        **/        \n        rows: 7        \n    });\n\n    $.fn.editabletypes.textarea = Textarea;\n\n}(window.jQuery));\n\n/**\nSelect (dropdown)\n\n@class select\n@extends list\n@final\n@example\n<a href=\"#\" id=\"status\" data-type=\"select\" data-pk=\"1\" data-url=\"/post\" data-title=\"Select status\"></a>\n<script>\n$(function(){\n    $('#status').editable({\n        value: 2,    \n        source: [\n              {value: 1, text: 'Active'},\n              {value: 2, text: 'Blocked'},\n              {value: 3, text: 'Deleted'}\n           ]\n    });\n});\n</script>\n**/\n(function ($) {\n    \"use strict\";\n    \n    var Select = function (options) {\n        this.init('select', options, Select.defaults);\n    };\n\n    $.fn.editableutils.inherit(Select, $.fn.editabletypes.list);\n\n    $.extend(Select.prototype, {\n        renderList: function() {\n            this.$input.empty();\n\n            var fillItems = function($el, data) {\n                var attr;\n                if($.isArray(data)) {\n                    for(var i=0; i<data.length; i++) {\n                        attr = {};\n                        if(data[i].children) {\n                            attr.label = data[i].text;\n                            $el.append(fillItems($('<optgroup>', attr), data[i].children)); \n                        } else {\n                            attr.value = data[i].value;\n                            if(data[i].disabled) {\n                                attr.disabled = true;\n                            }\n                            $el.append($('<option>', attr).text(data[i].text)); \n                        }\n                    }\n                }\n                return $el;\n            };        \n\n            fillItems(this.$input, this.sourceData);\n            \n            this.setClass();\n            \n            //enter submit\n            this.$input.on('keydown.editable', function (e) {\n                if (e.which === 13) {\n                    $(this).closest('form').submit();\n                }\n            });            \n        },\n       \n        value2htmlFinal: function(value, element) {\n            var text = '', \n                items = $.fn.editableutils.itemsByValue(value, this.sourceData);\n                \n            if(items.length) {\n                text = items[0].text;\n            }\n            \n            //$(element).text(text);\n            $.fn.editabletypes.abstractinput.prototype.value2html.call(this, text, element);\n        },\n        \n        autosubmit: function() {\n            this.$input.off('keydown.editable').on('change.editable', function(){\n                $(this).closest('form').submit();\n            });\n        }\n    });      \n\n    Select.defaults = $.extend({}, $.fn.editabletypes.list.defaults, {\n        /**\n        @property tpl \n        @default <select></select>\n        **/         \n        tpl:'<select></select>'\n    });\n\n    $.fn.editabletypes.select = Select;      \n\n}(window.jQuery));\n\n/**\nList of checkboxes. \nInternally value stored as javascript array of values.\n\n@class checklist\n@extends list\n@final\n@example\n<a href=\"#\" id=\"options\" data-type=\"checklist\" data-pk=\"1\" data-url=\"/post\" data-title=\"Select options\"></a>\n<script>\n$(function(){\n    $('#options').editable({\n        value: [2, 3],    \n        source: [\n              {value: 1, text: 'option1'},\n              {value: 2, text: 'option2'},\n              {value: 3, text: 'option3'}\n           ]\n    });\n});\n</script>\n**/\n(function ($) {\n    \"use strict\";\n    \n    var Checklist = function (options) {\n        this.init('checklist', options, Checklist.defaults);\n    };\n\n    $.fn.editableutils.inherit(Checklist, $.fn.editabletypes.list);\n\n    $.extend(Checklist.prototype, {\n        renderList: function() {\n            var $label, $div;\n            \n            this.$tpl.empty();\n            \n            if(!$.isArray(this.sourceData)) {\n                return;\n            }\n\n            for(var i=0; i<this.sourceData.length; i++) {\n                $label = $('<label>').append($('<input>', {\n                                           type: 'checkbox',\n                                           value: this.sourceData[i].value \n                                     }))\n                                     .append($('<span>').text(' '+this.sourceData[i].text));\n                \n                $('<div>').append($label).appendTo(this.$tpl);\n            }\n            \n            this.$input = this.$tpl.find('input[type=\"checkbox\"]');\n            this.setClass();\n        },\n       \n       value2str: function(value) {\n           return $.isArray(value) ? value.sort().join($.trim(this.options.separator)) : '';\n       },  \n       \n       //parse separated string\n        str2value: function(str) {\n           var reg, value = null;\n           if(typeof str === 'string' && str.length) {\n               reg = new RegExp('\\\\s*'+$.trim(this.options.separator)+'\\\\s*');\n               value = str.split(reg);\n           } else if($.isArray(str)) {\n               value = str; \n           } else {\n               value = [str];\n           }\n           return value;\n        },       \n       \n       //set checked on required checkboxes\n       value2input: function(value) {\n            this.$input.prop('checked', false);\n            if($.isArray(value) && value.length) {\n               this.$input.each(function(i, el) {\n                   var $el = $(el);\n                   // cannot use $.inArray as it performs strict comparison\n                   $.each(value, function(j, val){\n                       /*jslint eqeq: true*/\n                       if($el.val() == val) {\n                       /*jslint eqeq: false*/                           \n                           $el.prop('checked', true);\n                       }\n                   });\n               }); \n            }  \n        },  \n        \n       input2value: function() { \n           var checked = [];\n           this.$input.filter(':checked').each(function(i, el) {\n               checked.push($(el).val());\n           });\n           return checked;\n       },            \n          \n       //collect text of checked boxes\n        value2htmlFinal: function(value, element) {\n           var html = [],\n               checked = $.fn.editableutils.itemsByValue(value, this.sourceData),\n               escape = this.options.escape;\n               \n           if(checked.length) {\n               $.each(checked, function(i, v) {\n                   var text = escape ? $.fn.editableutils.escape(v.text) : v.text; \n                   html.push(text); \n               });\n               $(element).html(html.join('<br>'));\n           } else {\n               $(element).empty(); \n           }\n        },\n        \n       activate: function() {\n           this.$input.first().focus();\n       },\n       \n       autosubmit: function() {\n           this.$input.on('keydown', function(e){\n               if (e.which === 13) {\n                   $(this).closest('form').submit();\n               }\n           });\n       }\n    });      \n\n    Checklist.defaults = $.extend({}, $.fn.editabletypes.list.defaults, {\n        /**\n        @property tpl \n        @default <div></div>\n        **/         \n        tpl:'<div class=\"editable-checklist\"></div>',\n        \n        /**\n        @property inputclass \n        @type string\n        @default null\n        **/         \n        inputclass: null,        \n        \n        /**\n        Separator of values when reading from `data-value` attribute\n\n        @property separator \n        @type string\n        @default ','\n        **/         \n        separator: ','\n    });\n\n    $.fn.editabletypes.checklist = Checklist;      \n\n}(window.jQuery));\n\n/**\nHTML5 input types.\nFollowing types are supported:\n\n* password\n* email\n* url\n* tel\n* number\n* range\n* time\n\nLearn more about html5 inputs:  \nhttp://www.w3.org/wiki/HTML5_form_additions  \nTo check browser compatibility please see:  \nhttps://developer.mozilla.org/en-US/docs/HTML/Element/Input\n            \n@class html5types \n@extends text\n@final\n@since 1.3.0\n@example\n<a href=\"#\" id=\"email\" data-type=\"email\" data-pk=\"1\">admin@example.com</a>\n<script>\n$(function(){\n    $('#email').editable({\n        url: '/post',\n        title: 'Enter email'\n    });\n});\n</script>\n**/\n\n/**\n@property tpl \n@default depends on type\n**/ \n\n/*\nPassword\n*/\n(function ($) {\n    \"use strict\";\n    \n    var Password = function (options) {\n        this.init('password', options, Password.defaults);\n    };\n    $.fn.editableutils.inherit(Password, $.fn.editabletypes.text);\n    $.extend(Password.prototype, {\n       //do not display password, show '[hidden]' instead\n       value2html: function(value, element) {\n           if(value) {\n               $(element).text('[hidden]');\n           } else {\n               $(element).empty(); \n           }\n       },\n       //as password not displayed, should not set value by html\n       html2value: function(html) {\n           return null;\n       }       \n    });    \n    Password.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"password\">'\n    });\n    $.fn.editabletypes.password = Password;\n}(window.jQuery));\n\n\n/*\nEmail\n*/\n(function ($) {\n    \"use strict\";\n    \n    var Email = function (options) {\n        this.init('email', options, Email.defaults);\n    };\n    $.fn.editableutils.inherit(Email, $.fn.editabletypes.text);\n    Email.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"email\">'\n    });\n    $.fn.editabletypes.email = Email;\n}(window.jQuery));\n\n\n/*\nUrl\n*/\n(function ($) {\n    \"use strict\";\n    \n    var Url = function (options) {\n        this.init('url', options, Url.defaults);\n    };\n    $.fn.editableutils.inherit(Url, $.fn.editabletypes.text);\n    Url.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"url\">'\n    });\n    $.fn.editabletypes.url = Url;\n}(window.jQuery));\n\n\n/*\nTel\n*/\n(function ($) {\n    \"use strict\";\n    \n    var Tel = function (options) {\n        this.init('tel', options, Tel.defaults);\n    };\n    $.fn.editableutils.inherit(Tel, $.fn.editabletypes.text);\n    Tel.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"tel\">'\n    });\n    $.fn.editabletypes.tel = Tel;\n}(window.jQuery));\n\n\n/*\nNumber\n*/\n(function ($) {\n    \"use strict\";\n    \n    var NumberInput = function (options) {\n        this.init('number', options, NumberInput.defaults);\n    };\n    $.fn.editableutils.inherit(NumberInput, $.fn.editabletypes.text);\n    $.extend(NumberInput.prototype, {\n         render: function () {\n            NumberInput.superclass.render.call(this);\n            this.setAttr('min');\n            this.setAttr('max');\n            this.setAttr('step');\n        },\n        postrender: function() {\n            if(this.$clear) {\n                //increase right ffset  for up/down arrows\n                this.$clear.css({right: 24});\n                /*\n                //can position clear button only here, when form is shown and height can be calculated\n                var h = this.$input.outerHeight(true) || 20,\n                    delta = (h - this.$clear.height()) / 2;\n                \n                //add 12px to offset right for up/down arrows    \n                this.$clear.css({top: delta, right: delta + 16});\n                */\n            } \n        }        \n    });     \n    NumberInput.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"number\">',\n        inputclass: 'input-mini',\n        min: null,\n        max: null,\n        step: null\n    });\n    $.fn.editabletypes.number = NumberInput;\n}(window.jQuery));\n\n\n/*\nRange (inherit from number)\n*/\n(function ($) {\n    \"use strict\";\n    \n    var Range = function (options) {\n        this.init('range', options, Range.defaults);\n    };\n    $.fn.editableutils.inherit(Range, $.fn.editabletypes.number);\n    $.extend(Range.prototype, {\n        render: function () {\n            this.$input = this.$tpl.filter('input');\n            \n            this.setClass();\n            this.setAttr('min');\n            this.setAttr('max');\n            this.setAttr('step');           \n            \n            this.$input.on('input', function(){\n                $(this).siblings('output').text($(this).val()); \n            });  \n        },\n        activate: function() {\n            this.$input.focus();\n        }         \n    });\n    Range.defaults = $.extend({}, $.fn.editabletypes.number.defaults, {\n        tpl: '<input type=\"range\"><output style=\"width: 30px; display: inline-block\"></output>',\n        inputclass: 'input-medium'\n    });\n    $.fn.editabletypes.range = Range;\n}(window.jQuery));\n\n/*\nTime\n*/\n(function ($) {\n    \"use strict\";\n\n    var Time = function (options) {\n        this.init('time', options, Time.defaults);\n    };\n    //inherit from abstract, as inheritance from text gives selection error.\n    $.fn.editableutils.inherit(Time, $.fn.editabletypes.abstractinput);\n    $.extend(Time.prototype, {\n        render: function() {\n           this.setClass();\n        }        \n    });\n    Time.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        tpl: '<input type=\"time\">'\n    });\n    $.fn.editabletypes.time = Time;\n}(window.jQuery));\n\n/**\nSelect2 input. Based on amazing work of Igor Vaynberg https://github.com/ivaynberg/select2.  \nPlease see [original select2 docs](http://ivaynberg.github.com/select2) for detailed description and options.  \n \nYou should manually download and include select2 distributive:  \n\n    <link href=\"select2/select2.css\" rel=\"stylesheet\" type=\"text/css\"></link>  \n    <script src=\"select2/select2.js\"></script>  \n    \nTo make it **bootstrap-styled** you can use css from [here](https://github.com/t0m/select2-bootstrap-css): \n\n    <link href=\"select2-bootstrap.css\" rel=\"stylesheet\" type=\"text/css\"></link>    \n    \n**Note:** currently `autotext` feature does not work for select2 with `ajax` remote source.    \nYou need initially put both `data-value` and element's text youself:    \n\n    <a href=\"#\" data-type=\"select2\" data-value=\"1\">Text1</a>\n    \n    \n@class select2\n@extends abstractinput\n@since 1.4.1\n@final\n@example\n<a href=\"#\" id=\"country\" data-type=\"select2\" data-pk=\"1\" data-value=\"ru\" data-url=\"/post\" data-title=\"Select country\"></a>\n<script>\n$(function(){\n    //local source\n    $('#country').editable({\n        source: [\n              {id: 'gb', text: 'Great Britain'},\n              {id: 'us', text: 'United States'},\n              {id: 'ru', text: 'Russia'}\n           ],\n        select2: {\n           multiple: true\n        }\n    });\n    //remote source (simple)\n    $('#country').editable({\n        source: '/getCountries',\n        select2: {\n            placeholder: 'Select Country',\n            minimumInputLength: 1\n        }\n    });\n    //remote source (advanced)\n    $('#country').editable({\n        select2: {\n            placeholder: 'Select Country',\n            allowClear: true,\n            minimumInputLength: 3,\n            id: function (item) {\n                return item.CountryId;\n            },\n            ajax: {\n                url: '/getCountries',\n                dataType: 'json',\n                data: function (term, page) {\n                    return { query: term };\n                },\n                results: function (data, page) {\n                    return { results: data };\n                }\n            },\n            formatResult: function (item) {\n                return item.CountryName;\n            },\n            formatSelection: function (item) {\n                return item.CountryName;\n            },\n            initSelection: function (element, callback) {\n                return $.get('/getCountryById', { query: element.val() }, function (data) {\n                    callback(data);\n                });\n            } \n        }  \n    });\n});\n</script>\n**/\n(function ($) {\n    \"use strict\";\n    \n    var Constructor = function (options) {\n        this.init('select2', options, Constructor.defaults);\n\n        options.select2 = options.select2 || {};\n\n        this.sourceData = null;\n        \n        //placeholder\n        if(options.placeholder) {\n            options.select2.placeholder = options.placeholder;\n        }\n       \n        //if not `tags` mode, use source\n        if(!options.select2.tags && options.source) {\n            var source = options.source;\n            //if source is function, call it (once!)\n            if ($.isFunction(options.source)) {\n                source = options.source.call(options.scope);\n            }               \n\n            if (typeof source === 'string') {\n                options.select2.ajax = options.select2.ajax || {};\n                //some default ajax params\n                if(!options.select2.ajax.data) {\n                    options.select2.ajax.data = function(term) {return { query:term };};\n                }\n                if(!options.select2.ajax.results) {\n                    options.select2.ajax.results = function(data) { return {results:data };};\n                }\n                options.select2.ajax.url = source;\n            } else {\n                //check format and convert x-editable format to select2 format (if needed)\n                this.sourceData = this.convertSource(source);\n                options.select2.data = this.sourceData;\n            }\n        } \n\n        //overriding objects in config (as by default jQuery extend() is not recursive)\n        this.options.select2 = $.extend({}, Constructor.defaults.select2, options.select2);\n\n        //detect whether it is multi-valued\n        this.isMultiple = this.options.select2.tags || this.options.select2.multiple;\n        this.isRemote = ('ajax' in this.options.select2);\n\n        //store function returning ID of item\n        //should be here as used inautotext for local source\n        this.idFunc = this.options.select2.id;\n        if (typeof(this.idFunc) !== \"function\") {\n            var idKey = this.idFunc || 'id';\n            this.idFunc = function (e) { return e[idKey]; };\n        }\n\n        //store function that renders text in select2\n        this.formatSelection = this.options.select2.formatSelection;\n        if (typeof(this.formatSelection) !== \"function\") {\n            this.formatSelection = function (e) { return e.text; };\n        }\n    };\n\n    $.fn.editableutils.inherit(Constructor, $.fn.editabletypes.abstractinput);\n\n    $.extend(Constructor.prototype, {\n        render: function() {\n            this.setClass();\n\n            //can not apply select2 here as it calls initSelection \n            //over input that does not have correct value yet.\n            //apply select2 only in value2input\n            //this.$input.select2(this.options.select2);\n\n            //when data is loaded via ajax, we need to know when it's done to populate listData\n            if(this.isRemote) {\n                //listen to loaded event to populate data\n                this.$input.on('select2-loaded', $.proxy(function(e) {\n                    this.sourceData = e.items.results;\n                }, this));\n            }\n\n            //trigger resize of editableform to re-position container in multi-valued mode\n            if(this.isMultiple) {\n               this.$input.on('change', function() {\n                   $(this).closest('form').parent().triggerHandler('resize');\n               });\n            }\n       },\n\n       value2html: function(value, element) {\n           var text = '', data,\n               that = this;\n\n           if(this.options.select2.tags) { //in tags mode just assign value\n              data = value; \n              //data = $.fn.editableutils.itemsByValue(value, this.options.select2.tags, this.idFunc);\n           } else if(this.sourceData) {\n              data = $.fn.editableutils.itemsByValue(value, this.sourceData, this.idFunc); \n           } else {\n              //can not get list of possible values \n              //(e.g. autotext for select2 with ajax source)\n           }\n\n           //data may be array (when multiple values allowed)\n           if($.isArray(data)) {\n               //collect selected data and show with separator\n               text = [];\n               $.each(data, function(k, v){\n                   text.push(v && typeof v === 'object' ? that.formatSelection(v) : v);\n               });\n           } else if(data) {\n               text = that.formatSelection(data);\n           }\n\n           text = $.isArray(text) ? text.join(this.options.viewseparator) : text;\n\n           //$(element).text(text);\n           Constructor.superclass.value2html.call(this, text, element); \n       },\n\n       html2value: function(html) {\n           return this.options.select2.tags ? this.str2value(html, this.options.viewseparator) : null;\n       },\n\n       value2input: function(value) {\n           // if value array => join it anyway\n           if($.isArray(value)) {\n              value = value.join(this.getSeparator());\n           }\n\n           //for remote source just set value, text is updated by initSelection\n           if(!this.$input.data('select2')) {\n               this.$input.val(value);\n               this.$input.select2(this.options.select2);\n           } else {\n               //second argument needed to separate initial change from user's click (for autosubmit)   \n               this.$input.val(value).trigger('change', true); \n\n               //Uncaught Error: cannot call val() if initSelection() is not defined\n               //this.$input.select2('val', value);\n           }\n\n           // if defined remote source AND no multiple mode AND no user's initSelection provided --> \n           // we should somehow get text for provided id.\n           // The solution is to use element's text as text for that id (exclude empty)\n           if(this.isRemote && !this.isMultiple && !this.options.select2.initSelection) {\n               // customId and customText are methods to extract `id` and `text` from data object\n               // we can use this workaround only if user did not define these methods\n               // otherwise we cant construct data object\n               var customId = this.options.select2.id,\n                   customText = this.options.select2.formatSelection;\n\n               if(!customId && !customText) {\n                   var $el = $(this.options.scope);\n                   if (!$el.data('editable').isEmpty) {\n                       var data = {id: value, text: $el.text()};\n                       this.$input.select2('data', data); \n                   }\n               }\n           }\n       },\n       \n       input2value: function() { \n           return this.$input.select2('val');\n       },\n\n       str2value: function(str, separator) {\n            if(typeof str !== 'string' || !this.isMultiple) {\n                return str;\n            }\n\n            separator = separator || this.getSeparator();\n\n            var val, i, l;\n\n            if (str === null || str.length < 1) {\n                return null;\n            }\n            val = str.split(separator);\n            for (i = 0, l = val.length; i < l; i = i + 1) {\n                val[i] = $.trim(val[i]);\n            }\n\n            return val;\n       },\n\n        autosubmit: function() {\n            this.$input.on('change', function(e, isInitial){\n                if(!isInitial) {\n                  $(this).closest('form').submit();\n                }\n            });\n        },\n\n        getSeparator: function() {\n            return this.options.select2.separator || $.fn.select2.defaults.separator;\n        },\n\n        /*\n        Converts source from x-editable format: {value: 1, text: \"1\"} to\n        select2 format: {id: 1, text: \"1\"}\n        */\n        convertSource: function(source) {\n            if($.isArray(source) && source.length && source[0].value !== undefined) {\n                for(var i = 0; i<source.length; i++) {\n                    if(source[i].value !== undefined) {\n                        source[i].id = source[i].value;\n                        delete source[i].value;\n                    }\n                }\n            }\n            return source;\n        },\n        \n        destroy: function() {\n            if(this.$input.data('select2')) {\n                this.$input.select2('destroy');\n            }\n        }\n        \n    });\n\n    Constructor.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <input type=\"hidden\">\n        **/\n        tpl:'<input type=\"hidden\">',\n        /**\n        Configuration of select2. [Full list of options](http://ivaynberg.github.com/select2).\n\n        @property select2 \n        @type object\n        @default null\n        **/\n        select2: null,\n        /**\n        Placeholder attribute of select\n\n        @property placeholder \n        @type string\n        @default null\n        **/\n        placeholder: null,\n        /**\n        Source data for select. It will be assigned to select2 `data` property and kept here just for convenience.\n        Please note, that format is different from simple `select` input: use 'id' instead of 'value'.\n        E.g. `[{id: 1, text: \"text1\"}, {id: 2, text: \"text2\"}, ...]`.\n\n        @property source \n        @type array|string|function\n        @default null        \n        **/\n        source: null,\n        /**\n        Separator used to display tags.\n\n        @property viewseparator \n        @type string\n        @default ', '        \n        **/\n        viewseparator: ', '\n    });\n\n    $.fn.editabletypes.select2 = Constructor;\n\n}(window.jQuery));\n\n/**\n* Combodate - 1.0.5\n* Dropdown date and time picker.\n* Converts text input into dropdowns to pick day, month, year, hour, minute and second.\n* Uses momentjs as datetime library http://momentjs.com.\n* For i18n include corresponding file from https://github.com/timrwood/moment/tree/master/lang \n*\n* Confusion at noon and midnight - see http://en.wikipedia.org/wiki/12-hour_clock#Confusion_at_noon_and_midnight\n* In combodate: \n* 12:00 pm --> 12:00 (24-h format, midday)\n* 12:00 am --> 00:00 (24-h format, midnight, start of day)\n* \n* Differs from momentjs parse rules:\n* 00:00 pm, 12:00 pm --> 12:00 (24-h format, day not change)\n* 00:00 am, 12:00 am --> 00:00 (24-h format, day not change)\n* \n* \n* Author: Vitaliy Potapov\n* Project page: http://github.com/vitalets/combodate\n* Copyright (c) 2012 Vitaliy Potapov. Released under MIT License.\n**/\n(function ($) {\n\n    var Combodate = function (element, options) {\n        this.$element = $(element);\n        if(!this.$element.is('input')) {\n            $.error('Combodate should be applied to INPUT element');\n            return;\n        }\n        this.options = $.extend({}, $.fn.combodate.defaults, options, this.$element.data());\n        this.init();  \n     };\n\n    Combodate.prototype = {\n        constructor: Combodate, \n        init: function () {\n            this.map = {\n                //key   regexp    moment.method\n                day:    ['D',    'date'], \n                month:  ['M',    'month'], \n                year:   ['Y',    'year'], \n                hour:   ['[Hh]', 'hours'],\n                minute: ['m',    'minutes'], \n                second: ['s',    'seconds'],\n                ampm:   ['[Aa]', ''] \n            };\n            \n            this.$widget = $('<span class=\"combodate\"></span>').html(this.getTemplate());\n                      \n            this.initCombos();\n            \n            //update original input on change \n            this.$widget.on('change', 'select', $.proxy(function(e) {\n                this.$element.val(this.getValue()).change();\n                // update days count if month or year changes\n                if (this.options.smartDays) {\n                    if ($(e.target).is('.month') || $(e.target).is('.year')) {\n                        this.fillCombo('day');\n                    }\n                }\n            }, this));\n            \n            this.$widget.find('select').css('width', 'auto');\n                                       \n            // hide original input and insert widget                                       \n            this.$element.hide().after(this.$widget);\n            \n            // set initial value\n            this.setValue(this.$element.val() || this.options.value);\n        },\n        \n        /*\n         Replace tokens in template with <select> elements \n        */         \n        getTemplate: function() {\n            var tpl = this.options.template;\n\n            //first pass\n            $.each(this.map, function(k, v) {\n                v = v[0]; \n                var r = new RegExp(v+'+'),\n                    token = v.length > 1 ? v.substring(1, 2) : v;\n                    \n                tpl = tpl.replace(r, '{'+token+'}');\n            });\n\n            //replace spaces with &nbsp;\n            tpl = tpl.replace(/ /g, '&nbsp;');\n\n            //second pass\n            $.each(this.map, function(k, v) {\n                v = v[0];\n                var token = v.length > 1 ? v.substring(1, 2) : v;\n                    \n                tpl = tpl.replace('{'+token+'}', '<select class=\"'+k+'\"></select>');\n            });   \n\n            return tpl;\n        },\n        \n        /*\n         Initialize combos that presents in template \n        */        \n        initCombos: function() {\n            for (var k in this.map) {\n                var $c = this.$widget.find('.'+k);\n                // set properties like this.$day, this.$month etc.\n                this['$'+k] = $c.length ? $c : null;\n                // fill with items\n                this.fillCombo(k);\n            }\n        },\n\n        /*\n         Fill combo with items \n        */        \n        fillCombo: function(k) {\n            var $combo = this['$'+k];\n            if (!$combo) {\n                return;\n            }\n\n            // define method name to fill items, e.g `fillDays`\n            var f = 'fill' + k.charAt(0).toUpperCase() + k.slice(1); \n            var items = this[f]();\n            var value = $combo.val();\n\n            $combo.empty();\n            for(var i=0; i<items.length; i++) {\n                $combo.append('<option value=\"'+items[i][0]+'\">'+items[i][1]+'</option>');\n            }\n\n            $combo.val(value);\n        },\n\n        /*\n         Initialize items of combos. Handles `firstItem` option \n        */\n        fillCommon: function(key) {\n            var values = [],\n                relTime;\n                \n            if(this.options.firstItem === 'name') {\n                //need both to support moment ver < 2 and  >= 2\n                relTime = moment.relativeTime || moment.langData()._relativeTime; \n                var header = typeof relTime[key] === 'function' ? relTime[key](1, true, key, false) : relTime[key];\n                //take last entry (see momentjs lang files structure) \n                header = header.split(' ').reverse()[0];                \n                values.push(['', header]);\n            } else if(this.options.firstItem === 'empty') {\n                values.push(['', '']);\n            }\n            return values;\n        },  \n\n\n        /*\n        fill day\n        */\n        fillDay: function() {\n            var items = this.fillCommon('d'), name, i,\n                twoDigit = this.options.template.indexOf('DD') !== -1,\n                daysCount = 31;\n\n            // detect days count (depends on month and year)\n            // originally https://github.com/vitalets/combodate/pull/7\n            if (this.options.smartDays && this.$month && this.$year) {\n                var month = parseInt(this.$month.val(), 10);\n                var year = parseInt(this.$year.val(), 10);\n\n                if (!isNaN(month) && !isNaN(year)) {\n                    daysCount = moment([year, month]).daysInMonth();\n                }\n            }\n\n            for (i = 1; i <= daysCount; i++) {\n                name = twoDigit ? this.leadZero(i) : i;\n                items.push([i, name]);\n            }\n            return items;        \n        },\n        \n        /*\n        fill month\n        */\n        fillMonth: function() {\n            var items = this.fillCommon('M'), name, i, \n                longNames = this.options.template.indexOf('MMMM') !== -1,\n                shortNames = this.options.template.indexOf('MMM') !== -1,\n                twoDigit = this.options.template.indexOf('MM') !== -1;\n                \n            for(i=0; i<=11; i++) {\n                if(longNames) {\n                    //see https://github.com/timrwood/momentjs.com/pull/36\n                    name = moment().date(1).month(i).format('MMMM');\n                } else if(shortNames) {\n                    name = moment().date(1).month(i).format('MMM');\n                } else if(twoDigit) {\n                    name = this.leadZero(i+1);\n                } else {\n                    name = i+1;\n                }\n                items.push([i, name]);\n            } \n            return items;\n        },  \n        \n        /*\n        fill year\n        */\n        fillYear: function() {\n            var items = [], name, i, \n                longNames = this.options.template.indexOf('YYYY') !== -1;\n           \n            for(i=this.options.maxYear; i>=this.options.minYear; i--) {\n                name = longNames ? i : (i+'').substring(2);\n                items[this.options.yearDescending ? 'push' : 'unshift']([i, name]);\n            }\n            \n            items = this.fillCommon('y').concat(items);\n            \n            return items;              \n        },    \n        \n        /*\n        fill hour\n        */\n        fillHour: function() {\n            var items = this.fillCommon('h'), name, i,\n                h12 = this.options.template.indexOf('h') !== -1,\n                h24 = this.options.template.indexOf('H') !== -1,\n                twoDigit = this.options.template.toLowerCase().indexOf('hh') !== -1,\n                min = h12 ? 1 : 0, \n                max = h12 ? 12 : 23;\n                \n            for(i=min; i<=max; i++) {\n                name = twoDigit ? this.leadZero(i) : i;\n                items.push([i, name]);\n            } \n            return items;                 \n        },    \n        \n        /*\n        fill minute\n        */\n        fillMinute: function() {\n            var items = this.fillCommon('m'), name, i,\n                twoDigit = this.options.template.indexOf('mm') !== -1;\n\n            for(i=0; i<=59; i+= this.options.minuteStep) {\n                name = twoDigit ? this.leadZero(i) : i;\n                items.push([i, name]);\n            }    \n            return items;              \n        },  \n        \n        /*\n        fill second\n        */\n        fillSecond: function() {\n            var items = this.fillCommon('s'), name, i,\n                twoDigit = this.options.template.indexOf('ss') !== -1;\n\n            for(i=0; i<=59; i+= this.options.secondStep) {\n                name = twoDigit ? this.leadZero(i) : i;\n                items.push([i, name]);\n            }    \n            return items;              \n        },  \n        \n        /*\n        fill ampm\n        */\n        fillAmpm: function() {\n            var ampmL = this.options.template.indexOf('a') !== -1,\n                ampmU = this.options.template.indexOf('A') !== -1,            \n                items = [\n                    ['am', ampmL ? 'am' : 'AM'],\n                    ['pm', ampmL ? 'pm' : 'PM']\n                ];\n            return items;                              \n        },                                       \n\n        /*\n         Returns current date value from combos. \n         If format not specified - `options.format` used.\n         If format = `null` - Moment object returned.\n        */\n        getValue: function(format) {\n            var dt, values = {}, \n                that = this,\n                notSelected = false;\n                \n            //getting selected values    \n            $.each(this.map, function(k, v) {\n                if(k === 'ampm') {\n                    return;\n                }\n                var def = k === 'day' ? 1 : 0;\n                  \n                values[k] = that['$'+k] ? parseInt(that['$'+k].val(), 10) : def; \n                \n                if(isNaN(values[k])) {\n                   notSelected = true;\n                   return false; \n                }\n            });\n            \n            //if at least one visible combo not selected - return empty string\n            if(notSelected) {\n               return '';\n            }\n            \n            //convert hours 12h --> 24h \n            if(this.$ampm) {\n                //12:00 pm --> 12:00 (24-h format, midday), 12:00 am --> 00:00 (24-h format, midnight, start of day)\n                if(values.hour === 12) {\n                    values.hour = this.$ampm.val() === 'am' ? 0 : 12;                    \n                } else {\n                    values.hour = this.$ampm.val() === 'am' ? values.hour : values.hour+12;\n                }\n            }    \n            \n            dt = moment([values.year, values.month, values.day, values.hour, values.minute, values.second]);\n            \n            //highlight invalid date\n            this.highlight(dt);\n                              \n            format = format === undefined ? this.options.format : format;\n            if(format === null) {\n               return dt.isValid() ? dt : null; \n            } else {\n               return dt.isValid() ? dt.format(format) : ''; \n            }           \n        },\n        \n        setValue: function(value) {\n            if(!value) {\n                return;\n            }\n            \n            var dt = typeof value === 'string' ? moment(value, this.options.format) : moment(value),\n                that = this,\n                values = {};\n            \n            //function to find nearest value in select options\n            function getNearest($select, value) {\n                var delta = {};\n                $select.children('option').each(function(i, opt){\n                    var optValue = $(opt).attr('value'),\n                    distance;\n\n                    if(optValue === '') return;\n                    distance = Math.abs(optValue - value); \n                    if(typeof delta.distance === 'undefined' || distance < delta.distance) {\n                        delta = {value: optValue, distance: distance};\n                    } \n                }); \n                return delta.value;\n            }             \n            \n            if(dt.isValid()) {\n                //read values from date object\n                $.each(this.map, function(k, v) {\n                    if(k === 'ampm') {\n                       return; \n                    }\n                    values[k] = dt[v[1]]();\n                });\n               \n                if(this.$ampm) {\n                    //12:00 pm --> 12:00 (24-h format, midday), 12:00 am --> 00:00 (24-h format, midnight, start of day)\n                    if(values.hour >= 12) {\n                        values.ampm = 'pm';\n                        if(values.hour > 12) {\n                            values.hour -= 12;\n                        }\n                    } else {\n                        values.ampm = 'am';\n                        if(values.hour === 0) {\n                            values.hour = 12;\n                        }\n                    } \n                }\n               \n                $.each(values, function(k, v) {\n                    //call val() for each existing combo, e.g. this.$hour.val()\n                    if(that['$'+k]) {\n                       \n                        if(k === 'minute' && that.options.minuteStep > 1 && that.options.roundTime) {\n                           v = getNearest(that['$'+k], v);\n                        }\n                       \n                        if(k === 'second' && that.options.secondStep > 1 && that.options.roundTime) {\n                           v = getNearest(that['$'+k], v);\n                        }                       \n                       \n                        that['$'+k].val(v);\n                    }\n                });\n\n                // update days count\n                if (this.options.smartDays) {\n                    this.fillCombo('day');\n                }\n               \n               this.$element.val(dt.format(this.options.format)).change();\n            }\n        },\n        \n        /*\n         highlight combos if date is invalid\n        */\n        highlight: function(dt) {\n            if(!dt.isValid()) {\n                if(this.options.errorClass) {\n                    this.$widget.addClass(this.options.errorClass);\n                } else {\n                    //store original border color\n                    if(!this.borderColor) {\n                        this.borderColor = this.$widget.find('select').css('border-color'); \n                    }\n                    this.$widget.find('select').css('border-color', 'red');\n                } \n            } else {\n                if(this.options.errorClass) {\n                    this.$widget.removeClass(this.options.errorClass);\n                } else {\n                    this.$widget.find('select').css('border-color', this.borderColor);\n                }  \n            }\n        },\n        \n        leadZero: function(v) {\n            return v <= 9 ? '0' + v : v; \n        },\n        \n        destroy: function() {\n            this.$widget.remove();\n            this.$element.removeData('combodate').show();\n        }\n        \n        //todo: clear method        \n    };\n\n    $.fn.combodate = function ( option ) {\n        var d, args = Array.apply(null, arguments);\n        args.shift();\n\n        //getValue returns date as string / object (not jQuery object)\n        if(option === 'getValue' && this.length && (d = this.eq(0).data('combodate'))) {\n          return d.getValue.apply(d, args);\n        }        \n        \n        return this.each(function () {\n            var $this = $(this),\n            data = $this.data('combodate'),\n            options = typeof option == 'object' && option;\n            if (!data) {\n                $this.data('combodate', (data = new Combodate(this, options)));\n            }\n            if (typeof option == 'string' && typeof data[option] == 'function') {\n                data[option].apply(data, args);\n            }\n        });\n    };  \n    \n    $.fn.combodate.defaults = {\n         //in this format value stored in original input\n        format: 'DD-MM-YYYY HH:mm',      \n        //in this format items in dropdowns are displayed\n        template: 'D / MMM / YYYY   H : mm',\n        //initial value, can be `new Date()`    \n        value: null,                       \n        minYear: 1970,\n        maxYear: 2015,\n        yearDescending: true,\n        minuteStep: 5,\n        secondStep: 1,\n        firstItem: 'empty', //'name', 'empty', 'none'\n        errorClass: null,\n        roundTime: true, // whether to round minutes and seconds if step > 1\n        smartDays: false // whether days in combo depend on selected month: 31, 30, 28\n    };\n\n}(window.jQuery));\n/**\nCombodate input - dropdown date and time picker.    \nBased on [combodate](http://vitalets.github.com/combodate) plugin (included). To use it you should manually include [momentjs](http://momentjs.com).\n\n    <script src=\"js/moment.min.js\"></script>\n   \nAllows to input:\n\n* only date\n* only time \n* both date and time  \n\nPlease note, that format is taken from momentjs and **not compatible** with bootstrap-datepicker / jquery UI datepicker.  \nInternally value stored as `momentjs` object. \n\n@class combodate\n@extends abstractinput\n@final\n@since 1.4.0\n@example\n<a href=\"#\" id=\"dob\" data-type=\"combodate\" data-pk=\"1\" data-url=\"/post\" data-value=\"1984-05-15\" data-title=\"Select date\"></a>\n<script>\n$(function(){\n    $('#dob').editable({\n        format: 'YYYY-MM-DD',    \n        viewformat: 'DD.MM.YYYY',    \n        template: 'D / MMMM / YYYY',    \n        combodate: {\n                minYear: 2000,\n                maxYear: 2015,\n                minuteStep: 1\n           }\n        }\n    });\n});\n</script>\n**/\n\n/*global moment*/\n\n(function ($) {\n    \"use strict\";\n    \n    var Constructor = function (options) {\n        this.init('combodate', options, Constructor.defaults);\n        \n        //by default viewformat equals to format\n        if(!this.options.viewformat) {\n            this.options.viewformat = this.options.format;\n        }        \n        \n        //try parse combodate config defined as json string in data-combodate\n        options.combodate = $.fn.editableutils.tryParseJson(options.combodate, true);\n\n        //overriding combodate config (as by default jQuery extend() is not recursive)\n        this.options.combodate = $.extend({}, Constructor.defaults.combodate, options.combodate, {\n            format: this.options.format,\n            template: this.options.template\n        });\n    };\n\n    $.fn.editableutils.inherit(Constructor, $.fn.editabletypes.abstractinput);    \n    \n    $.extend(Constructor.prototype, {\n        render: function () {\n            this.$input.combodate(this.options.combodate);\n                    \n            if($.fn.editableform.engine === 'bs3') {\n                this.$input.siblings().find('select').addClass('form-control');\n            }\n            \n            if(this.options.inputclass) {\n                this.$input.siblings().find('select').addClass(this.options.inputclass);\n            }            \n            //\"clear\" link\n            /*\n            if(this.options.clear) {\n                this.$clear = $('<a href=\"#\"></a>').html(this.options.clear).click($.proxy(function(e){\n                    e.preventDefault();\n                    e.stopPropagation();\n                    this.clear();\n                }, this));\n                \n                this.$tpl.parent().append($('<div class=\"editable-clear\">').append(this.$clear));  \n            } \n            */               \n        },\n        \n        value2html: function(value, element) {\n            var text = value ? value.format(this.options.viewformat) : '';\n            //$(element).text(text);\n            Constructor.superclass.value2html.call(this, text, element);  \n        },\n\n        html2value: function(html) {\n            return html ? moment(html, this.options.viewformat) : null;\n        },   \n        \n        value2str: function(value) {\n            return value ? value.format(this.options.format) : '';\n       }, \n       \n       str2value: function(str) {\n           return str ? moment(str, this.options.format) : null;\n       }, \n       \n       value2submit: function(value) {\n           return this.value2str(value);\n       },                    \n\n       value2input: function(value) {\n           this.$input.combodate('setValue', value);\n       },\n        \n       input2value: function() { \n           return this.$input.combodate('getValue', null);\n       },       \n       \n       activate: function() {\n           this.$input.siblings('.combodate').find('select').eq(0).focus();\n       },\n       \n       /*\n       clear:  function() {\n          this.$input.data('datepicker').date = null;\n          this.$input.find('.active').removeClass('active');\n       },\n       */\n       \n       autosubmit: function() {\n           \n       }\n\n    });\n    \n    Constructor.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <input type=\"text\">\n        **/         \n        tpl:'<input type=\"text\">',\n        /**\n        @property inputclass \n        @default null\n        **/         \n        inputclass: null,\n        /**\n        Format used for sending value to server. Also applied when converting date from <code>data-value</code> attribute.<br>\n        See list of tokens in [momentjs docs](http://momentjs.com/docs/#/parsing/string-format)  \n        \n        @property format \n        @type string\n        @default YYYY-MM-DD\n        **/         \n        format:'YYYY-MM-DD',\n        /**\n        Format used for displaying date. Also applied when converting date from element's text on init.   \n        If not specified equals to `format`.\n        \n        @property viewformat \n        @type string\n        @default null\n        **/          \n        viewformat: null,        \n        /**\n        Template used for displaying dropdowns.\n        \n        @property template \n        @type string\n        @default D / MMM / YYYY\n        **/          \n        template: 'D / MMM / YYYY',  \n        /**\n        Configuration of combodate.\n        Full list of options: http://vitalets.github.com/combodate/#docs\n        \n        @property combodate \n        @type object\n        @default null\n        **/\n        combodate: null\n        \n        /*\n        (not implemented yet)\n        Text shown as clear date button. \n        If <code>false</code> clear button will not be rendered.\n        \n        @property clear \n        @type boolean|string\n        @default 'x clear'         \n        */\n        //clear: '&times; clear'\n    });   \n\n    $.fn.editabletypes.combodate = Constructor;\n\n}(window.jQuery));\n\n/*\nEditableform based on Twitter Bootstrap 3\n*/\n(function ($) {\n    \"use strict\";\n    \n    //store parent methods\n    var pInitInput = $.fn.editableform.Constructor.prototype.initInput;\n    \n    $.extend($.fn.editableform.Constructor.prototype, {\n        initTemplate: function() {\n            this.$form = $($.fn.editableform.template); \n            this.$form.find('.control-group').addClass('form-group');\n            this.$form.find('.editable-error-block').addClass('help-block');\n        },\n        initInput: function() {  \n            pInitInput.apply(this);\n\n            //for bs3 set default class `input-sm` to standard inputs\n            var emptyInputClass = this.input.options.inputclass === null || this.input.options.inputclass === false;\n            var defaultClass = 'input-sm';\n            \n            //bs3 add `form-control` class to standard inputs\n            var stdtypes = 'text,select,textarea,password,email,url,tel,number,range,time,typeaheadjs'.split(','); \n            if(~$.inArray(this.input.type, stdtypes)) {\n                this.input.$input.addClass('form-control');\n                if(emptyInputClass) {\n                    this.input.options.inputclass = defaultClass;\n                    this.input.$input.addClass(defaultClass);\n                }\n            }             \n        \n            //apply bs3 size class also to buttons (to fit size of control)\n            var $btn = this.$form.find('.editable-buttons');\n            var classes = emptyInputClass ? [defaultClass] : this.input.options.inputclass.split(' ');\n            for(var i=0; i<classes.length; i++) {\n                // `btn-sm` is default now\n                /*\n                if(classes[i].toLowerCase() === 'input-sm') { \n                    $btn.find('button').addClass('btn-sm');  \n                }\n                */\n                if(classes[i].toLowerCase() === 'input-lg') {\n                    $btn.find('button').removeClass('btn-sm').addClass('btn-lg'); \n                }\n            }\n        }\n    });    \n    \n    //buttons\n    $.fn.editableform.buttons = \n      '<button type=\"submit\" class=\"btn btn-primary btn-sm editable-submit\">'+\n        '<i class=\"glyphicon glyphicon-ok\"></i>'+\n      '</button>'+\n      '<button type=\"button\" class=\"btn btn-default btn-sm editable-cancel\">'+\n        '<i class=\"glyphicon glyphicon-remove\"></i>'+\n      '</button>';         \n    \n    //error classes\n    $.fn.editableform.errorGroupClass = 'has-error';\n    $.fn.editableform.errorBlockClass = null;  \n    //engine\n    $.fn.editableform.engine = 'bs3';  \n}(window.jQuery));\n/**\n* Editable Popover3 (for Bootstrap 3) \n* ---------------------\n* requires bootstrap-popover.js\n*/\n(function ($) {\n    \"use strict\";\n\n    //extend methods\n    $.extend($.fn.editableContainer.Popup.prototype, {\n        containerName: 'popover',\n        containerDataName: 'bs.popover',\n        innerCss: '.popover-content',\n        defaults: $.fn.popover.Constructor.DEFAULTS,\n\n        initContainer: function(){\n            $.extend(this.containerOptions, {\n                trigger: 'manual',\n                selector: false,\n                content: ' ',\n                template: this.defaults.template\n            });\n            \n            //as template property is used in inputs, hide it from popover\n            var t;\n            if(this.$element.data('template')) {\n               t = this.$element.data('template');\n               this.$element.removeData('template');  \n            } \n            \n            this.call(this.containerOptions);\n            \n            if(t) {\n               //restore data('template')\n               this.$element.data('template', t); \n            }\n        }, \n        \n        /* show */\n        innerShow: function () {\n            this.call('show');                \n        },  \n        \n        /* hide */\n        innerHide: function () {\n            this.call('hide');       \n        }, \n        \n        /* destroy */\n        innerDestroy: function() {\n            this.call('destroy');\n        },                               \n        \n        setContainerOption: function(key, value) {\n            this.container().options[key] = value; \n        },               \n\n        /**\n        * move popover to new position. This function mainly copied from bootstrap-popover.\n        */\n        /*jshint laxcomma: true, eqeqeq: false*/\n        setPosition: function () { \n\n            (function() {\n            /*    \n                var $tip = this.tip()\n                , inside\n                , pos\n                , actualWidth\n                , actualHeight\n                , placement\n                , tp\n                , tpt\n                , tpb\n                , tpl\n                , tpr;\n\n                placement = typeof this.options.placement === 'function' ?\n                this.options.placement.call(this, $tip[0], this.$element[0]) :\n                this.options.placement;\n\n                inside = /in/.test(placement);\n               \n                $tip\n              //  .detach()\n              //vitalets: remove any placement class because otherwise they dont influence on re-positioning of visible popover\n                .removeClass('top right bottom left')\n                .css({ top: 0, left: 0, display: 'block' });\n              //  .insertAfter(this.$element);\n               \n                pos = this.getPosition(inside);\n\n                actualWidth = $tip[0].offsetWidth;\n                actualHeight = $tip[0].offsetHeight;\n\n                placement = inside ? placement.split(' ')[1] : placement;\n\n                tpb = {top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2};\n                tpt = {top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2};\n                tpl = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth};\n                tpr = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width};\n\n                switch (placement) {\n                    case 'bottom':\n                        if ((tpb.top + actualHeight) > ($(window).scrollTop() + $(window).height())) {\n                            if (tpt.top > $(window).scrollTop()) {\n                                placement = 'top';\n                            } else if ((tpr.left + actualWidth) < ($(window).scrollLeft() + $(window).width())) {\n                                placement = 'right';\n                            } else if (tpl.left > $(window).scrollLeft()) {\n                                placement = 'left';\n                            } else {\n                                placement = 'right';\n                            }\n                        }\n                        break;\n                    case 'top':\n                        if (tpt.top < $(window).scrollTop()) {\n                            if ((tpb.top + actualHeight) < ($(window).scrollTop() + $(window).height())) {\n                                placement = 'bottom';\n                            } else if ((tpr.left + actualWidth) < ($(window).scrollLeft() + $(window).width())) {\n                                placement = 'right';\n                            } else if (tpl.left > $(window).scrollLeft()) {\n                                placement = 'left';\n                            } else {\n                                placement = 'right';\n                            }\n                        }\n                        break;\n                    case 'left':\n                        if (tpl.left < $(window).scrollLeft()) {\n                            if ((tpr.left + actualWidth) < ($(window).scrollLeft() + $(window).width())) {\n                                placement = 'right';\n                            } else if (tpt.top > $(window).scrollTop()) {\n                                placement = 'top';\n                            } else if (tpt.top > $(window).scrollTop()) {\n                                placement = 'bottom';\n                            } else {\n                                placement = 'right';\n                            }\n                        }\n                        break;\n                    case 'right':\n                        if ((tpr.left + actualWidth) > ($(window).scrollLeft() + $(window).width())) {\n                            if (tpl.left > $(window).scrollLeft()) {\n                                placement = 'left';\n                            } else if (tpt.top > $(window).scrollTop()) {\n                                placement = 'top';\n                            } else if (tpt.top > $(window).scrollTop()) {\n                                placement = 'bottom';\n                            }\n                        }\n                        break;\n                }\n\n                switch (placement) {\n                    case 'bottom':\n                        tp = tpb;\n                        break;\n                    case 'top':\n                        tp = tpt;\n                        break;\n                    case 'left':\n                        tp = tpl;\n                        break;\n                    case 'right':\n                        tp = tpr;\n                        break;\n                }\n\n                $tip\n                .offset(tp)\n                .addClass(placement)\n                .addClass('in');\n           */\n                     \n           \n            var $tip = this.tip();\n            \n            var placement = typeof this.options.placement == 'function' ?\n                this.options.placement.call(this, $tip[0], this.$element[0]) :\n                this.options.placement;            \n\n            var autoToken = /\\s?auto?\\s?/i;\n            var autoPlace = autoToken.test(placement);\n            if (autoPlace) {\n                placement = placement.replace(autoToken, '') || 'top';\n            }\n            \n            \n            var pos = this.getPosition();\n            var actualWidth = $tip[0].offsetWidth;\n            var actualHeight = $tip[0].offsetHeight;\n\n            if (autoPlace) {\n                var $parent = this.$element.parent();\n\n                var orgPlacement = placement;\n                var docScroll    = document.documentElement.scrollTop || document.body.scrollTop;\n                var parentWidth  = this.options.container == 'body' ? window.innerWidth  : $parent.outerWidth();\n                var parentHeight = this.options.container == 'body' ? window.innerHeight : $parent.outerHeight();\n                var parentLeft   = this.options.container == 'body' ? 0 : $parent.offset().left;\n\n                placement = placement == 'bottom' && pos.top   + pos.height  + actualHeight - docScroll > parentHeight  ? 'top'    :\n                            placement == 'top'    && pos.top   - docScroll   - actualHeight < 0                         ? 'bottom' :\n                            placement == 'right'  && pos.right + actualWidth > parentWidth                              ? 'left'   :\n                            placement == 'left'   && pos.left  - actualWidth < parentLeft                               ? 'right'  :\n                            placement;\n\n                $tip\n                  .removeClass(orgPlacement)\n                  .addClass(placement);\n            }\n\n\n            var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);\n\n            this.applyPlacement(calculatedOffset, placement);            \n                     \n                \n            }).call(this.container());\n          /*jshint laxcomma: false, eqeqeq: true*/  \n        }            \n    });\n\n}(window.jQuery));\n\n/* =========================================================\n * bootstrap-datepicker.js\n * http://www.eyecon.ro/bootstrap-datepicker\n * =========================================================\n * Copyright 2012 Stefan Petre\n * Improvements by Andrew Rowls\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ========================================================= */\n\n(function( $ ) {\n\n\tfunction UTCDate(){\n\t\treturn new Date(Date.UTC.apply(Date, arguments));\n\t}\n\tfunction UTCToday(){\n\t\tvar today = new Date();\n\t\treturn UTCDate(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate());\n\t}\n\n\t// Picker object\n\n\tvar Datepicker = function(element, options) {\n\t\tvar that = this;\n\n\t\tthis._process_options(options);\n\n\t\tthis.element = $(element);\n\t\tthis.isInline = false;\n\t\tthis.isInput = this.element.is('input');\n\t\tthis.component = this.element.is('.date') ? this.element.find('.add-on, .btn') : false;\n\t\tthis.hasInput = this.component && this.element.find('input').length;\n\t\tif(this.component && this.component.length === 0)\n\t\t\tthis.component = false;\n\n\t\tthis.picker = $(DPGlobal.template);\n\t\tthis._buildEvents();\n\t\tthis._attachEvents();\n\n\t\tif(this.isInline) {\n\t\t\tthis.picker.addClass('datepicker-inline').appendTo(this.element);\n\t\t} else {\n\t\t\tthis.picker.addClass('datepicker-dropdown dropdown-menu');\n\t\t}\n\n\t\tif (this.o.rtl){\n\t\t\tthis.picker.addClass('datepicker-rtl');\n\t\t\tthis.picker.find('.prev i, .next i')\n\t\t\t\t\t\t.toggleClass('icon-arrow-left icon-arrow-right');\n\t\t}\n\n\n\t\tthis.viewMode = this.o.startView;\n\n\t\tif (this.o.calendarWeeks)\n\t\t\tthis.picker.find('tfoot th.today')\n\t\t\t\t\t\t.attr('colspan', function(i, val){\n\t\t\t\t\t\t\treturn parseInt(val) + 1;\n\t\t\t\t\t\t});\n\n\t\tthis._allow_update = false;\n\n\t\tthis.setStartDate(this.o.startDate);\n\t\tthis.setEndDate(this.o.endDate);\n\t\tthis.setDaysOfWeekDisabled(this.o.daysOfWeekDisabled);\n\n\t\tthis.fillDow();\n\t\tthis.fillMonths();\n\n\t\tthis._allow_update = true;\n\n\t\tthis.update();\n\t\tthis.showMode();\n\n\t\tif(this.isInline) {\n\t\t\tthis.show();\n\t\t}\n\t};\n\n\tDatepicker.prototype = {\n\t\tconstructor: Datepicker,\n\n\t\t_process_options: function(opts){\n\t\t\t// Store raw options for reference\n\t\t\tthis._o = $.extend({}, this._o, opts);\n\t\t\t// Processed options\n\t\t\tvar o = this.o = $.extend({}, this._o);\n\n\t\t\t// Check if \"de-DE\" style date is available, if not language should\n\t\t\t// fallback to 2 letter code eg \"de\"\n\t\t\tvar lang = o.language;\n\t\t\tif (!dates[lang]) {\n\t\t\t\tlang = lang.split('-')[0];\n\t\t\t\tif (!dates[lang])\n\t\t\t\t\tlang = defaults.language;\n\t\t\t}\n\t\t\to.language = lang;\n\n\t\t\tswitch(o.startView){\n\t\t\t\tcase 2:\n\t\t\t\tcase 'decade':\n\t\t\t\t\to.startView = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\tcase 'year':\n\t\t\t\t\to.startView = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\to.startView = 0;\n\t\t\t}\n\n\t\t\tswitch (o.minViewMode) {\n\t\t\t\tcase 1:\n\t\t\t\tcase 'months':\n\t\t\t\t\to.minViewMode = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tcase 'years':\n\t\t\t\t\to.minViewMode = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\to.minViewMode = 0;\n\t\t\t}\n\n\t\t\to.startView = Math.max(o.startView, o.minViewMode);\n\n\t\t\to.weekStart %= 7;\n\t\t\to.weekEnd = ((o.weekStart + 6) % 7);\n\n\t\t\tvar format = DPGlobal.parseFormat(o.format)\n\t\t\tif (o.startDate !== -Infinity) {\n\t\t\t\to.startDate = DPGlobal.parseDate(o.startDate, format, o.language);\n\t\t\t}\n\t\t\tif (o.endDate !== Infinity) {\n\t\t\t\to.endDate = DPGlobal.parseDate(o.endDate, format, o.language);\n\t\t\t}\n\n\t\t\to.daysOfWeekDisabled = o.daysOfWeekDisabled||[];\n\t\t\tif (!$.isArray(o.daysOfWeekDisabled))\n\t\t\t\to.daysOfWeekDisabled = o.daysOfWeekDisabled.split(/[,\\s]*/);\n\t\t\to.daysOfWeekDisabled = $.map(o.daysOfWeekDisabled, function (d) {\n\t\t\t\treturn parseInt(d, 10);\n\t\t\t});\n\t\t},\n\t\t_events: [],\n\t\t_secondaryEvents: [],\n\t\t_applyEvents: function(evs){\n\t\t\tfor (var i=0, el, ev; i<evs.length; i++){\n\t\t\t\tel = evs[i][0];\n\t\t\t\tev = evs[i][1];\n\t\t\t\tel.on(ev);\n\t\t\t}\n\t\t},\n\t\t_unapplyEvents: function(evs){\n\t\t\tfor (var i=0, el, ev; i<evs.length; i++){\n\t\t\t\tel = evs[i][0];\n\t\t\t\tev = evs[i][1];\n\t\t\t\tel.off(ev);\n\t\t\t}\n\t\t},\n\t\t_buildEvents: function(){\n\t\t\tif (this.isInput) { // single input\n\t\t\t\tthis._events = [\n\t\t\t\t\t[this.element, {\n\t\t\t\t\t\tfocus: $.proxy(this.show, this),\n\t\t\t\t\t\tkeyup: $.proxy(this.update, this),\n\t\t\t\t\t\tkeydown: $.proxy(this.keydown, this)\n\t\t\t\t\t}]\n\t\t\t\t];\n\t\t\t}\n\t\t\telse if (this.component && this.hasInput){ // component: input + button\n\t\t\t\tthis._events = [\n\t\t\t\t\t// For components that are not readonly, allow keyboard nav\n\t\t\t\t\t[this.element.find('input'), {\n\t\t\t\t\t\tfocus: $.proxy(this.show, this),\n\t\t\t\t\t\tkeyup: $.proxy(this.update, this),\n\t\t\t\t\t\tkeydown: $.proxy(this.keydown, this)\n\t\t\t\t\t}],\n\t\t\t\t\t[this.component, {\n\t\t\t\t\t\tclick: $.proxy(this.show, this)\n\t\t\t\t\t}]\n\t\t\t\t];\n\t\t\t}\n\t\t\telse if (this.element.is('div')) {  // inline datepicker\n\t\t\t\tthis.isInline = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis._events = [\n\t\t\t\t\t[this.element, {\n\t\t\t\t\t\tclick: $.proxy(this.show, this)\n\t\t\t\t\t}]\n\t\t\t\t];\n\t\t\t}\n\n\t\t\tthis._secondaryEvents = [\n\t\t\t\t[this.picker, {\n\t\t\t\t\tclick: $.proxy(this.click, this)\n\t\t\t\t}],\n\t\t\t\t[$(window), {\n\t\t\t\t\tresize: $.proxy(this.place, this)\n\t\t\t\t}],\n\t\t\t\t[$(document), {\n\t\t\t\t\tmousedown: $.proxy(function (e) {\n\t\t\t\t\t\t// Clicked outside the datepicker, hide it\n\t\t\t\t\t\tif (!(\n\t\t\t\t\t\t\tthis.element.is(e.target) ||\n\t\t\t\t\t\t\tthis.element.find(e.target).size() ||\n\t\t\t\t\t\t\tthis.picker.is(e.target) ||\n\t\t\t\t\t\t\tthis.picker.find(e.target).size()\n\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\tthis.hide();\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this)\n\t\t\t\t}]\n\t\t\t];\n\t\t},\n\t\t_attachEvents: function(){\n\t\t\tthis._detachEvents();\n\t\t\tthis._applyEvents(this._events);\n\t\t},\n\t\t_detachEvents: function(){\n\t\t\tthis._unapplyEvents(this._events);\n\t\t},\n\t\t_attachSecondaryEvents: function(){\n\t\t\tthis._detachSecondaryEvents();\n\t\t\tthis._applyEvents(this._secondaryEvents);\n\t\t},\n\t\t_detachSecondaryEvents: function(){\n\t\t\tthis._unapplyEvents(this._secondaryEvents);\n\t\t},\n\t\t_trigger: function(event, altdate){\n\t\t\tvar date = altdate || this.date,\n\t\t\t\tlocal_date = new Date(date.getTime() + (date.getTimezoneOffset()*60000));\n\n\t\t\tthis.element.trigger({\n\t\t\t\ttype: event,\n\t\t\t\tdate: local_date,\n\t\t\t\tformat: $.proxy(function(altformat){\n\t\t\t\t\tvar format = altformat || this.o.format;\n\t\t\t\t\treturn DPGlobal.formatDate(date, format, this.o.language);\n\t\t\t\t}, this)\n\t\t\t});\n\t\t},\n\n\t\tshow: function(e) {\n\t\t\tif (!this.isInline)\n\t\t\t\tthis.picker.appendTo('body');\n\t\t\tthis.picker.show();\n\t\t\tthis.height = this.component ? this.component.outerHeight() : this.element.outerHeight();\n\t\t\tthis.place();\n\t\t\tthis._attachSecondaryEvents();\n\t\t\tif (e) {\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t\tthis._trigger('show');\n\t\t},\n\n\t\thide: function(e){\n\t\t\tif(this.isInline) return;\n\t\t\tif (!this.picker.is(':visible')) return;\n\t\t\tthis.picker.hide().detach();\n\t\t\tthis._detachSecondaryEvents();\n\t\t\tthis.viewMode = this.o.startView;\n\t\t\tthis.showMode();\n\n\t\t\tif (\n\t\t\t\tthis.o.forceParse &&\n\t\t\t\t(\n\t\t\t\t\tthis.isInput && this.element.val() ||\n\t\t\t\t\tthis.hasInput && this.element.find('input').val()\n\t\t\t\t)\n\t\t\t)\n\t\t\t\tthis.setValue();\n\t\t\tthis._trigger('hide');\n\t\t},\n\n\t\tremove: function() {\n\t\t\tthis.hide();\n\t\t\tthis._detachEvents();\n\t\t\tthis._detachSecondaryEvents();\n\t\t\tthis.picker.remove();\n\t\t\tdelete this.element.data().datepicker;\n\t\t\tif (!this.isInput) {\n\t\t\t\tdelete this.element.data().date;\n\t\t\t}\n\t\t},\n\n\t\tgetDate: function() {\n\t\t\tvar d = this.getUTCDate();\n\t\t\treturn new Date(d.getTime() + (d.getTimezoneOffset()*60000));\n\t\t},\n\n\t\tgetUTCDate: function() {\n\t\t\treturn this.date;\n\t\t},\n\n\t\tsetDate: function(d) {\n\t\t\tthis.setUTCDate(new Date(d.getTime() - (d.getTimezoneOffset()*60000)));\n\t\t},\n\n\t\tsetUTCDate: function(d) {\n\t\t\tthis.date = d;\n\t\t\tthis.setValue();\n\t\t},\n\n\t\tsetValue: function() {\n\t\t\tvar formatted = this.getFormattedDate();\n\t\t\tif (!this.isInput) {\n\t\t\t\tif (this.component){\n\t\t\t\t\tthis.element.find('input').val(formatted);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.element.val(formatted);\n\t\t\t}\n\t\t},\n\n\t\tgetFormattedDate: function(format) {\n\t\t\tif (format === undefined)\n\t\t\t\tformat = this.o.format;\n\t\t\treturn DPGlobal.formatDate(this.date, format, this.o.language);\n\t\t},\n\n\t\tsetStartDate: function(startDate){\n\t\t\tthis._process_options({startDate: startDate});\n\t\t\tthis.update();\n\t\t\tthis.updateNavArrows();\n\t\t},\n\n\t\tsetEndDate: function(endDate){\n\t\t\tthis._process_options({endDate: endDate});\n\t\t\tthis.update();\n\t\t\tthis.updateNavArrows();\n\t\t},\n\n\t\tsetDaysOfWeekDisabled: function(daysOfWeekDisabled){\n\t\t\tthis._process_options({daysOfWeekDisabled: daysOfWeekDisabled});\n\t\t\tthis.update();\n\t\t\tthis.updateNavArrows();\n\t\t},\n\n\t\tplace: function(){\n\t\t\t\t\t\tif(this.isInline) return;\n\t\t\tvar zIndex = parseInt(this.element.parents().filter(function() {\n\t\t\t\t\t\t\treturn $(this).css('z-index') != 'auto';\n\t\t\t\t\t\t}).first().css('z-index'))+10;\n\t\t\tvar offset = this.component ? this.component.parent().offset() : this.element.offset();\n\t\t\tvar height = this.component ? this.component.outerHeight(true) : this.element.outerHeight(true);\n\t\t\tthis.picker.css({\n\t\t\t\ttop: offset.top + height,\n\t\t\t\tleft: offset.left,\n\t\t\t\tzIndex: zIndex\n\t\t\t});\n\t\t},\n\n\t\t_allow_update: true,\n\t\tupdate: function(){\n\t\t\tif (!this._allow_update) return;\n\n\t\t\tvar date, fromArgs = false;\n\t\t\tif(arguments && arguments.length && (typeof arguments[0] === 'string' || arguments[0] instanceof Date)) {\n\t\t\t\tdate = arguments[0];\n\t\t\t\tfromArgs = true;\n\t\t\t} else {\n\t\t\t\tdate = this.isInput ? this.element.val() : this.element.data('date') || this.element.find('input').val();\n\t\t\t\tdelete this.element.data().date;\n\t\t\t}\n\n\t\t\tthis.date = DPGlobal.parseDate(date, this.o.format, this.o.language);\n\n\t\t\tif(fromArgs) this.setValue();\n\n\t\t\tif (this.date < this.o.startDate) {\n\t\t\t\tthis.viewDate = new Date(this.o.startDate);\n\t\t\t} else if (this.date > this.o.endDate) {\n\t\t\t\tthis.viewDate = new Date(this.o.endDate);\n\t\t\t} else {\n\t\t\t\tthis.viewDate = new Date(this.date);\n\t\t\t}\n\t\t\tthis.fill();\n\t\t},\n\n\t\tfillDow: function(){\n\t\t\tvar dowCnt = this.o.weekStart,\n\t\t\thtml = '<tr>';\n\t\t\tif(this.o.calendarWeeks){\n\t\t\t\tvar cell = '<th class=\"cw\">&nbsp;</th>';\n\t\t\t\thtml += cell;\n\t\t\t\tthis.picker.find('.datepicker-days thead tr:first-child').prepend(cell);\n\t\t\t}\n\t\t\twhile (dowCnt < this.o.weekStart + 7) {\n\t\t\t\thtml += '<th class=\"dow\">'+dates[this.o.language].daysMin[(dowCnt++)%7]+'</th>';\n\t\t\t}\n\t\t\thtml += '</tr>';\n\t\t\tthis.picker.find('.datepicker-days thead').append(html);\n\t\t},\n\n\t\tfillMonths: function(){\n\t\t\tvar html = '',\n\t\t\ti = 0;\n\t\t\twhile (i < 12) {\n\t\t\t\thtml += '<span class=\"month\">'+dates[this.o.language].monthsShort[i++]+'</span>';\n\t\t\t}\n\t\t\tthis.picker.find('.datepicker-months td').html(html);\n\t\t},\n\n\t\tsetRange: function(range){\n\t\t\tif (!range || !range.length)\n\t\t\t\tdelete this.range;\n\t\t\telse\n\t\t\t\tthis.range = $.map(range, function(d){ return d.valueOf(); });\n\t\t\tthis.fill();\n\t\t},\n\n\t\tgetClassNames: function(date){\n\t\t\tvar cls = [],\n\t\t\t\tyear = this.viewDate.getUTCFullYear(),\n\t\t\t\tmonth = this.viewDate.getUTCMonth(),\n\t\t\t\tcurrentDate = this.date.valueOf(),\n\t\t\t\ttoday = new Date();\n\t\t\tif (date.getUTCFullYear() < year || (date.getUTCFullYear() == year && date.getUTCMonth() < month)) {\n\t\t\t\tcls.push('old');\n\t\t\t} else if (date.getUTCFullYear() > year || (date.getUTCFullYear() == year && date.getUTCMonth() > month)) {\n\t\t\t\tcls.push('new');\n\t\t\t}\n\t\t\t// Compare internal UTC date with local today, not UTC today\n\t\t\tif (this.o.todayHighlight &&\n\t\t\t\tdate.getUTCFullYear() == today.getFullYear() &&\n\t\t\t\tdate.getUTCMonth() == today.getMonth() &&\n\t\t\t\tdate.getUTCDate() == today.getDate()) {\n\t\t\t\tcls.push('today');\n\t\t\t}\n\t\t\tif (currentDate && date.valueOf() == currentDate) {\n\t\t\t\tcls.push('active');\n\t\t\t}\n\t\t\tif (date.valueOf() < this.o.startDate || date.valueOf() > this.o.endDate ||\n\t\t\t\t$.inArray(date.getUTCDay(), this.o.daysOfWeekDisabled) !== -1) {\n\t\t\t\tcls.push('disabled');\n\t\t\t}\n\t\t\tif (this.range){\n\t\t\t\tif (date > this.range[0] && date < this.range[this.range.length-1]){\n\t\t\t\t\tcls.push('range');\n\t\t\t\t}\n\t\t\t\tif ($.inArray(date.valueOf(), this.range) != -1){\n\t\t\t\t\tcls.push('selected');\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cls;\n\t\t},\n\n\t\tfill: function() {\n\t\t\tvar d = new Date(this.viewDate),\n\t\t\t\tyear = d.getUTCFullYear(),\n\t\t\t\tmonth = d.getUTCMonth(),\n\t\t\t\tstartYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,\n\t\t\t\tstartMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,\n\t\t\t\tendYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,\n\t\t\t\tendMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,\n\t\t\t\tcurrentDate = this.date && this.date.valueOf(),\n\t\t\t\ttooltip;\n\t\t\tthis.picker.find('.datepicker-days thead th.datepicker-switch')\n\t\t\t\t\t\t.text(dates[this.o.language].months[month]+' '+year);\n\t\t\tthis.picker.find('tfoot th.today')\n\t\t\t\t\t\t.text(dates[this.o.language].today)\n\t\t\t\t\t\t.toggle(this.o.todayBtn !== false);\n\t\t\tthis.picker.find('tfoot th.clear')\n\t\t\t\t\t\t.text(dates[this.o.language].clear)\n\t\t\t\t\t\t.toggle(this.o.clearBtn !== false);\n\t\t\tthis.updateNavArrows();\n\t\t\tthis.fillMonths();\n\t\t\tvar prevMonth = UTCDate(year, month-1, 28,0,0,0,0),\n\t\t\t\tday = DPGlobal.getDaysInMonth(prevMonth.getUTCFullYear(), prevMonth.getUTCMonth());\n\t\t\tprevMonth.setUTCDate(day);\n\t\t\tprevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.o.weekStart + 7)%7);\n\t\t\tvar nextMonth = new Date(prevMonth);\n\t\t\tnextMonth.setUTCDate(nextMonth.getUTCDate() + 42);\n\t\t\tnextMonth = nextMonth.valueOf();\n\t\t\tvar html = [];\n\t\t\tvar clsName;\n\t\t\twhile(prevMonth.valueOf() < nextMonth) {\n\t\t\t\tif (prevMonth.getUTCDay() == this.o.weekStart) {\n\t\t\t\t\thtml.push('<tr>');\n\t\t\t\t\tif(this.o.calendarWeeks){\n\t\t\t\t\t\t// ISO 8601: First week contains first thursday.\n\t\t\t\t\t\t// ISO also states week starts on Monday, but we can be more abstract here.\n\t\t\t\t\t\tvar\n\t\t\t\t\t\t\t// Start of current week: based on weekstart/current date\n\t\t\t\t\t\t\tws = new Date(+prevMonth + (this.o.weekStart - prevMonth.getUTCDay() - 7) % 7 * 864e5),\n\t\t\t\t\t\t\t// Thursday of this week\n\t\t\t\t\t\t\tth = new Date(+ws + (7 + 4 - ws.getUTCDay()) % 7 * 864e5),\n\t\t\t\t\t\t\t// First Thursday of year, year from thursday\n\t\t\t\t\t\t\tyth = new Date(+(yth = UTCDate(th.getUTCFullYear(), 0, 1)) + (7 + 4 - yth.getUTCDay())%7*864e5),\n\t\t\t\t\t\t\t// Calendar week: ms between thursdays, div ms per day, div 7 days\n\t\t\t\t\t\t\tcalWeek =  (th - yth) / 864e5 / 7 + 1;\n\t\t\t\t\t\thtml.push('<td class=\"cw\">'+ calWeek +'</td>');\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tclsName = this.getClassNames(prevMonth);\n\t\t\t\tclsName.push('day');\n\n\t\t\t\tvar before = this.o.beforeShowDay(prevMonth);\n\t\t\t\tif (before === undefined)\n\t\t\t\t\tbefore = {};\n\t\t\t\telse if (typeof(before) === 'boolean')\n\t\t\t\t\tbefore = {enabled: before};\n\t\t\t\telse if (typeof(before) === 'string')\n\t\t\t\t\tbefore = {classes: before};\n\t\t\t\tif (before.enabled === false)\n\t\t\t\t\tclsName.push('disabled');\n\t\t\t\tif (before.classes)\n\t\t\t\t\tclsName = clsName.concat(before.classes.split(/\\s+/));\n\t\t\t\tif (before.tooltip)\n\t\t\t\t\ttooltip = before.tooltip;\n\n\t\t\t\tclsName = $.unique(clsName);\n\t\t\t\thtml.push('<td class=\"'+clsName.join(' ')+'\"' + (tooltip ? ' title=\"'+tooltip+'\"' : '') + '>'+prevMonth.getUTCDate() + '</td>');\n\t\t\t\tif (prevMonth.getUTCDay() == this.o.weekEnd) {\n\t\t\t\t\thtml.push('</tr>');\n\t\t\t\t}\n\t\t\t\tprevMonth.setUTCDate(prevMonth.getUTCDate()+1);\n\t\t\t}\n\t\t\tthis.picker.find('.datepicker-days tbody').empty().append(html.join(''));\n\t\t\tvar currentYear = this.date && this.date.getUTCFullYear();\n\n\t\t\tvar months = this.picker.find('.datepicker-months')\n\t\t\t\t\t\t.find('th:eq(1)')\n\t\t\t\t\t\t\t.text(year)\n\t\t\t\t\t\t\t.end()\n\t\t\t\t\t\t.find('span').removeClass('active');\n\t\t\tif (currentYear && currentYear == year) {\n\t\t\t\tmonths.eq(this.date.getUTCMonth()).addClass('active');\n\t\t\t}\n\t\t\tif (year < startYear || year > endYear) {\n\t\t\t\tmonths.addClass('disabled');\n\t\t\t}\n\t\t\tif (year == startYear) {\n\t\t\t\tmonths.slice(0, startMonth).addClass('disabled');\n\t\t\t}\n\t\t\tif (year == endYear) {\n\t\t\t\tmonths.slice(endMonth+1).addClass('disabled');\n\t\t\t}\n\n\t\t\thtml = '';\n\t\t\tyear = parseInt(year/10, 10) * 10;\n\t\t\tvar yearCont = this.picker.find('.datepicker-years')\n\t\t\t\t\t\t\t\t.find('th:eq(1)')\n\t\t\t\t\t\t\t\t\t.text(year + '-' + (year + 9))\n\t\t\t\t\t\t\t\t\t.end()\n\t\t\t\t\t\t\t\t.find('td');\n\t\t\tyear -= 1;\n\t\t\tfor (var i = -1; i < 11; i++) {\n\t\t\t\thtml += '<span class=\"year'+(i == -1 ? ' old' : i == 10 ? ' new' : '')+(currentYear == year ? ' active' : '')+(year < startYear || year > endYear ? ' disabled' : '')+'\">'+year+'</span>';\n\t\t\t\tyear += 1;\n\t\t\t}\n\t\t\tyearCont.html(html);\n\t\t},\n\n\t\tupdateNavArrows: function() {\n\t\t\tif (!this._allow_update) return;\n\n\t\t\tvar d = new Date(this.viewDate),\n\t\t\t\tyear = d.getUTCFullYear(),\n\t\t\t\tmonth = d.getUTCMonth();\n\t\t\tswitch (this.viewMode) {\n\t\t\t\tcase 0:\n\t\t\t\t\tif (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear() && month <= this.o.startDate.getUTCMonth()) {\n\t\t\t\t\t\tthis.picker.find('.prev').css({visibility: 'hidden'});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.picker.find('.prev').css({visibility: 'visible'});\n\t\t\t\t\t}\n\t\t\t\t\tif (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear() && month >= this.o.endDate.getUTCMonth()) {\n\t\t\t\t\t\tthis.picker.find('.next').css({visibility: 'hidden'});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.picker.find('.next').css({visibility: 'visible'});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\tcase 2:\n\t\t\t\t\tif (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear()) {\n\t\t\t\t\t\tthis.picker.find('.prev').css({visibility: 'hidden'});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.picker.find('.prev').css({visibility: 'visible'});\n\t\t\t\t\t}\n\t\t\t\t\tif (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear()) {\n\t\t\t\t\t\tthis.picker.find('.next').css({visibility: 'hidden'});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.picker.find('.next').css({visibility: 'visible'});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t},\n\n\t\tclick: function(e) {\n\t\t\te.preventDefault();\n\t\t\tvar target = $(e.target).closest('span, td, th');\n\t\t\tif (target.length == 1) {\n\t\t\t\tswitch(target[0].nodeName.toLowerCase()) {\n\t\t\t\t\tcase 'th':\n\t\t\t\t\t\tswitch(target[0].className) {\n\t\t\t\t\t\t\tcase 'datepicker-switch':\n\t\t\t\t\t\t\t\tthis.showMode(1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'prev':\n\t\t\t\t\t\t\tcase 'next':\n\t\t\t\t\t\t\t\tvar dir = DPGlobal.modes[this.viewMode].navStep * (target[0].className == 'prev' ? -1 : 1);\n\t\t\t\t\t\t\t\tswitch(this.viewMode){\n\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\tthis.viewDate = this.moveMonth(this.viewDate, dir);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\tthis.viewDate = this.moveYear(this.viewDate, dir);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.fill();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'today':\n\t\t\t\t\t\t\t\tvar date = new Date();\n\t\t\t\t\t\t\t\tdate = UTCDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);\n\n\t\t\t\t\t\t\t\tthis.showMode(-2);\n\t\t\t\t\t\t\t\tvar which = this.o.todayBtn == 'linked' ? null : 'view';\n\t\t\t\t\t\t\t\tthis._setDate(date, which);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'clear':\n\t\t\t\t\t\t\t\tvar element;\n\t\t\t\t\t\t\t\tif (this.isInput)\n\t\t\t\t\t\t\t\t\telement = this.element;\n\t\t\t\t\t\t\t\telse if (this.component)\n\t\t\t\t\t\t\t\t\telement = this.element.find('input');\n\t\t\t\t\t\t\t\tif (element)\n\t\t\t\t\t\t\t\t\telement.val(\"\").change();\n\t\t\t\t\t\t\t\tthis._trigger('changeDate');\n\t\t\t\t\t\t\t\tthis.update();\n\t\t\t\t\t\t\t\tif (this.o.autoclose)\n\t\t\t\t\t\t\t\t\tthis.hide();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'span':\n\t\t\t\t\t\tif (!target.is('.disabled')) {\n\t\t\t\t\t\t\tthis.viewDate.setUTCDate(1);\n\t\t\t\t\t\t\tif (target.is('.month')) {\n\t\t\t\t\t\t\t\tvar day = 1;\n\t\t\t\t\t\t\t\tvar month = target.parent().find('span').index(target);\n\t\t\t\t\t\t\t\tvar year = this.viewDate.getUTCFullYear();\n\t\t\t\t\t\t\t\tthis.viewDate.setUTCMonth(month);\n\t\t\t\t\t\t\t\tthis._trigger('changeMonth', this.viewDate);\n\t\t\t\t\t\t\t\tif (this.o.minViewMode === 1) {\n\t\t\t\t\t\t\t\t\tthis._setDate(UTCDate(year, month, day,0,0,0,0));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvar year = parseInt(target.text(), 10)||0;\n\t\t\t\t\t\t\t\tvar day = 1;\n\t\t\t\t\t\t\t\tvar month = 0;\n\t\t\t\t\t\t\t\tthis.viewDate.setUTCFullYear(year);\n\t\t\t\t\t\t\t\tthis._trigger('changeYear', this.viewDate);\n\t\t\t\t\t\t\t\tif (this.o.minViewMode === 2) {\n\t\t\t\t\t\t\t\t\tthis._setDate(UTCDate(year, month, day,0,0,0,0));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.showMode(-1);\n\t\t\t\t\t\t\tthis.fill();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'td':\n\t\t\t\t\t\tif (target.is('.day') && !target.is('.disabled')){\n\t\t\t\t\t\t\tvar day = parseInt(target.text(), 10)||1;\n\t\t\t\t\t\t\tvar year = this.viewDate.getUTCFullYear(),\n\t\t\t\t\t\t\t\tmonth = this.viewDate.getUTCMonth();\n\t\t\t\t\t\t\tif (target.is('.old')) {\n\t\t\t\t\t\t\t\tif (month === 0) {\n\t\t\t\t\t\t\t\t\tmonth = 11;\n\t\t\t\t\t\t\t\t\tyear -= 1;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmonth -= 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (target.is('.new')) {\n\t\t\t\t\t\t\t\tif (month == 11) {\n\t\t\t\t\t\t\t\t\tmonth = 0;\n\t\t\t\t\t\t\t\t\tyear += 1;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmonth += 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis._setDate(UTCDate(year, month, day,0,0,0,0));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_setDate: function(date, which){\n\t\t\tif (!which || which == 'date')\n\t\t\t\tthis.date = new Date(date);\n\t\t\tif (!which || which  == 'view')\n\t\t\t\tthis.viewDate = new Date(date);\n\t\t\tthis.fill();\n\t\t\tthis.setValue();\n\t\t\tthis._trigger('changeDate');\n\t\t\tvar element;\n\t\t\tif (this.isInput) {\n\t\t\t\telement = this.element;\n\t\t\t} else if (this.component){\n\t\t\t\telement = this.element.find('input');\n\t\t\t}\n\t\t\tif (element) {\n\t\t\t\telement.change();\n\t\t\t\tif (this.o.autoclose && (!which || which == 'date')) {\n\t\t\t\t\tthis.hide();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tmoveMonth: function(date, dir){\n\t\t\tif (!dir) return date;\n\t\t\tvar new_date = new Date(date.valueOf()),\n\t\t\t\tday = new_date.getUTCDate(),\n\t\t\t\tmonth = new_date.getUTCMonth(),\n\t\t\t\tmag = Math.abs(dir),\n\t\t\t\tnew_month, test;\n\t\t\tdir = dir > 0 ? 1 : -1;\n\t\t\tif (mag == 1){\n\t\t\t\ttest = dir == -1\n\t\t\t\t\t// If going back one month, make sure month is not current month\n\t\t\t\t\t// (eg, Mar 31 -> Feb 31 == Feb 28, not Mar 02)\n\t\t\t\t\t? function(){ return new_date.getUTCMonth() == month; }\n\t\t\t\t\t// If going forward one month, make sure month is as expected\n\t\t\t\t\t// (eg, Jan 31 -> Feb 31 == Feb 28, not Mar 02)\n\t\t\t\t\t: function(){ return new_date.getUTCMonth() != new_month; };\n\t\t\t\tnew_month = month + dir;\n\t\t\t\tnew_date.setUTCMonth(new_month);\n\t\t\t\t// Dec -> Jan (12) or Jan -> Dec (-1) -- limit expected date to 0-11\n\t\t\t\tif (new_month < 0 || new_month > 11)\n\t\t\t\t\tnew_month = (new_month + 12) % 12;\n\t\t\t} else {\n\t\t\t\t// For magnitudes >1, move one month at a time...\n\t\t\t\tfor (var i=0; i<mag; i++)\n\t\t\t\t\t// ...which might decrease the day (eg, Jan 31 to Feb 28, etc)...\n\t\t\t\t\tnew_date = this.moveMonth(new_date, dir);\n\t\t\t\t// ...then reset the day, keeping it in the new month\n\t\t\t\tnew_month = new_date.getUTCMonth();\n\t\t\t\tnew_date.setUTCDate(day);\n\t\t\t\ttest = function(){ return new_month != new_date.getUTCMonth(); };\n\t\t\t}\n\t\t\t// Common date-resetting loop -- if date is beyond end of month, make it\n\t\t\t// end of month\n\t\t\twhile (test()){\n\t\t\t\tnew_date.setUTCDate(--day);\n\t\t\t\tnew_date.setUTCMonth(new_month);\n\t\t\t}\n\t\t\treturn new_date;\n\t\t},\n\n\t\tmoveYear: function(date, dir){\n\t\t\treturn this.moveMonth(date, dir*12);\n\t\t},\n\n\t\tdateWithinRange: function(date){\n\t\t\treturn date >= this.o.startDate && date <= this.o.endDate;\n\t\t},\n\n\t\tkeydown: function(e){\n\t\t\tif (this.picker.is(':not(:visible)')){\n\t\t\t\tif (e.keyCode == 27) // allow escape to hide and re-show picker\n\t\t\t\t\tthis.show();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar dateChanged = false,\n\t\t\t\tdir, day, month,\n\t\t\t\tnewDate, newViewDate;\n\t\t\tswitch(e.keyCode){\n\t\t\t\tcase 27: // escape\n\t\t\t\t\tthis.hide();\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 37: // left\n\t\t\t\tcase 39: // right\n\t\t\t\t\tif (!this.o.keyboardNavigation) break;\n\t\t\t\t\tdir = e.keyCode == 37 ? -1 : 1;\n\t\t\t\t\tif (e.ctrlKey){\n\t\t\t\t\t\tnewDate = this.moveYear(this.date, dir);\n\t\t\t\t\t\tnewViewDate = this.moveYear(this.viewDate, dir);\n\t\t\t\t\t} else if (e.shiftKey){\n\t\t\t\t\t\tnewDate = this.moveMonth(this.date, dir);\n\t\t\t\t\t\tnewViewDate = this.moveMonth(this.viewDate, dir);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewDate = new Date(this.date);\n\t\t\t\t\t\tnewDate.setUTCDate(this.date.getUTCDate() + dir);\n\t\t\t\t\t\tnewViewDate = new Date(this.viewDate);\n\t\t\t\t\t\tnewViewDate.setUTCDate(this.viewDate.getUTCDate() + dir);\n\t\t\t\t\t}\n\t\t\t\t\tif (this.dateWithinRange(newDate)){\n\t\t\t\t\t\tthis.date = newDate;\n\t\t\t\t\t\tthis.viewDate = newViewDate;\n\t\t\t\t\t\tthis.setValue();\n\t\t\t\t\t\tthis.update();\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\tdateChanged = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 38: // up\n\t\t\t\tcase 40: // down\n\t\t\t\t\tif (!this.o.keyboardNavigation) break;\n\t\t\t\t\tdir = e.keyCode == 38 ? -1 : 1;\n\t\t\t\t\tif (e.ctrlKey){\n\t\t\t\t\t\tnewDate = this.moveYear(this.date, dir);\n\t\t\t\t\t\tnewViewDate = this.moveYear(this.viewDate, dir);\n\t\t\t\t\t} else if (e.shiftKey){\n\t\t\t\t\t\tnewDate = this.moveMonth(this.date, dir);\n\t\t\t\t\t\tnewViewDate = this.moveMonth(this.viewDate, dir);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewDate = new Date(this.date);\n\t\t\t\t\t\tnewDate.setUTCDate(this.date.getUTCDate() + dir * 7);\n\t\t\t\t\t\tnewViewDate = new Date(this.viewDate);\n\t\t\t\t\t\tnewViewDate.setUTCDate(this.viewDate.getUTCDate() + dir * 7);\n\t\t\t\t\t}\n\t\t\t\t\tif (this.dateWithinRange(newDate)){\n\t\t\t\t\t\tthis.date = newDate;\n\t\t\t\t\t\tthis.viewDate = newViewDate;\n\t\t\t\t\t\tthis.setValue();\n\t\t\t\t\t\tthis.update();\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\tdateChanged = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 13: // enter\n\t\t\t\t\tthis.hide();\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9: // tab\n\t\t\t\t\tthis.hide();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (dateChanged){\n\t\t\t\tthis._trigger('changeDate');\n\t\t\t\tvar element;\n\t\t\t\tif (this.isInput) {\n\t\t\t\t\telement = this.element;\n\t\t\t\t} else if (this.component){\n\t\t\t\t\telement = this.element.find('input');\n\t\t\t\t}\n\t\t\t\tif (element) {\n\t\t\t\t\telement.change();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tshowMode: function(dir) {\n\t\t\tif (dir) {\n\t\t\t\tthis.viewMode = Math.max(this.o.minViewMode, Math.min(2, this.viewMode + dir));\n\t\t\t}\n\t\t\t/*\n\t\t\t\tvitalets: fixing bug of very special conditions:\n\t\t\t\tjquery 1.7.1 + webkit + show inline datepicker in bootstrap popover.\n\t\t\t\tMethod show() does not set display css correctly and datepicker is not shown.\n\t\t\t\tChanged to .css('display', 'block') solve the problem.\n\t\t\t\tSee https://github.com/vitalets/x-editable/issues/37\n\n\t\t\t\tIn jquery 1.7.2+ everything works fine.\n\t\t\t*/\n\t\t\t//this.picker.find('>div').hide().filter('.datepicker-'+DPGlobal.modes[this.viewMode].clsName).show();\n\t\t\tthis.picker.find('>div').hide().filter('.datepicker-'+DPGlobal.modes[this.viewMode].clsName).css('display', 'block');\n\t\t\tthis.updateNavArrows();\n\t\t}\n\t};\n\n\tvar DateRangePicker = function(element, options){\n\t\tthis.element = $(element);\n\t\tthis.inputs = $.map(options.inputs, function(i){ return i.jquery ? i[0] : i; });\n\t\tdelete options.inputs;\n\n\t\t$(this.inputs)\n\t\t\t.datepicker(options)\n\t\t\t.bind('changeDate', $.proxy(this.dateUpdated, this));\n\n\t\tthis.pickers = $.map(this.inputs, function(i){ return $(i).data('datepicker'); });\n\t\tthis.updateDates();\n\t};\n\tDateRangePicker.prototype = {\n\t\tupdateDates: function(){\n\t\t\tthis.dates = $.map(this.pickers, function(i){ return i.date; });\n\t\t\tthis.updateRanges();\n\t\t},\n\t\tupdateRanges: function(){\n\t\t\tvar range = $.map(this.dates, function(d){ return d.valueOf(); });\n\t\t\t$.each(this.pickers, function(i, p){\n\t\t\t\tp.setRange(range);\n\t\t\t});\n\t\t},\n\t\tdateUpdated: function(e){\n\t\t\tvar dp = $(e.target).data('datepicker'),\n\t\t\t\tnew_date = dp.getUTCDate(),\n\t\t\t\ti = $.inArray(e.target, this.inputs),\n\t\t\t\tl = this.inputs.length;\n\t\t\tif (i == -1) return;\n\n\t\t\tif (new_date < this.dates[i]){\n\t\t\t\t// Date being moved earlier/left\n\t\t\t\twhile (i>=0 && new_date < this.dates[i]){\n\t\t\t\t\tthis.pickers[i--].setUTCDate(new_date);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (new_date > this.dates[i]){\n\t\t\t\t// Date being moved later/right\n\t\t\t\twhile (i<l && new_date > this.dates[i]){\n\t\t\t\t\tthis.pickers[i++].setUTCDate(new_date);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.updateDates();\n\t\t},\n\t\tremove: function(){\n\t\t\t$.map(this.pickers, function(p){ p.remove(); });\n\t\t\tdelete this.element.data().datepicker;\n\t\t}\n\t};\n\n\tfunction opts_from_el(el, prefix){\n\t\t// Derive options from element data-attrs\n\t\tvar data = $(el).data(),\n\t\t\tout = {}, inkey,\n\t\t\treplace = new RegExp('^' + prefix.toLowerCase() + '([A-Z])'),\n\t\t\tprefix = new RegExp('^' + prefix.toLowerCase());\n\t\tfor (var key in data)\n\t\t\tif (prefix.test(key)){\n\t\t\t\tinkey = key.replace(replace, function(_,a){ return a.toLowerCase(); });\n\t\t\t\tout[inkey] = data[key];\n\t\t\t}\n\t\treturn out;\n\t}\n\n\tfunction opts_from_locale(lang){\n\t\t// Derive options from locale plugins\n\t\tvar out = {};\n\t\t// Check if \"de-DE\" style date is available, if not language should\n\t\t// fallback to 2 letter code eg \"de\"\n\t\tif (!dates[lang]) {\n\t\t\tlang = lang.split('-')[0]\n\t\t\tif (!dates[lang])\n\t\t\t\treturn;\n\t\t}\n\t\tvar d = dates[lang];\n\t\t$.each(locale_opts, function(i,k){\n\t\t\tif (k in d)\n\t\t\t\tout[k] = d[k];\n\t\t});\n\t\treturn out;\n\t}\n\n\tvar old = $.fn.datepicker;\n\tvar datepicker = $.fn.datepicker = function ( option ) {\n\t\tvar args = Array.apply(null, arguments);\n\t\targs.shift();\n\t\tvar internal_return,\n\t\t\tthis_return;\n\t\tthis.each(function () {\n\t\t\tvar $this = $(this),\n\t\t\t\tdata = $this.data('datepicker'),\n\t\t\t\toptions = typeof option == 'object' && option;\n\t\t\tif (!data) {\n\t\t\t\tvar elopts = opts_from_el(this, 'date'),\n\t\t\t\t\t// Preliminary otions\n\t\t\t\t\txopts = $.extend({}, defaults, elopts, options),\n\t\t\t\t\tlocopts = opts_from_locale(xopts.language),\n\t\t\t\t\t// Options priority: js args, data-attrs, locales, defaults\n\t\t\t\t\topts = $.extend({}, defaults, locopts, elopts, options);\n\t\t\t\tif ($this.is('.input-daterange') || opts.inputs){\n\t\t\t\t\tvar ropts = {\n\t\t\t\t\t\tinputs: opts.inputs || $this.find('input').toArray()\n\t\t\t\t\t};\n\t\t\t\t\t$this.data('datepicker', (data = new DateRangePicker(this, $.extend(opts, ropts))));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t$this.data('datepicker', (data = new Datepicker(this, opts)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (typeof option == 'string' && typeof data[option] == 'function') {\n\t\t\t\tinternal_return = data[option].apply(data, args);\n\t\t\t\tif (internal_return !== undefined)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\tif (internal_return !== undefined)\n\t\t\treturn internal_return;\n\t\telse\n\t\t\treturn this;\n\t};\n\n\tvar defaults = $.fn.datepicker.defaults = {\n\t\tautoclose: false,\n\t\tbeforeShowDay: $.noop,\n\t\tcalendarWeeks: false,\n\t\tclearBtn: false,\n\t\tdaysOfWeekDisabled: [],\n\t\tendDate: Infinity,\n\t\tforceParse: true,\n\t\tformat: 'mm/dd/yyyy',\n\t\tkeyboardNavigation: true,\n\t\tlanguage: 'en',\n\t\tminViewMode: 0,\n\t\trtl: false,\n\t\tstartDate: -Infinity,\n\t\tstartView: 0,\n\t\ttodayBtn: false,\n\t\ttodayHighlight: false,\n\t\tweekStart: 0\n\t};\n\tvar locale_opts = $.fn.datepicker.locale_opts = [\n\t\t'format',\n\t\t'rtl',\n\t\t'weekStart'\n\t];\n\t$.fn.datepicker.Constructor = Datepicker;\n\tvar dates = $.fn.datepicker.dates = {\n\t\ten: {\n\t\t\tdays: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"],\n\t\t\tdaysShort: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"],\n\t\t\tdaysMin: [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\", \"Su\"],\n\t\t\tmonths: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n\t\t\tmonthsShort: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n\t\t\ttoday: \"Today\",\n\t\t\tclear: \"Clear\"\n\t\t}\n\t};\n\n\tvar DPGlobal = {\n\t\tmodes: [\n\t\t\t{\n\t\t\t\tclsName: 'days',\n\t\t\t\tnavFnc: 'Month',\n\t\t\t\tnavStep: 1\n\t\t\t},\n\t\t\t{\n\t\t\t\tclsName: 'months',\n\t\t\t\tnavFnc: 'FullYear',\n\t\t\t\tnavStep: 1\n\t\t\t},\n\t\t\t{\n\t\t\t\tclsName: 'years',\n\t\t\t\tnavFnc: 'FullYear',\n\t\t\t\tnavStep: 10\n\t\t}],\n\t\tisLeapYear: function (year) {\n\t\t\treturn (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0));\n\t\t},\n\t\tgetDaysInMonth: function (year, month) {\n\t\t\treturn [31, (DPGlobal.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];\n\t\t},\n\t\tvalidParts: /dd?|DD?|mm?|MM?|yy(?:yy)?/g,\n\t\tnonpunctuation: /[^ -\\/:-@\\[\\u3400-\\u9fff-`{-~\\t\\n\\r]+/g,\n\t\tparseFormat: function(format){\n\t\t\t// IE treats \\0 as a string end in inputs (truncating the value),\n\t\t\t// so it's a bad format delimiter, anyway\n\t\t\tvar separators = format.replace(this.validParts, '\\0').split('\\0'),\n\t\t\t\tparts = format.match(this.validParts);\n\t\t\tif (!separators || !separators.length || !parts || parts.length === 0){\n\t\t\t\tthrow new Error(\"Invalid date format.\");\n\t\t\t}\n\t\t\treturn {separators: separators, parts: parts};\n\t\t},\n\t\tparseDate: function(date, format, language) {\n\t\t\tif (date instanceof Date) return date;\n\t\t\tif (typeof format === 'string')\n\t\t\t\tformat = DPGlobal.parseFormat(format);\n\t\t\tif (/^[\\-+]\\d+[dmwy]([\\s,]+[\\-+]\\d+[dmwy])*$/.test(date)) {\n\t\t\t\tvar part_re = /([\\-+]\\d+)([dmwy])/,\n\t\t\t\t\tparts = date.match(/([\\-+]\\d+)([dmwy])/g),\n\t\t\t\t\tpart, dir;\n\t\t\t\tdate = new Date();\n\t\t\t\tfor (var i=0; i<parts.length; i++) {\n\t\t\t\t\tpart = part_re.exec(parts[i]);\n\t\t\t\t\tdir = parseInt(part[1]);\n\t\t\t\t\tswitch(part[2]){\n\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\tdate.setUTCDate(date.getUTCDate() + dir);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'm':\n\t\t\t\t\t\t\tdate = Datepicker.prototype.moveMonth.call(Datepicker.prototype, date, dir);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'w':\n\t\t\t\t\t\t\tdate.setUTCDate(date.getUTCDate() + dir * 7);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'y':\n\t\t\t\t\t\t\tdate = Datepicker.prototype.moveYear.call(Datepicker.prototype, date, dir);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn UTCDate(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 0, 0, 0);\n\t\t\t}\n\t\t\tvar parts = date && date.match(this.nonpunctuation) || [],\n\t\t\t\tdate = new Date(),\n\t\t\t\tparsed = {},\n\t\t\t\tsetters_order = ['yyyy', 'yy', 'M', 'MM', 'm', 'mm', 'd', 'dd'],\n\t\t\t\tsetters_map = {\n\t\t\t\t\tyyyy: function(d,v){ return d.setUTCFullYear(v); },\n\t\t\t\t\tyy: function(d,v){ return d.setUTCFullYear(2000+v); },\n\t\t\t\t\tm: function(d,v){\n\t\t\t\t\t\tv -= 1;\n\t\t\t\t\t\twhile (v<0) v += 12;\n\t\t\t\t\t\tv %= 12;\n\t\t\t\t\t\td.setUTCMonth(v);\n\t\t\t\t\t\twhile (d.getUTCMonth() != v)\n\t\t\t\t\t\t\td.setUTCDate(d.getUTCDate()-1);\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t},\n\t\t\t\t\td: function(d,v){ return d.setUTCDate(v); }\n\t\t\t\t},\n\t\t\t\tval, filtered, part;\n\t\t\tsetters_map['M'] = setters_map['MM'] = setters_map['mm'] = setters_map['m'];\n\t\t\tsetters_map['dd'] = setters_map['d'];\n\t\t\tdate = UTCDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);\n\t\t\tvar fparts = format.parts.slice();\n\t\t\t// Remove noop parts\n\t\t\tif (parts.length != fparts.length) {\n\t\t\t\tfparts = $(fparts).filter(function(i,p){\n\t\t\t\t\treturn $.inArray(p, setters_order) !== -1;\n\t\t\t\t}).toArray();\n\t\t\t}\n\t\t\t// Process remainder\n\t\t\tif (parts.length == fparts.length) {\n\t\t\t\tfor (var i=0, cnt = fparts.length; i < cnt; i++) {\n\t\t\t\t\tval = parseInt(parts[i], 10);\n\t\t\t\t\tpart = fparts[i];\n\t\t\t\t\tif (isNaN(val)) {\n\t\t\t\t\t\tswitch(part) {\n\t\t\t\t\t\t\tcase 'MM':\n\t\t\t\t\t\t\t\tfiltered = $(dates[language].months).filter(function(){\n\t\t\t\t\t\t\t\t\tvar m = this.slice(0, parts[i].length),\n\t\t\t\t\t\t\t\t\t\tp = parts[i].slice(0, m.length);\n\t\t\t\t\t\t\t\t\treturn m == p;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tval = $.inArray(filtered[0], dates[language].months) + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'M':\n\t\t\t\t\t\t\t\tfiltered = $(dates[language].monthsShort).filter(function(){\n\t\t\t\t\t\t\t\t\tvar m = this.slice(0, parts[i].length),\n\t\t\t\t\t\t\t\t\t\tp = parts[i].slice(0, m.length);\n\t\t\t\t\t\t\t\t\treturn m == p;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tval = $.inArray(filtered[0], dates[language].monthsShort) + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tparsed[part] = val;\n\t\t\t\t}\n\t\t\t\tfor (var i=0, s; i<setters_order.length; i++){\n\t\t\t\t\ts = setters_order[i];\n\t\t\t\t\tif (s in parsed && !isNaN(parsed[s]))\n\t\t\t\t\t\tsetters_map[s](date, parsed[s]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn date;\n\t\t},\n\t\tformatDate: function(date, format, language){\n\t\t\tif (typeof format === 'string')\n\t\t\t\tformat = DPGlobal.parseFormat(format);\n\t\t\tvar val = {\n\t\t\t\td: date.getUTCDate(),\n\t\t\t\tD: dates[language].daysShort[date.getUTCDay()],\n\t\t\t\tDD: dates[language].days[date.getUTCDay()],\n\t\t\t\tm: date.getUTCMonth() + 1,\n\t\t\t\tM: dates[language].monthsShort[date.getUTCMonth()],\n\t\t\t\tMM: dates[language].months[date.getUTCMonth()],\n\t\t\t\tyy: date.getUTCFullYear().toString().substring(2),\n\t\t\t\tyyyy: date.getUTCFullYear()\n\t\t\t};\n\t\t\tval.dd = (val.d < 10 ? '0' : '') + val.d;\n\t\t\tval.mm = (val.m < 10 ? '0' : '') + val.m;\n\t\t\tvar date = [],\n\t\t\t\tseps = $.extend([], format.separators);\n\t\t\tfor (var i=0, cnt = format.parts.length; i <= cnt; i++) {\n\t\t\t\tif (seps.length)\n\t\t\t\t\tdate.push(seps.shift());\n\t\t\t\tdate.push(val[format.parts[i]]);\n\t\t\t}\n\t\t\treturn date.join('');\n\t\t},\n\t\theadTemplate: '<thead>'+\n\t\t\t\t\t\t\t'<tr>'+\n\t\t\t\t\t\t\t\t'<th class=\"prev\"><i class=\"icon-arrow-left\"/></th>'+\n\t\t\t\t\t\t\t\t'<th colspan=\"5\" class=\"datepicker-switch\"></th>'+\n\t\t\t\t\t\t\t\t'<th class=\"next\"><i class=\"icon-arrow-right\"/></th>'+\n\t\t\t\t\t\t\t'</tr>'+\n\t\t\t\t\t\t'</thead>',\n\t\tcontTemplate: '<tbody><tr><td colspan=\"7\"></td></tr></tbody>',\n\t\tfootTemplate: '<tfoot><tr><th colspan=\"7\" class=\"today\"></th></tr><tr><th colspan=\"7\" class=\"clear\"></th></tr></tfoot>'\n\t};\n\tDPGlobal.template = '<div class=\"datepicker\">'+\n\t\t\t\t\t\t\t'<div class=\"datepicker-days\">'+\n\t\t\t\t\t\t\t\t'<table class=\" table-condensed\">'+\n\t\t\t\t\t\t\t\t\tDPGlobal.headTemplate+\n\t\t\t\t\t\t\t\t\t'<tbody></tbody>'+\n\t\t\t\t\t\t\t\t\tDPGlobal.footTemplate+\n\t\t\t\t\t\t\t\t'</table>'+\n\t\t\t\t\t\t\t'</div>'+\n\t\t\t\t\t\t\t'<div class=\"datepicker-months\">'+\n\t\t\t\t\t\t\t\t'<table class=\"table-condensed\">'+\n\t\t\t\t\t\t\t\t\tDPGlobal.headTemplate+\n\t\t\t\t\t\t\t\t\tDPGlobal.contTemplate+\n\t\t\t\t\t\t\t\t\tDPGlobal.footTemplate+\n\t\t\t\t\t\t\t\t'</table>'+\n\t\t\t\t\t\t\t'</div>'+\n\t\t\t\t\t\t\t'<div class=\"datepicker-years\">'+\n\t\t\t\t\t\t\t\t'<table class=\"table-condensed\">'+\n\t\t\t\t\t\t\t\t\tDPGlobal.headTemplate+\n\t\t\t\t\t\t\t\t\tDPGlobal.contTemplate+\n\t\t\t\t\t\t\t\t\tDPGlobal.footTemplate+\n\t\t\t\t\t\t\t\t'</table>'+\n\t\t\t\t\t\t\t'</div>'+\n\t\t\t\t\t\t'</div>';\n\n\t$.fn.datepicker.DPGlobal = DPGlobal;\n\n\n\t/* DATEPICKER NO CONFLICT\n\t* =================== */\n\n\t$.fn.datepicker.noConflict = function(){\n\t\t$.fn.datepicker = old;\n\t\treturn this;\n\t};\n\n\n\t/* DATEPICKER DATA-API\n\t* ================== */\n\n\t$(document).on(\n\t\t'focus.datepicker.data-api click.datepicker.data-api',\n\t\t'[data-provide=\"datepicker\"]',\n\t\tfunction(e){\n\t\t\tvar $this = $(this);\n\t\t\tif ($this.data('datepicker')) return;\n\t\t\te.preventDefault();\n\t\t\t// component click requires us to explicitly show it\n\t\t\tdatepicker.call($this, 'show');\n\t\t}\n\t);\n\t$(function(){\n\t\t//$('[data-provide=\"datepicker-inline\"]').datepicker();\n        //vit: changed to support noConflict()\n        datepicker.call($('[data-provide=\"datepicker-inline\"]'));\n\t});\n\n}( window.jQuery ));\n\n/**\nBootstrap-datepicker.  \nDescription and examples: https://github.com/eternicode/bootstrap-datepicker.  \nFor **i18n** you should include js file from here: https://github.com/eternicode/bootstrap-datepicker/tree/master/js/locales\nand set `language` option.  \nSince 1.4.0 date has different appearance in **popup** and **inline** modes. \n\n@class date\n@extends abstractinput\n@final\n@example\n<a href=\"#\" id=\"dob\" data-type=\"date\" data-pk=\"1\" data-url=\"/post\" data-title=\"Select date\">15/05/1984</a>\n<script>\n$(function(){\n    $('#dob').editable({\n        format: 'yyyy-mm-dd',    \n        viewformat: 'dd/mm/yyyy',    \n        datepicker: {\n                weekStart: 1\n           }\n        }\n    });\n});\n</script>\n**/\n(function ($) {\n    \"use strict\";\n    \n    //store bootstrap-datepicker as bdateicker to exclude conflict with jQuery UI one\n    $.fn.bdatepicker = $.fn.datepicker.noConflict();\n    if(!$.fn.datepicker) { //if there were no other datepickers, keep also original name\n        $.fn.datepicker = $.fn.bdatepicker;    \n    }    \n    \n    var Date = function (options) {\n        this.init('date', options, Date.defaults);\n        this.initPicker(options, Date.defaults);\n    };\n\n    $.fn.editableutils.inherit(Date, $.fn.editabletypes.abstractinput);    \n    \n    $.extend(Date.prototype, {\n        initPicker: function(options, defaults) {\n            //'format' is set directly from settings or data-* attributes\n\n            //by default viewformat equals to format\n            if(!this.options.viewformat) {\n                this.options.viewformat = this.options.format;\n            }\n            \n            //try parse datepicker config defined as json string in data-datepicker\n            options.datepicker = $.fn.editableutils.tryParseJson(options.datepicker, true);\n            \n            //overriding datepicker config (as by default jQuery extend() is not recursive)\n            //since 1.4 datepicker internally uses viewformat instead of format. Format is for submit only\n            this.options.datepicker = $.extend({}, defaults.datepicker, options.datepicker, {\n                format: this.options.viewformat\n            });\n            \n            //language\n            this.options.datepicker.language = this.options.datepicker.language || 'en'; \n\n            //store DPglobal\n            this.dpg = $.fn.bdatepicker.DPGlobal; \n\n            //store parsed formats\n            this.parsedFormat = this.dpg.parseFormat(this.options.format);\n            this.parsedViewFormat = this.dpg.parseFormat(this.options.viewformat);            \n        },\n        \n        render: function () {\n            this.$input.bdatepicker(this.options.datepicker);\n            \n            //\"clear\" link\n            if(this.options.clear) {\n                this.$clear = $('<a href=\"#\"></a>').html(this.options.clear).click($.proxy(function(e){\n                    e.preventDefault();\n                    e.stopPropagation();\n                    this.clear();\n                }, this));\n                \n                this.$tpl.parent().append($('<div class=\"editable-clear\">').append(this.$clear));  \n            }                \n        },\n        \n        value2html: function(value, element) {\n           var text = value ? this.dpg.formatDate(value, this.parsedViewFormat, this.options.datepicker.language) : '';\n           Date.superclass.value2html.call(this, text, element); \n        },\n\n        html2value: function(html) {\n            return this.parseDate(html, this.parsedViewFormat);\n        },   \n\n        value2str: function(value) {\n            return value ? this.dpg.formatDate(value, this.parsedFormat, this.options.datepicker.language) : '';\n        }, \n\n        str2value: function(str) {\n            return this.parseDate(str, this.parsedFormat);\n        }, \n\n        value2submit: function(value) {\n            return this.value2str(value);\n        },                    \n\n        value2input: function(value) {\n            this.$input.bdatepicker('update', value);\n        },\n\n        input2value: function() { \n            return this.$input.data('datepicker').date;\n        },       \n\n        activate: function() {\n        },\n\n        clear:  function() {\n            this.$input.data('datepicker').date = null;\n            this.$input.find('.active').removeClass('active');\n            if(!this.options.showbuttons) {\n                this.$input.closest('form').submit(); \n            }\n        },\n\n        autosubmit: function() {\n            this.$input.on('mouseup', '.day', function(e){\n                if($(e.currentTarget).is('.old') || $(e.currentTarget).is('.new')) {\n                    return;\n                }\n                var $form = $(this).closest('form');\n                setTimeout(function() {\n                    $form.submit();\n                }, 200);\n            });\n           //changedate is not suitable as it triggered when showing datepicker. see #149\n           /*\n           this.$input.on('changeDate', function(e){\n               var $form = $(this).closest('form');\n               setTimeout(function() {\n                   $form.submit();\n               }, 200);\n           });\n           */\n       },\n       \n       /*\n        For incorrect date bootstrap-datepicker returns current date that is not suitable\n        for datefield.\n        This function returns null for incorrect date.  \n       */\n       parseDate: function(str, format) {\n           var date = null, formattedBack;\n           if(str) {\n               date = this.dpg.parseDate(str, format, this.options.datepicker.language);\n               if(typeof str === 'string') {\n                   formattedBack = this.dpg.formatDate(date, format, this.options.datepicker.language);\n                   if(str !== formattedBack) {\n                       date = null;\n                   }\n               }\n           }\n           return date;\n       }\n\n    });\n\n    Date.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <div></div>\n        **/         \n        tpl:'<div class=\"editable-date well\"></div>',\n        /**\n        @property inputclass \n        @default null\n        **/\n        inputclass: null,\n        /**\n        Format used for sending value to server. Also applied when converting date from <code>data-value</code> attribute.<br>\n        Possible tokens are: <code>d, dd, m, mm, yy, yyyy</code>  \n\n        @property format \n        @type string\n        @default yyyy-mm-dd\n        **/\n        format:'yyyy-mm-dd',\n        /**\n        Format used for displaying date. Also applied when converting date from element's text on init.   \n        If not specified equals to <code>format</code>\n\n        @property viewformat \n        @type string\n        @default null\n        **/\n        viewformat: null,\n        /**\n        Configuration of datepicker.\n        Full list of options: http://bootstrap-datepicker.readthedocs.org/en/latest/options.html\n\n        @property datepicker \n        @type object\n        @default {\n            weekStart: 0,\n            startView: 0,\n            minViewMode: 0,\n            autoclose: false\n        }\n        **/\n        datepicker:{\n            weekStart: 0,\n            startView: 0,\n            minViewMode: 0,\n            autoclose: false\n        },\n        /**\n        Text shown as clear date button. \n        If <code>false</code> clear button will not be rendered.\n\n        @property clear \n        @type boolean|string\n        @default 'x clear'\n        **/\n        clear: '&times; clear'\n    });\n\n    $.fn.editabletypes.date = Date;\n\n}(window.jQuery));\n\n/**\nBootstrap datefield input - modification for inline mode.\nShows normal <input type=\"text\"> and binds popup datepicker.  \nAutomatically shown in inline mode.\n\n@class datefield\n@extends date\n\n@since 1.4.0\n**/\n(function ($) {\n    \"use strict\";\n    \n    var DateField = function (options) {\n        this.init('datefield', options, DateField.defaults);\n        this.initPicker(options, DateField.defaults);\n    };\n\n    $.fn.editableutils.inherit(DateField, $.fn.editabletypes.date);    \n    \n    $.extend(DateField.prototype, {\n        render: function () {\n            this.$input = this.$tpl.find('input');\n            this.setClass();\n            this.setAttr('placeholder');\n    \n            //bootstrap-datepicker is set `bdateicker` to exclude conflict with jQuery UI one. (in date.js)        \n            this.$tpl.bdatepicker(this.options.datepicker);\n            \n            //need to disable original event handlers\n            this.$input.off('focus keydown');\n            \n            //update value of datepicker\n            this.$input.keyup($.proxy(function(){\n               this.$tpl.removeData('date');\n               this.$tpl.bdatepicker('update');\n            }, this));\n            \n        },   \n        \n       value2input: function(value) {\n           this.$input.val(value ? this.dpg.formatDate(value, this.parsedViewFormat, this.options.datepicker.language) : '');\n           this.$tpl.bdatepicker('update');\n       },\n        \n       input2value: function() { \n           return this.html2value(this.$input.val());\n       },              \n        \n       activate: function() {\n           $.fn.editabletypes.text.prototype.activate.call(this);\n       },\n       \n       autosubmit: function() {\n         //reset autosubmit to empty  \n       }\n    });\n    \n    DateField.defaults = $.extend({}, $.fn.editabletypes.date.defaults, {\n        /**\n        @property tpl \n        **/         \n        tpl:'<div class=\"input-append date\"><input type=\"text\"/><span class=\"add-on\"><i class=\"icon-th\"></i></span></div>',\n        /**\n        @property inputclass \n        @default 'input-small'\n        **/         \n        inputclass: 'input-small',\n        \n        /* datepicker config */\n        datepicker: {\n            weekStart: 0,\n            startView: 0,\n            minViewMode: 0,\n            autoclose: true\n        }\n    });\n    \n    $.fn.editabletypes.datefield = DateField;\n\n}(window.jQuery));\n/**\nBootstrap-datetimepicker.  \nBased on [smalot bootstrap-datetimepicker plugin](https://github.com/smalot/bootstrap-datetimepicker). \nBefore usage you should manually include dependent js and css:\n\n    <link href=\"css/datetimepicker.css\" rel=\"stylesheet\" type=\"text/css\"></link> \n    <script src=\"js/bootstrap-datetimepicker.js\"></script>\n\nFor **i18n** you should include js file from here: https://github.com/smalot/bootstrap-datetimepicker/tree/master/js/locales\nand set `language` option.  \n\n@class datetime\n@extends abstractinput\n@final\n@since 1.4.4\n@example\n<a href=\"#\" id=\"last_seen\" data-type=\"datetime\" data-pk=\"1\" data-url=\"/post\" title=\"Select date & time\">15/03/2013 12:45</a>\n<script>\n$(function(){\n    $('#last_seen').editable({\n        format: 'yyyy-mm-dd hh:ii',    \n        viewformat: 'dd/mm/yyyy hh:ii',    \n        datetimepicker: {\n                weekStart: 1\n           }\n        }\n    });\n});\n</script>\n**/\n(function ($) {\n    \"use strict\";\n\n    var DateTime = function (options) {\n        this.init('datetime', options, DateTime.defaults);\n        this.initPicker(options, DateTime.defaults);\n    };\n\n    $.fn.editableutils.inherit(DateTime, $.fn.editabletypes.abstractinput);\n\n    $.extend(DateTime.prototype, {\n        initPicker: function(options, defaults) {\n            //'format' is set directly from settings or data-* attributes\n\n            //by default viewformat equals to format\n            if(!this.options.viewformat) {\n                this.options.viewformat = this.options.format;\n            }\n            \n            //try parse datetimepicker config defined as json string in data-datetimepicker\n            options.datetimepicker = $.fn.editableutils.tryParseJson(options.datetimepicker, true);\n\n            //overriding datetimepicker config (as by default jQuery extend() is not recursive)\n            //since 1.4 datetimepicker internally uses viewformat instead of format. Format is for submit only\n            this.options.datetimepicker = $.extend({}, defaults.datetimepicker, options.datetimepicker, {\n                format: this.options.viewformat\n            });\n\n            //language\n            this.options.datetimepicker.language = this.options.datetimepicker.language || 'en'; \n\n            //store DPglobal\n            this.dpg = $.fn.datetimepicker.DPGlobal; \n\n            //store parsed formats\n            this.parsedFormat = this.dpg.parseFormat(this.options.format, this.options.formatType);\n            this.parsedViewFormat = this.dpg.parseFormat(this.options.viewformat, this.options.formatType);\n        },\n\n        render: function () {\n            this.$input.datetimepicker(this.options.datetimepicker);\n\n            //adjust container position when viewMode changes\n            //see https://github.com/smalot/bootstrap-datetimepicker/pull/80\n            this.$input.on('changeMode', function(e) {\n                var f = $(this).closest('form').parent();\n                //timeout here, otherwise container changes position before form has new size\n                setTimeout(function(){\n                    f.triggerHandler('resize');\n                }, 0);\n            });\n\n            //\"clear\" link\n            if(this.options.clear) {\n                this.$clear = $('<a href=\"#\"></a>').html(this.options.clear).click($.proxy(function(e){\n                    e.preventDefault();\n                    e.stopPropagation();\n                    this.clear();\n                }, this));\n\n                this.$tpl.parent().append($('<div class=\"editable-clear\">').append(this.$clear));  \n            }\n        },\n\n        value2html: function(value, element) {\n            //formatDate works with UTCDate!\n            var text = value ? this.dpg.formatDate(this.toUTC(value), this.parsedViewFormat, this.options.datetimepicker.language, this.options.formatType) : '';\n            if(element) {\n                DateTime.superclass.value2html.call(this, text, element);\n            } else {\n                return text;\n            }\n        },\n\n        html2value: function(html) {\n            //parseDate return utc date!\n            var value = this.parseDate(html, this.parsedViewFormat); \n            return value ? this.fromUTC(value) : null;\n        },\n\n        value2str: function(value) {\n            //formatDate works with UTCDate!\n            return value ? this.dpg.formatDate(this.toUTC(value), this.parsedFormat, this.options.datetimepicker.language, this.options.formatType) : '';\n       },\n\n       str2value: function(str) {\n           //parseDate return utc date!\n           var value = this.parseDate(str, this.parsedFormat);\n           return value ? this.fromUTC(value) : null;\n       },\n\n       value2submit: function(value) {\n           return this.value2str(value);\n       },\n\n       value2input: function(value) {\n           if(value) {\n             this.$input.data('datetimepicker').setDate(value);\n           }\n       },\n\n       input2value: function() { \n           //date may be cleared, in that case getDate() triggers error\n           var dt = this.$input.data('datetimepicker');\n           return dt.date ? dt.getDate() : null;\n       },\n\n       activate: function() {\n       },\n\n       clear: function() {\n          this.$input.data('datetimepicker').date = null;\n          this.$input.find('.active').removeClass('active');\n          if(!this.options.showbuttons) {\n             this.$input.closest('form').submit(); \n          }          \n       },\n\n       autosubmit: function() {\n           this.$input.on('mouseup', '.minute', function(e){\n               var $form = $(this).closest('form');\n               setTimeout(function() {\n                   $form.submit();\n               }, 200);\n           });\n       },\n\n       //convert date from local to utc\n       toUTC: function(value) {\n         return value ? new Date(value.valueOf() - value.getTimezoneOffset() * 60000) : value;  \n       },\n\n       //convert date from utc to local\n       fromUTC: function(value) {\n         return value ? new Date(value.valueOf() + value.getTimezoneOffset() * 60000) : value;  \n       },\n\n       /*\n        For incorrect date bootstrap-datetimepicker returns current date that is not suitable\n        for datetimefield.\n        This function returns null for incorrect date.  \n       */\n       parseDate: function(str, format) {\n           var date = null, formattedBack;\n           if(str) {\n               date = this.dpg.parseDate(str, format, this.options.datetimepicker.language, this.options.formatType);\n               if(typeof str === 'string') {\n                   formattedBack = this.dpg.formatDate(date, format, this.options.datetimepicker.language, this.options.formatType);\n                   if(str !== formattedBack) {\n                       date = null;\n                   } \n               }\n           }\n           return date;\n       }\n\n    });\n\n    DateTime.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <div></div>\n        **/         \n        tpl:'<div class=\"editable-date well\"></div>',\n        /**\n        @property inputclass \n        @default null\n        **/\n        inputclass: null,\n        /**\n        Format used for sending value to server. Also applied when converting date from <code>data-value</code> attribute.<br>\n        Possible tokens are: <code>d, dd, m, mm, yy, yyyy, h, i</code>  \n        \n        @property format \n        @type string\n        @default yyyy-mm-dd hh:ii\n        **/         \n        format:'yyyy-mm-dd hh:ii',\n        formatType:'standard',\n        /**\n        Format used for displaying date. Also applied when converting date from element's text on init.   \n        If not specified equals to <code>format</code>\n        \n        @property viewformat \n        @type string\n        @default null\n        **/\n        viewformat: null,\n        /**\n        Configuration of datetimepicker.\n        Full list of options: https://github.com/smalot/bootstrap-datetimepicker\n\n        @property datetimepicker \n        @type object\n        @default { }\n        **/\n        datetimepicker:{\n            todayHighlight: false,\n            autoclose: false\n        },\n        /**\n        Text shown as clear date button. \n        If <code>false</code> clear button will not be rendered.\n\n        @property clear \n        @type boolean|string\n        @default 'x clear'\n        **/\n        clear: '&times; clear'\n    });\n\n    $.fn.editabletypes.datetime = DateTime;\n\n}(window.jQuery));\n/**\nBootstrap datetimefield input - datetime input for inline mode.\nShows normal <input type=\"text\"> and binds popup datetimepicker.  \nAutomatically shown in inline mode.\n\n@class datetimefield\n@extends datetime\n\n**/\n(function ($) {\n    \"use strict\";\n    \n    var DateTimeField = function (options) {\n        this.init('datetimefield', options, DateTimeField.defaults);\n        this.initPicker(options, DateTimeField.defaults);\n    };\n\n    $.fn.editableutils.inherit(DateTimeField, $.fn.editabletypes.datetime);\n    \n    $.extend(DateTimeField.prototype, {\n        render: function () {\n            this.$input = this.$tpl.find('input');\n            this.setClass();\n            this.setAttr('placeholder');\n            \n            this.$tpl.datetimepicker(this.options.datetimepicker);\n            \n            //need to disable original event handlers\n            this.$input.off('focus keydown');\n            \n            //update value of datepicker\n            this.$input.keyup($.proxy(function(){\n               this.$tpl.removeData('date');\n               this.$tpl.datetimepicker('update');\n            }, this));\n            \n        },   \n      \n       value2input: function(value) {\n           this.$input.val(this.value2html(value));\n           this.$tpl.datetimepicker('update');\n       },\n        \n       input2value: function() { \n           return this.html2value(this.$input.val());\n       },              \n        \n       activate: function() {\n           $.fn.editabletypes.text.prototype.activate.call(this);\n       },\n       \n       autosubmit: function() {\n         //reset autosubmit to empty  \n       }\n    });\n    \n    DateTimeField.defaults = $.extend({}, $.fn.editabletypes.datetime.defaults, {\n        /**\n        @property tpl \n        **/         \n        tpl:'<div class=\"input-append date\"><input type=\"text\"/><span class=\"add-on\"><i class=\"icon-th\"></i></span></div>',\n        /**\n        @property inputclass \n        @default 'input-medium'\n        **/         \n        inputclass: 'input-medium',\n        \n        /* datetimepicker config */\n        datetimepicker:{\n            todayHighlight: false,\n            autoclose: true\n        }\n    });\n    \n    $.fn.editabletypes.datetimefield = DateTimeField;\n\n}(window.jQuery));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9Nb2R1bGVzL1RyYW5zbGF0aW9uL25vZGVfbW9kdWxlcy94LWVkaXRhYmxlL2Rpc3QvYm9vdHN0cmFwMy1lZGl0YWJsZS9qcy9ib290c3RyYXAtZWRpdGFibGUuanM/NDUwZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0U7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHVEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsK0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9CQUFvQixFQUFFO0FBQ3hFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0EscUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULDRCO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTs7QUFFYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFO0FBQ0E7QUFDQSxTOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0EsYTtBQUNBLFNBQVM7QUFDVCxNOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE07O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSw0QjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUztBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTO0FBQ0EsS0FBSzs7QUFFTCxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvRjtBQUNsQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEO0FBQ0E7QUFDQTtBQUNBLHVCO0FBQ0EsYTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUNBQWlDO0FBQ3JFO0FBQ0EsK0Y7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLG1EQUFtRDtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixrQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUIsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUztBQUNaLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkc7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLDJFO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEO0FBQ0EseUQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUM7QUFDQSx3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTztBQUNiLCtCO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDO0FBQ0EsZ0JBQWdCLFM7QUFDaEI7QUFDQTs7QUFFQTtBQUNBLHNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUU7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSx5RTtBQUNBLGFBQWE7QUFDYjtBQUNBLGE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQjtBQUNBLGdDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEQ7QUFDQSw2RDtBQUNBLHlJOztBQUVBO0FBQ0EseUU7QUFDQSxpQkFBaUI7QUFDakIsc0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE1BQU07QUFDMUIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUM7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLFNBQVM7QUFDN0Isb0JBQW9CLFNBQVM7QUFDN0Isc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrRztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHFIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQiwrRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCO0FBQ0EscUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0EsNEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUI7QUFDQSxhOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0M7QUFDQSxhO0FBQ0EsU0FBUztBQUNULE07OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZUFBZTtBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyw4Q0FBOEMsRUFBRTtBQUMvRjtBQUNBLFlBQVk7QUFDWiwrQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsbUNBQW1DO0FBQ25DLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0IsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBLDZCO0FBQ0E7QUFDQSw2RDtBQUNBLFk7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLFk7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsNkJBQTZCOztBQUUvRCxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxTQUFTOztBQUVUO0FBQ0Esd0JBQXdCO0FBQ3hCLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQztBQUNBLGFBQWE7QUFDYix3REFBd0Qsb0JBQW9CLEVBQUU7QUFDOUU7O0FBRUE7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUNBQW1DO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGFBQWEsRUFBRSxFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsYUFBYSxFQUFFLEU7QUFDeEY7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGFBQWEsRUFBRSxFO0FBQ3JGO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBLHVDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLHVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsZ0VBQWdFLHNCQUFzQixHQUFHLElBQUk7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QjtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUEsOEJBQThCLGlCQUFpQjtBQUMvQyxtQztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0Esa0NBQWtDLGNBQWMsR0FBRyxhQUFhO0FBQ2hFLHlDO0FBQ0EsNkM7QUFDQSxzQ0FBc0Msd0JBQXdCLEdBQUcsd0JBQXdCO0FBQ3pGLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsOEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQ0FBcUMsd0JBQXdCLEU7QUFDN0Q7QUFDQTtBQUNBLGFBQWEsT0FBTyxXQUFXO0FBQy9CO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRCxpQkFBaUIsRTtBQUNqQjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGE7QUFDQSxTOztBQUVBLEtBQUssRTs7QUFFTCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLGtEQUFrRCx3QkFBd0IsR0FBRyx3QkFBd0I7QUFDckcsNERBQTRELCtCQUErQjs7QUFFM0Y7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLDRCQUE0Qix3QkFBd0IsR0FBRyx3QkFBd0IsRUFBRTs7O0FBRzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsbUM7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0IsMkJBQTJCO0FBQzNCOztBQUVBLDREO0FBQ0EsWTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsNEJBQTRCO0FBQy9EO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYTs7QUFFQTtBQUNBO0FBQ0EsYTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsUztBQUNBLEtBQUs7O0FBRUwsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0EsNkJBQTZCO0FBQzdCO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsdUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSw2RDs7O0FBR0EsYUFBYTtBQUNiO0FBQ0EsUztBQUNBLEtBQUs7O0FBRUwsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQix1Q0FBdUM7QUFDakU7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG9CQUFvQixFQUFFO0FBQ2hFO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMscUJBQXFCO0FBQzFELE1BQU07QUFDTixxQ0FBcUMsc0JBQXNCO0FBQzNEO0FBQ0E7QUFDQSxxQ0FBcUMscUJBQXFCO0FBQzFELE1BQU07QUFDTixxQ0FBcUMsc0JBQXNCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMscUJBQXFCO0FBQzFELE1BQU07QUFDTixxQ0FBcUMsc0JBQXNCO0FBQzNEO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTCxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsS0FBSzs7QUFFTDs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVIsZ0M7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUMiLCJmaWxlIjoiLi9Nb2R1bGVzL1RyYW5zbGF0aW9uL25vZGVfbW9kdWxlcy94LWVkaXRhYmxlL2Rpc3QvYm9vdHN0cmFwMy1lZGl0YWJsZS9qcy9ib290c3RyYXAtZWRpdGFibGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgWC1lZGl0YWJsZSAtIHYxLjUuMSBcbiogSW4tcGxhY2UgZWRpdGluZyB3aXRoIFR3aXR0ZXIgQm9vdHN0cmFwLCBqUXVlcnkgVUkgb3IgcHVyZSBqUXVlcnlcbiogaHR0cDovL2dpdGh1Yi5jb20vdml0YWxldHMveC1lZGl0YWJsZVxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVml0YWxpeSBQb3RhcG92OyBMaWNlbnNlZCBNSVQgKi9cbi8qKlxuRm9ybSB3aXRoIHNpbmdsZSBpbnB1dCBlbGVtZW50LCB0d28gYnV0dG9ucyBhbmQgdHdvIHN0YXRlczogbm9ybWFsL2xvYWRpbmcuXG5BcHBsaWVkIGFzIGpRdWVyeSBtZXRob2QgdG8gRElWIHRhZyAobm90IHRvIGZvcm0gdGFnISkuIFRoaXMgaXMgYmVjYXVzZSBmb3JtIGNhbiBiZSBpbiBsb2FkaW5nIHN0YXRlIHdoZW4gc3Bpbm5lciBzaG93bi5cbkVkaXRhYmxlZm9ybSBpcyBsaW5rZWQgd2l0aCBvbmUgb2YgaW5wdXQgdHlwZXMsIGUuZy4gJ3RleHQnLCAnc2VsZWN0JyBldGMuXG5cbkBjbGFzcyBlZGl0YWJsZWZvcm1cbkB1c2VzIHRleHRcbkB1c2VzIHRleHRhcmVhXG4qKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIFxuICAgIHZhciBFZGl0YWJsZUZvcm0gPSBmdW5jdGlvbiAoZGl2LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxlZm9ybS5kZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuJGRpdiA9ICQoZGl2KTsgLy9kaXYsIGNvbnRhaW5pbmcgZm9ybS4gTm90IGZvcm0gdGFnLiBOb3QgZWRpdGFibGUtZWxlbWVudC5cbiAgICAgICAgaWYoIXRoaXMub3B0aW9ucy5zY29wZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNjb3BlID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvL25vdGhpbmcgc2hvd24gYWZ0ZXIgaW5pdFxuICAgIH07XG5cbiAgICBFZGl0YWJsZUZvcm0ucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogRWRpdGFibGVGb3JtLFxuICAgICAgICBpbml0SW5wdXQ6IGZ1bmN0aW9uKCkgeyAgLy9jYWxsZWQgb25jZVxuICAgICAgICAgICAgLy90YWtlIGlucHV0IGZyb20gb3B0aW9ucyAoYXMgaXQgaXMgY3JlYXRlZCBpbiBlZGl0YWJsZS1lbGVtZW50KVxuICAgICAgICAgICAgdGhpcy5pbnB1dCA9IHRoaXMub3B0aW9ucy5pbnB1dDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9zZXQgaW5pdGlhbCB2YWx1ZVxuICAgICAgICAgICAgLy90b2RvOiBtYXkgYmUgYWRkIGNoZWNrOiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IFxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuaW5wdXQuc3RyMnZhbHVlKHRoaXMub3B0aW9ucy52YWx1ZSk7IFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3ByZXJlbmRlcjogZ2V0IGlucHV0LiRpbnB1dFxuICAgICAgICAgICAgdGhpcy5pbnB1dC5wcmVyZW5kZXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdFRlbXBsYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuJGZvcm0gPSAkKCQuZm4uZWRpdGFibGVmb3JtLnRlbXBsYXRlKTsgXG4gICAgICAgIH0sXG4gICAgICAgIGluaXRCdXR0b25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciAkYnRuID0gdGhpcy4kZm9ybS5maW5kKCcuZWRpdGFibGUtYnV0dG9ucycpO1xuICAgICAgICAgICAgJGJ0bi5hcHBlbmQoJC5mbi5lZGl0YWJsZWZvcm0uYnV0dG9ucyk7XG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuc2hvd2J1dHRvbnMgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICAgICAgJGJ0bi5hZGRDbGFzcygnZWRpdGFibGUtYnV0dG9ucy1ib3R0b20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgIFJlbmRlcnMgZWRpdGFibGVmb3JtXG5cbiAgICAgICAgQG1ldGhvZCByZW5kZXJcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vaW5pdCBsb2FkZXJcbiAgICAgICAgICAgIHRoaXMuJGxvYWRpbmcgPSAkKCQuZm4uZWRpdGFibGVmb3JtLmxvYWRpbmcpOyAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRkaXYuZW1wdHkoKS5hcHBlbmQodGhpcy4kbG9hZGluZyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaW5pdCBmb3JtIHRlbXBsYXRlIGFuZCBidXR0b25zXG4gICAgICAgICAgICB0aGlzLmluaXRUZW1wbGF0ZSgpO1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnNob3didXR0b25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0QnV0dG9ucygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRmb3JtLmZpbmQoJy5lZGl0YWJsZS1idXR0b25zJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vc2hvdyBsb2FkaW5nIHN0YXRlXG4gICAgICAgICAgICB0aGlzLnNob3dMb2FkaW5nKCk7ICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vZmxhZyBzaG93aW5nIGlzIGZvcm0gbm93IHNhdmluZyB2YWx1ZSB0byBzZXJ2ZXIuIFxuICAgICAgICAgICAgLy9JdCBpcyBuZWVkZWQgdG8gd2FpdCB3aGVuIGNsb3NpbmcgZm9ybS5cbiAgICAgICAgICAgIHRoaXMuaXNTYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLyoqICAgICAgICBcbiAgICAgICAgICAgIEZpcmVkIHdoZW4gcmVuZGVyaW5nIHN0YXJ0c1xuICAgICAgICAgICAgQGV2ZW50IHJlbmRlcmluZyBcbiAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBldmVudCBldmVudCBvYmplY3RcbiAgICAgICAgICAgICoqLyAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kZGl2LnRyaWdnZXJIYW5kbGVyKCdyZW5kZXJpbmcnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9pbml0IGlucHV0XG4gICAgICAgICAgICB0aGlzLmluaXRJbnB1dCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2FwcGVuZCBpbnB1dCB0byBmb3JtXG4gICAgICAgICAgICB0aGlzLiRmb3JtLmZpbmQoJ2Rpdi5lZGl0YWJsZS1pbnB1dCcpLmFwcGVuZCh0aGlzLmlucHV0LiR0cGwpOyAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2FwcGVuZCBmb3JtIHRvIGNvbnRhaW5lclxuICAgICAgICAgICAgdGhpcy4kZGl2LmFwcGVuZCh0aGlzLiRmb3JtKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9yZW5kZXIgaW5wdXRcbiAgICAgICAgICAgICQud2hlbih0aGlzLmlucHV0LnJlbmRlcigpKVxuICAgICAgICAgICAgLnRoZW4oJC5wcm94eShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy9zZXR1cCBpbnB1dCB0byBzdWJtaXQgYXV0b21hdGljYWxseSB3aGVuIG5vIGJ1dHRvbnMgc2hvd25cbiAgICAgICAgICAgICAgICBpZighdGhpcy5vcHRpb25zLnNob3didXR0b25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuYXV0b3N1Ym1pdCgpOyBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vYXR0YWNoICdjYW5jZWwnIGhhbmRsZXJcbiAgICAgICAgICAgICAgICB0aGlzLiRmb3JtLmZpbmQoJy5lZGl0YWJsZS1jYW5jZWwnKS5jbGljaygkLnByb3h5KHRoaXMuY2FuY2VsLCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYodGhpcy5pbnB1dC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKHRoaXMuaW5wdXQuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRmb3JtLmZpbmQoJy5lZGl0YWJsZS1zdWJtaXQnKS5hdHRyKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0LiRpbnB1dC5hdHRyKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAvL3ByZXZlbnQgZm9ybSBmcm9tIHN1Ym1pdHRpbmdcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZm9ybS5zdWJtaXQoZnVuY3Rpb24oZSl7IGUucHJldmVudERlZmF1bHQoKTsgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuJGlucHV0LnJlbW92ZUF0dHIoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGZvcm0uZmluZCgnLmVkaXRhYmxlLXN1Ym1pdCcpLnJlbW92ZUF0dHIoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICh0aGlzLnZhbHVlID09PSBudWxsIHx8IHRoaXMudmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLnZhbHVlID09PSAnJykgPyB0aGlzLm9wdGlvbnMuZGVmYXVsdFZhbHVlIDogdGhpcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dC52YWx1ZTJpbnB1dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vYXR0YWNoIHN1Ym1pdCBoYW5kbGVyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGZvcm0uc3VibWl0KCQucHJveHkodGhpcy5zdWJtaXQsIHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKiogICAgICAgIFxuICAgICAgICAgICAgICAgIEZpcmVkIHdoZW4gZm9ybSBpcyByZW5kZXJlZFxuICAgICAgICAgICAgICAgIEBldmVudCByZW5kZXJlZFxuICAgICAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBldmVudCBldmVudCBvYmplY3RcbiAgICAgICAgICAgICAgICAqKi8gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXYudHJpZ2dlckhhbmRsZXIoJ3JlbmRlcmVkJyk7ICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93Rm9ybSgpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vY2FsbCBwb3N0cmVuZGVyIG1ldGhvZCB0byBwZXJmb3JtIGFjdGlvbnMgcmVxdWlyZWQgdmlzaWJpbGl0eSBvZiBmb3JtXG4gICAgICAgICAgICAgICAgaWYodGhpcy5pbnB1dC5wb3N0cmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQucG9zdHJlbmRlcigpO1xuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7ICAgXG4gICAgICAgICAgICAvKiogICAgICAgIFxuICAgICAgICAgICAgRmlyZWQgd2hlbiBmb3JtIHdhcyBjYW5jZWxsZWQgYnkgdXNlclxuICAgICAgICAgICAgQGV2ZW50IGNhbmNlbCBcbiAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBldmVudCBldmVudCBvYmplY3RcbiAgICAgICAgICAgICoqLyAgICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRkaXYudHJpZ2dlckhhbmRsZXIoJ2NhbmNlbCcpO1xuICAgICAgICB9LFxuICAgICAgICBzaG93TG9hZGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdywgaDtcbiAgICAgICAgICAgIGlmKHRoaXMuJGZvcm0pIHtcbiAgICAgICAgICAgICAgICAvL3NldCBsb2FkaW5nIHNpemUgZXF1YWwgdG8gZm9ybVxuICAgICAgICAgICAgICAgIHcgPSB0aGlzLiRmb3JtLm91dGVyV2lkdGgoKTtcbiAgICAgICAgICAgICAgICBoID0gdGhpcy4kZm9ybS5vdXRlckhlaWdodCgpOyBcbiAgICAgICAgICAgICAgICBpZih3KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvYWRpbmcud2lkdGgodyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9hZGluZy5oZWlnaHQoaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuJGZvcm0uaGlkZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL3N0cmV0Y2ggbG9hZGluZyB0byBmaWxsIGNvbnRhaW5lciB3aWR0aFxuICAgICAgICAgICAgICAgIHcgPSB0aGlzLiRsb2FkaW5nLnBhcmVudCgpLndpZHRoKCk7XG4gICAgICAgICAgICAgICAgaWYodykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2FkaW5nLndpZHRoKHcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJGxvYWRpbmcuc2hvdygpOyBcbiAgICAgICAgfSxcblxuICAgICAgICBzaG93Rm9ybTogZnVuY3Rpb24oYWN0aXZhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuJGxvYWRpbmcuaGlkZSgpO1xuICAgICAgICAgICAgdGhpcy4kZm9ybS5zaG93KCk7XG4gICAgICAgICAgICBpZihhY3RpdmF0ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0LmFjdGl2YXRlKCk7IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqICAgICAgICBcbiAgICAgICAgICAgIEZpcmVkIHdoZW4gZm9ybSBpcyBzaG93blxuICAgICAgICAgICAgQGV2ZW50IHNob3cgXG4gICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gZXZlbnQgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICAqKi8gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kZGl2LnRyaWdnZXJIYW5kbGVyKCdzaG93Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICAgICAgdmFyICRncm91cCA9IHRoaXMuJGZvcm0uZmluZCgnLmNvbnRyb2wtZ3JvdXAnKSxcbiAgICAgICAgICAgICAgICAkYmxvY2sgPSB0aGlzLiRmb3JtLmZpbmQoJy5lZGl0YWJsZS1lcnJvci1ibG9jaycpLFxuICAgICAgICAgICAgICAgIGxpbmVzO1xuXG4gICAgICAgICAgICBpZihtc2cgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgJGdyb3VwLnJlbW92ZUNsYXNzKCQuZm4uZWRpdGFibGVmb3JtLmVycm9yR3JvdXBDbGFzcyk7XG4gICAgICAgICAgICAgICAgJGJsb2NrLnJlbW92ZUNsYXNzKCQuZm4uZWRpdGFibGVmb3JtLmVycm9yQmxvY2tDbGFzcykuZW1wdHkoKS5oaWRlKCk7IFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgbmV3bGluZSB0byA8YnI+IGZvciBtb3JlIHByZXR0eSBlcnJvciBkaXNwbGF5XG4gICAgICAgICAgICAgICAgaWYobXNnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzID0gKCcnK21zZykuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lc1tpXSA9ICQoJzxkaXY+JykudGV4dChsaW5lc1tpXSkuaHRtbCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IGxpbmVzLmpvaW4oJzxicj4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJGdyb3VwLmFkZENsYXNzKCQuZm4uZWRpdGFibGVmb3JtLmVycm9yR3JvdXBDbGFzcyk7XG4gICAgICAgICAgICAgICAgJGJsb2NrLmFkZENsYXNzKCQuZm4uZWRpdGFibGVmb3JtLmVycm9yQmxvY2tDbGFzcykuaHRtbChtc2cpLnNob3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzdWJtaXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vZ2V0IG5ldyB2YWx1ZSBmcm9tIGlucHV0XG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLmlucHV0LmlucHV0MnZhbHVlKCk7IFxuXG4gICAgICAgICAgICAvL3ZhbGlkYXRpb246IGlmIHZhbGlkYXRlIHJldHVybnMgc3RyaW5nIG9yIHRydXRoeSB2YWx1ZSAtIG1lYW5zIGVycm9yXG4gICAgICAgICAgICAvL2lmIHJldHVybnMgb2JqZWN0IGxpa2Uge25ld1ZhbHVlOiAnLi4uJ30gPT4gc3VibWl0dGVkIHZhbHVlIGlzIHJlYXNzaWduZWQgdG8gaXRcbiAgICAgICAgICAgIHZhciBlcnJvciA9IHRoaXMudmFsaWRhdGUobmV3VmFsdWUpO1xuICAgICAgICAgICAgaWYgKCQudHlwZShlcnJvcikgPT09ICdvYmplY3QnICYmIGVycm9yLm5ld1ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IGVycm9yLm5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQudmFsdWUyaW5wdXQobmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBlcnJvci5tc2cgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyb3IubXNnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93Rm9ybSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Zvcm0oKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2lmIHZhbHVlIG5vdCBjaGFuZ2VkIC0tPiB0cmlnZ2VyICdub2NoYW5nZScgZXZlbnQgYW5kIHJldHVyblxuICAgICAgICAgICAgLypqc2xpbnQgZXFlcTogdHJ1ZSovXG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5zYXZlbm9jaGFuZ2UgJiYgdGhpcy5pbnB1dC52YWx1ZTJzdHIobmV3VmFsdWUpID09IHRoaXMuaW5wdXQudmFsdWUyc3RyKHRoaXMudmFsdWUpKSB7XG4gICAgICAgICAgICAvKmpzbGludCBlcWVxOiBmYWxzZSovICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8qKiAgICAgICAgXG4gICAgICAgICAgICAgICAgRmlyZWQgd2hlbiB2YWx1ZSBub3QgY2hhbmdlZCBidXQgZm9ybSBpcyBzdWJtaXR0ZWQuIFJlcXVpcmVzIHNhdmVub2NoYW5nZSA9IGZhbHNlLlxuICAgICAgICAgICAgICAgIEBldmVudCBub2NoYW5nZSBcbiAgICAgICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gZXZlbnQgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICAgICAgKiovICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXYudHJpZ2dlckhhbmRsZXIoJ25vY2hhbmdlJyk7ICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBcblxuICAgICAgICAgICAgLy9jb252ZXJ0IHZhbHVlIGZvciBzdWJtaXR0aW5nIHRvIHNlcnZlclxuICAgICAgICAgICAgdmFyIHN1Ym1pdFZhbHVlID0gdGhpcy5pbnB1dC52YWx1ZTJzdWJtaXQobmV3VmFsdWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmlzU2F2aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9zZW5kaW5nIGRhdGEgdG8gc2VydmVyXG4gICAgICAgICAgICAkLndoZW4odGhpcy5zYXZlKHN1Ym1pdFZhbHVlKSlcbiAgICAgICAgICAgIC5kb25lKCQucHJveHkoZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2F2aW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvL3J1biBzdWNjZXNzIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuc3VjY2VzcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMub3B0aW9ucy5zdWNjZXNzLmNhbGwodGhpcy5vcHRpb25zLnNjb3BlLCByZXNwb25zZSwgbmV3VmFsdWUpIDogbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vaWYgc3VjY2VzcyBjYWxsYmFjayByZXR1cm5zIGZhbHNlIC0tPiBrZWVwIGZvcm0gb3BlbiBhbmQgZG8gbm90IGFjdGl2YXRlIGlucHV0XG4gICAgICAgICAgICAgICAgaWYocmVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93Rm9ybShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2lmIHN1Y2Nlc3MgY2FsbGJhY2sgcmV0dXJucyBzdHJpbmcgLS0+ICBrZWVwIGZvcm0gb3Blbiwgc2hvdyBlcnJvciBhbmQgYWN0aXZhdGUgaW5wdXQgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgcmVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKHJlcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Zvcm0oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vaWYgc3VjY2VzcyBjYWxsYmFjayByZXR1cm5zIG9iamVjdCBsaWtlIHtuZXdWYWx1ZTogPHNvbWV0aGluZz59IC0tPiB1c2UgdGhhdCB2YWx1ZSBpbnN0ZWFkIG9mIHN1Ym1pdHRlZFxuICAgICAgICAgICAgICAgIC8vaXQgaXMgdXNlZnVsbCBpZiB5b3Ugd2FudCB0byBjaG5hZ2UgdmFsdWUgaW4gdXJsLWZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgaWYocmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmIHJlcy5oYXNPd25Qcm9wZXJ0eSgnbmV3VmFsdWUnKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHJlcy5uZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2NsZWFyIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGZhbHNlKTsgICBcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgLyoqICAgICAgICBcbiAgICAgICAgICAgICAgICBGaXJlZCB3aGVuIGZvcm0gaXMgc3VibWl0dGVkXG4gICAgICAgICAgICAgICAgQGV2ZW50IHNhdmUgXG4gICAgICAgICAgICAgICAgQHBhcmFtIHtPYmplY3R9IGV2ZW50IGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgYWRkaXRpb25hbCBwYXJhbXNcbiAgICAgICAgICAgICAgICBAcGFyYW0ge21peGVkfSBwYXJhbXMubmV3VmFsdWUgcmF3IG5ldyB2YWx1ZVxuICAgICAgICAgICAgICAgIEBwYXJhbSB7bWl4ZWR9IHBhcmFtcy5zdWJtaXRWYWx1ZSBzdWJtaXR0ZWQgdmFsdWUgYXMgc3RyaW5nXG4gICAgICAgICAgICAgICAgQHBhcmFtIHtPYmplY3R9IHBhcmFtcy5yZXNwb25zZSBhamF4IHJlc3BvbnNlXG5cbiAgICAgICAgICAgICAgICBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICQoJyNmb3JtLWRpdicpLm9uKCdzYXZlJyksIGZ1bmN0aW9uKGUsIHBhcmFtcyl7XG4gICAgICAgICAgICAgICAgICAgIGlmKHBhcmFtcy5uZXdWYWx1ZSA9PT0gJ3VzZXJuYW1lJykgey4uLn1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAqKi9cbiAgICAgICAgICAgICAgICB0aGlzLiRkaXYudHJpZ2dlckhhbmRsZXIoJ3NhdmUnLCB7bmV3VmFsdWU6IG5ld1ZhbHVlLCBzdWJtaXRWYWx1ZTogc3VibWl0VmFsdWUsIHJlc3BvbnNlOiByZXNwb25zZX0pO1xuICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAuZmFpbCgkLnByb3h5KGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNTYXZpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHZhciBtc2c7XG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIHRoaXMub3B0aW9ucy5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBtc2cgPSB0aGlzLm9wdGlvbnMuZXJyb3IuY2FsbCh0aGlzLm9wdGlvbnMuc2NvcGUsIHhociwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IHR5cGVvZiB4aHIgPT09ICdzdHJpbmcnID8geGhyIDogeGhyLnJlc3BvbnNlVGV4dCB8fCB4aHIuc3RhdHVzVGV4dCB8fCAnVW5rbm93biBlcnJvciEnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IobXNnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dGb3JtKCk7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2F2ZTogZnVuY3Rpb24oc3VibWl0VmFsdWUpIHtcbiAgICAgICAgICAgIC8vdHJ5IHBhcnNlIGNvbXBvc2l0ZSBwayBkZWZpbmVkIGFzIGpzb24gc3RyaW5nIGluIGRhdGEtcGsgXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucGsgPSAkLmZuLmVkaXRhYmxldXRpbHMudHJ5UGFyc2VKc29uKHRoaXMub3B0aW9ucy5waywgdHJ1ZSk7IFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgcGsgPSAodHlwZW9mIHRoaXMub3B0aW9ucy5wayA9PT0gJ2Z1bmN0aW9uJykgPyB0aGlzLm9wdGlvbnMucGsuY2FsbCh0aGlzLm9wdGlvbnMuc2NvcGUpIDogdGhpcy5vcHRpb25zLnBrLFxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgc2VuZCBvbiBzZXJ2ZXIgaW4gZm9sbG93aW5nIGNhc2VzOlxuICAgICAgICAgICAgICAxLiB1cmwgaXMgZnVuY3Rpb25cbiAgICAgICAgICAgICAgMi4gdXJsIGlzIHN0cmluZyBBTkQgKHBrIGRlZmluZWQgT1Igc2VuZCBvcHRpb24gPSBhbHdheXMpIFxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNlbmQgPSAhISh0eXBlb2YgdGhpcy5vcHRpb25zLnVybCA9PT0gJ2Z1bmN0aW9uJyB8fCAodGhpcy5vcHRpb25zLnVybCAmJiAoKHRoaXMub3B0aW9ucy5zZW5kID09PSAnYWx3YXlzJykgfHwgKHRoaXMub3B0aW9ucy5zZW5kID09PSAnYXV0bycgJiYgcGsgIT09IG51bGwgJiYgcGsgIT09IHVuZGVmaW5lZCkpKSksXG4gICAgICAgICAgICBwYXJhbXM7XG5cbiAgICAgICAgICAgIGlmIChzZW5kKSB7IC8vc2VuZCB0byBzZXJ2ZXJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dMb2FkaW5nKCk7XG5cbiAgICAgICAgICAgICAgICAvL3N0YW5kYXJkIHBhcmFtc1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5vcHRpb25zLm5hbWUgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdWJtaXRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGs6IHBrIFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvL2FkZGl0aW9uYWwgcGFyYW1zXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIHRoaXMub3B0aW9ucy5wYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gdGhpcy5vcHRpb25zLnBhcmFtcy5jYWxsKHRoaXMub3B0aW9ucy5zY29wZSwgcGFyYW1zKTsgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdHJ5IHBhcnNlIGpzb24gaW4gc2luZ2xlIHF1b3RlcyAoZnJvbSBkYXRhLXBhcmFtcyBhdHRyaWJ1dGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wYXJhbXMgPSAkLmZuLmVkaXRhYmxldXRpbHMudHJ5UGFyc2VKc29uKHRoaXMub3B0aW9ucy5wYXJhbXMsIHRydWUpOyAgIFxuICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZChwYXJhbXMsIHRoaXMub3B0aW9ucy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiB0aGlzLm9wdGlvbnMudXJsID09PSAnZnVuY3Rpb24nKSB7IC8vdXNlcidzIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudXJsLmNhbGwodGhpcy5vcHRpb25zLnNjb3BlLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7ICBcbiAgICAgICAgICAgICAgICAgICAgLy9zZW5kIGFqYXggdG8gc2VydmVyIGFuZCByZXR1cm4gZGVmZXJyZWQgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkLmFqYXgoJC5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICAgICA6IHRoaXMub3B0aW9ucy51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhICAgIDogcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAgICA6ICdQT1NUJ1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm9wdGlvbnMuYWpheE9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFxuXG4gICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMudmFsaWRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnZhbGlkYXRlLmNhbGwodGhpcy5vcHRpb25zLnNjb3BlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3B0aW9uOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZihrZXkgaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vZG8gbm90IHBhc3Mgb3B0aW9uIHRvIGlucHV0IGFzIGl0IGlzIHBhc3NlZCBpbiBlZGl0YWJsZS1lbGVtZW50XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBjb252ZXJ0U3RyKSB7XG4gICAgICAgICAgICBpZihjb252ZXJ0U3RyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuaW5wdXQuc3RyMnZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2lmIGZvcm0gaXMgdmlzaWJsZSwgdXBkYXRlIGlucHV0XG4gICAgICAgICAgICBpZih0aGlzLiRmb3JtICYmIHRoaXMuJGZvcm0uaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0LnZhbHVlMmlucHV0KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgfSAgICAgICAgICAgIFxuICAgICAgICB9ICAgICAgICAgICAgICAgXG4gICAgfTtcblxuICAgIC8qXG4gICAgSW5pdGlhbGl6ZSBlZGl0YWJsZWZvcm0uIEFwcGxpZWQgdG8galF1ZXJ5IG9iamVjdC5cblxuICAgIEBtZXRob2QgJCgpLmVkaXRhYmxlZm9ybShvcHRpb25zKVxuICAgIEBwYXJhbXMge09iamVjdH0gb3B0aW9uc1xuICAgIEBleGFtcGxlXG4gICAgdmFyICRmb3JtID0gJCgnJmx0O2RpdiZndDsnKS5lZGl0YWJsZWZvcm0oe1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIG5hbWU6ICd1c2VybmFtZScsXG4gICAgICAgIHVybDogJy9wb3N0JyxcbiAgICAgICAgdmFsdWU6ICd2aXRhbGl5J1xuICAgIH0pO1xuXG4gICAgLy90byBkaXNwbGF5IGZvcm0geW91IHNob3VsZCBjYWxsICdyZW5kZXInIG1ldGhvZFxuICAgICRmb3JtLmVkaXRhYmxlZm9ybSgncmVuZGVyJyk7ICAgICBcbiAgICAqL1xuICAgICQuZm4uZWRpdGFibGVmb3JtID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLCBcbiAgICAgICAgICAgIGRhdGEgPSAkdGhpcy5kYXRhKCdlZGl0YWJsZWZvcm0nKSwgXG4gICAgICAgICAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PT0gJ29iamVjdCcgJiYgb3B0aW9uOyBcbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICR0aGlzLmRhdGEoJ2VkaXRhYmxlZm9ybScsIChkYXRhID0gbmV3IEVkaXRhYmxlRm9ybSh0aGlzLCBvcHRpb25zKSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PT0gJ3N0cmluZycpIHsgLy9jYWxsIG1ldGhvZCBcbiAgICAgICAgICAgICAgICBkYXRhW29wdGlvbl0uYXBwbHkoZGF0YSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8va2VlcCBsaW5rIHRvIGNvbnN0cnVjdG9yIHRvIGFsbG93IGluaGVyaXRhbmNlXG4gICAgJC5mbi5lZGl0YWJsZWZvcm0uQ29uc3RydWN0b3IgPSBFZGl0YWJsZUZvcm07ICAgIFxuXG4gICAgLy9kZWZhdWx0c1xuICAgICQuZm4uZWRpdGFibGVmb3JtLmRlZmF1bHRzID0ge1xuICAgICAgICAvKiBzZWUgYWxzbyBkZWZhdWx0cyBmb3IgaW5wdXQgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgVHlwZSBvZiBpbnB1dC4gQ2FuIGJlIDxjb2RlPnRleHR8dGV4dGFyZWF8c2VsZWN0fGRhdGV8Y2hlY2tsaXN0PC9jb2RlPlxuXG4gICAgICAgIEBwcm9wZXJ0eSB0eXBlIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgJ3RleHQnXG4gICAgICAgICoqL1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIC8qKlxuICAgICAgICBVcmwgZm9yIHN1Ym1pdCwgZS5nLiA8Y29kZT4nL3Bvc3QnPC9jb2RlPiAgXG4gICAgICAgIElmIGZ1bmN0aW9uIC0gaXQgd2lsbCBiZSBjYWxsZWQgaW5zdGVhZCBvZiBhamF4LiBGdW5jdGlvbiBzaG91bGQgcmV0dXJuIGRlZmVycmVkIG9iamVjdCB0byBydW4gZmFpbC9kb25lIGNhbGxiYWNrcy5cblxuICAgICAgICBAcHJvcGVydHkgdXJsIFxuICAgICAgICBAdHlwZSBzdHJpbmd8ZnVuY3Rpb25cbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICBAZXhhbXBsZVxuICAgICAgICB1cmw6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIGQgPSBuZXcgJC5EZWZlcnJlZDtcbiAgICAgICAgICAgIGlmKHBhcmFtcy52YWx1ZSA9PT0gJ2FiYycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5yZWplY3QoJ2Vycm9yIG1lc3NhZ2UnKTsgLy9yZXR1cm5pbmcgZXJyb3IgdmlhIGRlZmVycmVkIG9iamVjdFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL2FzeW5jIHNhdmluZyBkYXRhIGluIGpzIG1vZGVsXG4gICAgICAgICAgICAgICAgc29tZU1vZGVsLmFzeW5jU2F2ZU1ldGhvZCh7XG4gICAgICAgICAgICAgICAgICAgLi4uLCBcbiAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgIGQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTsgXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQucHJvbWlzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IFxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICB1cmw6bnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIEFkZGl0aW9uYWwgcGFyYW1zIGZvciBzdWJtaXQuIElmIGRlZmluZWQgYXMgPGNvZGU+b2JqZWN0PC9jb2RlPiAtIGl0IGlzICoqYXBwZW5kZWQqKiB0byBvcmlnaW5hbCBhamF4IGRhdGEgKHBrLCBuYW1lIGFuZCB2YWx1ZSkuICBcbiAgICAgICAgSWYgZGVmaW5lZCBhcyA8Y29kZT5mdW5jdGlvbjwvY29kZT4gLSByZXR1cm5lZCBvYmplY3QgKipvdmVyd3JpdGVzKiogb3JpZ2luYWwgYWpheCBkYXRhLlxuICAgICAgICBAZXhhbXBsZVxuICAgICAgICBwYXJhbXM6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICAgICAgLy9vcmlnaW5hbGx5IHBhcmFtcyBjb250YWluIHBrLCBuYW1lIGFuZCB2YWx1ZVxuICAgICAgICAgICAgcGFyYW1zLmEgPSAxO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgfVxuXG4gICAgICAgIEBwcm9wZXJ0eSBwYXJhbXMgXG4gICAgICAgIEB0eXBlIG9iamVjdHxmdW5jdGlvblxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgcGFyYW1zOm51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBOYW1lIG9mIGZpZWxkLiBXaWxsIGJlIHN1Ym1pdHRlZCBvbiBzZXJ2ZXIuIENhbiBiZSB0YWtlbiBmcm9tIDxjb2RlPmlkPC9jb2RlPiBhdHRyaWJ1dGVcblxuICAgICAgICBAcHJvcGVydHkgbmFtZSBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBQcmltYXJ5IGtleSBvZiBlZGl0YWJsZSBvYmplY3QgKGUuZy4gcmVjb3JkIGlkIGluIGRhdGFiYXNlKS4gRm9yIGNvbXBvc2l0ZSBrZXlzIHVzZSBvYmplY3QsIGUuZy4gPGNvZGU+e2lkOiAxLCBsYW5nOiAnZW4nfTwvY29kZT4uXG4gICAgICAgIENhbiBiZSBjYWxjdWxhdGVkIGR5bmFtaWNhbGx5IHZpYSBmdW5jdGlvbi5cblxuICAgICAgICBAcHJvcGVydHkgcGsgXG4gICAgICAgIEB0eXBlIHN0cmluZ3xvYmplY3R8ZnVuY3Rpb25cbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgcGs6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBJbml0aWFsIHZhbHVlLiBJZiBub3QgZGVmaW5lZCAtIHdpbGwgYmUgdGFrZW4gZnJvbSBlbGVtZW50J3MgY29udGVudC5cbiAgICAgICAgRm9yIF9fc2VsZWN0X18gdHlwZSBzaG91bGQgYmUgZGVmaW5lZCAoYXMgaXQgaXMgSUQgb2Ygc2hvd24gdGV4dCkuXG5cbiAgICAgICAgQHByb3BlcnR5IHZhbHVlIFxuICAgICAgICBAdHlwZSBzdHJpbmd8b2JqZWN0XG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBWYWx1ZSB0aGF0IHdpbGwgYmUgZGlzcGxheWVkIGluIGlucHV0IGlmIG9yaWdpbmFsIGZpZWxkIHZhbHVlIGlzIGVtcHR5IChgbnVsbHx1bmRlZmluZWR8JydgKS5cblxuICAgICAgICBAcHJvcGVydHkgZGVmYXVsdFZhbHVlIFxuICAgICAgICBAdHlwZSBzdHJpbmd8b2JqZWN0XG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgQHNpbmNlIDEuNC42XG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIFN0cmF0ZWd5IGZvciBzZW5kaW5nIGRhdGEgb24gc2VydmVyLiBDYW4gYmUgYGF1dG98YWx3YXlzfG5ldmVyYC5cbiAgICAgICAgV2hlbiAnYXV0bycgZGF0YSB3aWxsIGJlIHNlbnQgb24gc2VydmVyICoqb25seSBpZiBwayBhbmQgdXJsIGRlZmluZWQqKiwgb3RoZXJ3aXNlIG5ldyB2YWx1ZSB3aWxsIGJlIHN0b3JlZCBsb2NhbGx5LlxuXG4gICAgICAgIEBwcm9wZXJ0eSBzZW5kIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgJ2F1dG8nXG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgc2VuZDogJ2F1dG8nLCBcbiAgICAgICAgLyoqXG4gICAgICAgIEZ1bmN0aW9uIGZvciBjbGllbnQtc2lkZSB2YWxpZGF0aW9uLiBJZiByZXR1cm5zIHN0cmluZyAtIG1lYW5zIHZhbGlkYXRpb24gbm90IHBhc3NlZCBhbmQgc3RyaW5nIHNob3dlZCBhcyBlcnJvci5cbiAgICAgICAgU2luY2UgMS41LjEgeW91IGNhbiBtb2RpZnkgc3VibWl0dGVkIHZhbHVlIGJ5IHJldHVybmluZyBvYmplY3QgZnJvbSBgdmFsaWRhdGVgOiBcbiAgICAgICAgYHtuZXdWYWx1ZTogJy4uLid9YCBvciBge25ld1ZhbHVlOiAnLi4uJywgbXNnOiAnLi4uJ31gXG5cbiAgICAgICAgQHByb3BlcnR5IHZhbGlkYXRlIFxuICAgICAgICBAdHlwZSBmdW5jdGlvblxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBleGFtcGxlXG4gICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYoJC50cmltKHZhbHVlKSA9PSAnJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnVGhpcyBmaWVsZCBpcyByZXF1aXJlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHZhbGlkYXRlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgU3VjY2VzcyBjYWxsYmFjay4gQ2FsbGVkIHdoZW4gdmFsdWUgc3VjY2Vzc2Z1bGx5IHNlbnQgb24gc2VydmVyIGFuZCAqKnJlc3BvbnNlIHN0YXR1cyA9IDIwMCoqLiAgXG4gICAgICAgIFVzZWZ1bGwgdG8gd29yayB3aXRoIGpzb24gcmVzcG9uc2UuIEZvciBleGFtcGxlLCBpZiB5b3VyIGJhY2tlbmQgcmVzcG9uc2UgY2FuIGJlIDxjb2RlPntzdWNjZXNzOiB0cnVlfTwvY29kZT5cbiAgICAgICAgb3IgPGNvZGU+e3N1Y2Nlc3M6IGZhbHNlLCBtc2c6IFwic2VydmVyIGVycm9yXCJ9PC9jb2RlPiB5b3UgY2FuIGNoZWNrIGl0IGluc2lkZSB0aGlzIGNhbGxiYWNrLiAgXG4gICAgICAgIElmIGl0IHJldHVybnMgKipzdHJpbmcqKiAtIG1lYW5zIGVycm9yIG9jY3VyZWQgYW5kIHN0cmluZyBpcyBzaG93biBhcyBlcnJvciBtZXNzYWdlLiAgXG4gICAgICAgIElmIGl0IHJldHVybnMgKipvYmplY3QgbGlrZSoqIDxjb2RlPntuZXdWYWx1ZTogJmx0O3NvbWV0aGluZyZndDt9PC9jb2RlPiAtIGl0IG92ZXJ3cml0ZXMgdmFsdWUsIHN1Ym1pdHRlZCBieSB1c2VyLiAgXG4gICAgICAgIE90aGVyd2lzZSBuZXdWYWx1ZSBzaW1wbHkgcmVuZGVyZWQgaW50byBlbGVtZW50LlxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IHN1Y2Nlc3MgXG4gICAgICAgIEB0eXBlIGZ1bmN0aW9uXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgc3VjY2VzczogZnVuY3Rpb24ocmVzcG9uc2UsIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBpZighcmVzcG9uc2Uuc3VjY2VzcykgcmV0dXJuIHJlc3BvbnNlLm1zZztcbiAgICAgICAgfVxuICAgICAgICAqKi8gICAgICAgICAgXG4gICAgICAgIHN1Y2Nlc3M6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBFcnJvciBjYWxsYmFjay4gQ2FsbGVkIHdoZW4gcmVxdWVzdCBmYWlsZWQgKHJlc3BvbnNlIHN0YXR1cyAhPSAyMDApLiAgXG4gICAgICAgIFVzZWZ1bGwgd2hlbiB5b3Ugd2FudCB0byBwYXJzZSBlcnJvciByZXNwb25zZSBhbmQgZGlzcGxheSBhIGN1c3RvbSBtZXNzYWdlLlxuICAgICAgICBNdXN0IHJldHVybiAqKnN0cmluZyoqIC0gdGhlIG1lc3NhZ2UgdG8gYmUgZGlzcGxheWVkIGluIHRoZSBlcnJvciBibG9jay5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IGVycm9yIFxuICAgICAgICBAdHlwZSBmdW5jdGlvblxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBzaW5jZSAxLjQuNFxuICAgICAgICBAZXhhbXBsZVxuICAgICAgICBlcnJvcjogZnVuY3Rpb24ocmVzcG9uc2UsIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBpZihyZXNwb25zZS5zdGF0dXMgPT09IDUwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnU2VydmljZSB1bmF2YWlsYWJsZS4gUGxlYXNlIHRyeSBsYXRlci4nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHN1Ym1pdCBhamF4IHJlcXVlc3QuXG4gICAgICAgIExpc3Qgb2YgdmFsdWVzOiBodHRwOi8vYXBpLmpxdWVyeS5jb20valF1ZXJ5LmFqYXhcbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBhamF4T3B0aW9ucyBcbiAgICAgICAgQHR5cGUgb2JqZWN0XG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgQHNpbmNlIDEuMS4xICAgICAgICBcbiAgICAgICAgQGV4YW1wbGUgXG4gICAgICAgIGFqYXhPcHRpb25zOiB7XG4gICAgICAgICAgICB0eXBlOiAncHV0JyxcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbidcbiAgICAgICAgfSAgICAgICAgXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIGFqYXhPcHRpb25zOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgV2hlcmUgdG8gc2hvdyBidXR0b25zOiBsZWZ0KHRydWUpfGJvdHRvbXxmYWxzZSAgXG4gICAgICAgIEZvcm0gd2l0aG91dCBidXR0b25zIGlzIGF1dG8tc3VibWl0dGVkLlxuXG4gICAgICAgIEBwcm9wZXJ0eSBzaG93YnV0dG9ucyBcbiAgICAgICAgQHR5cGUgYm9vbGVhbnxzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgdHJ1ZVxuICAgICAgICBAc2luY2UgMS4xLjFcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHNob3didXR0b25zOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgU2NvcGUgZm9yIGNhbGxiYWNrIG1ldGhvZHMgKHN1Y2Nlc3MsIHZhbGlkYXRlKS4gIFxuICAgICAgICBJZiA8Y29kZT5udWxsPC9jb2RlPiBtZWFucyBlZGl0YWJsZWZvcm0gaW5zdGFuY2UgaXRzZWxmLiBcblxuICAgICAgICBAcHJvcGVydHkgc2NvcGUgXG4gICAgICAgIEB0eXBlIERPTUVsZW1lbnR8b2JqZWN0XG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgQHNpbmNlIDEuMi4wXG4gICAgICAgIEBwcml2YXRlXG4gICAgICAgICoqLyAgICAgICAgICAgIFxuICAgICAgICBzY29wZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIFdoZXRoZXIgdG8gc2F2ZSBvciBjYW5jZWwgdmFsdWUgd2hlbiBpdCB3YXMgbm90IGNoYW5nZWQgYnV0IGZvcm0gd2FzIHN1Ym1pdHRlZFxuXG4gICAgICAgIEBwcm9wZXJ0eSBzYXZlbm9jaGFuZ2UgXG4gICAgICAgIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgQHNpbmNlIDEuMi4wXG4gICAgICAgICoqL1xuICAgICAgICBzYXZlbm9jaGFuZ2U6IGZhbHNlXG4gICAgfTsgICBcblxuICAgIC8qXG4gICAgTm90ZTogZm9sbG93aW5nIHBhcmFtcyBjb3VsZCByZWRlZmluZWQgaW4gZW5naW5lOiBib290c3RyYXAgb3IganF1ZXJ5dWk6XG4gICAgQ2xhc3NlcyAnY29udHJvbC1ncm91cCcgYW5kICdlZGl0YWJsZS1lcnJvci1ibG9jaycgbXVzdCBhbHdheXMgcHJlc2VudCFcbiAgICAqLyAgICAgIFxuICAgICQuZm4uZWRpdGFibGVmb3JtLnRlbXBsYXRlID0gJzxmb3JtIGNsYXNzPVwiZm9ybS1pbmxpbmUgZWRpdGFibGVmb3JtXCI+JytcbiAgICAnPGRpdiBjbGFzcz1cImNvbnRyb2wtZ3JvdXBcIj4nICsgXG4gICAgJzxkaXY+PGRpdiBjbGFzcz1cImVkaXRhYmxlLWlucHV0XCI+PC9kaXY+PGRpdiBjbGFzcz1cImVkaXRhYmxlLWJ1dHRvbnNcIj48L2Rpdj48L2Rpdj4nK1xuICAgICc8ZGl2IGNsYXNzPVwiZWRpdGFibGUtZXJyb3ItYmxvY2tcIj48L2Rpdj4nICsgXG4gICAgJzwvZGl2PicgKyBcbiAgICAnPC9mb3JtPic7XG5cbiAgICAvL2xvYWRpbmcgZGl2XG4gICAgJC5mbi5lZGl0YWJsZWZvcm0ubG9hZGluZyA9ICc8ZGl2IGNsYXNzPVwiZWRpdGFibGVmb3JtLWxvYWRpbmdcIj48L2Rpdj4nO1xuXG4gICAgLy9idXR0b25zXG4gICAgJC5mbi5lZGl0YWJsZWZvcm0uYnV0dG9ucyA9ICc8YnV0dG9uIHR5cGU9XCJzdWJtaXRcIiBjbGFzcz1cImVkaXRhYmxlLXN1Ym1pdFwiPm9rPC9idXR0b24+JytcbiAgICAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJlZGl0YWJsZS1jYW5jZWxcIj5jYW5jZWw8L2J1dHRvbj4nOyAgICAgIFxuXG4gICAgLy9lcnJvciBjbGFzcyBhdHRhY2hlZCB0byBjb250cm9sLWdyb3VwXG4gICAgJC5mbi5lZGl0YWJsZWZvcm0uZXJyb3JHcm91cENsYXNzID0gbnVsbDsgIFxuXG4gICAgLy9lcnJvciBjbGFzcyBhdHRhY2hlZCB0byBlZGl0YWJsZS1lcnJvci1ibG9ja1xuICAgICQuZm4uZWRpdGFibGVmb3JtLmVycm9yQmxvY2tDbGFzcyA9ICdlZGl0YWJsZS1lcnJvcic7XG4gICAgXG4gICAgLy9lbmdpbmVcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5lbmdpbmUgPSAnanF1ZXJ5Jztcbn0od2luZG93LmpRdWVyeSkpO1xuXG4vKipcbiogRWRpdGFibGVGb3JtIHV0aWxpdGVzXG4qL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgXG4gICAgLy91dGlsc1xuICAgICQuZm4uZWRpdGFibGV1dGlscyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICogY2xhc3NpYyBKUyBpbmhlcml0YW5jZSBmdW5jdGlvblxuICAgICAgICAqLyAgXG4gICAgICAgIGluaGVyaXQ6IGZ1bmN0aW9uIChDaGlsZCwgUGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgRiA9IGZ1bmN0aW9uKCkgeyB9O1xuICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBQYXJlbnQucHJvdG90eXBlO1xuICAgICAgICAgICAgQ2hpbGQucHJvdG90eXBlID0gbmV3IEYoKTtcbiAgICAgICAgICAgIENoaWxkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENoaWxkO1xuICAgICAgICAgICAgQ2hpbGQuc3VwZXJjbGFzcyA9IFBhcmVudC5wcm90b3R5cGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICogc2V0IGNhcmV0IHBvc2l0aW9uIGluIGlucHV0XG4gICAgICAgICogc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk5MTI2L2pxdWVyeS1zZXQtY3Vyc29yLXBvc2l0aW9uLWluLXRleHQtYXJlYVxuICAgICAgICAqLyAgICAgICAgXG4gICAgICAgIHNldEN1cnNvclBvc2l0aW9uOiBmdW5jdGlvbihlbGVtLCBwb3MpIHtcbiAgICAgICAgICAgIGlmIChlbGVtLnNldFNlbGVjdGlvblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5zZXRTZWxlY3Rpb25SYW5nZShwb3MsIHBvcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW0uY3JlYXRlVGV4dFJhbmdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZWxlbS5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgICAgICAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBwb3MpO1xuICAgICAgICAgICAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgcG9zKTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgKiBmdW5jdGlvbiB0byBwYXJzZSBKU09OIGluICpzaW5nbGUqIHF1b3Rlcy4gKGpxdWVyeSBhdXRvbWF0aWNhbGx5IHBhcnNlIG9ubHkgZG91YmxlIHF1b3RlcylcbiAgICAgICAgKiBUaGF0IGFsbG93cyBzdWNoIGNvZGUgYXM6IDxhIGRhdGEtc291cmNlPVwieydhJzogJ2InLCAnYyc6ICdkJ31cIj5cbiAgICAgICAgKiBzYWZlID0gdHJ1ZSAtLT4gbWVhbnMgbm8gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duXG4gICAgICAgICogZm9yIGRldGFpbHMgc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzQxMDM0OC9ob3ctdG8tc2V0LWpzb24tZm9ybWF0LXRvLWh0bWw1LWRhdGEtYXR0cmlidXRlcy1pbi10aGUtanF1ZXJ5XG4gICAgICAgICovXG4gICAgICAgIHRyeVBhcnNlSnNvbjogZnVuY3Rpb24ocywgc2FmZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJyAmJiBzLmxlbmd0aCAmJiBzLm1hdGNoKC9eW1xce1xcW10uKltcXH1cXF1dJC8pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhZmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qanNsaW50IGV2aWw6IHRydWUqL1xuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IChuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgcykpKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKmpzbGludCBldmlsOiBmYWxzZSovXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKmpzbGludCBldmlsOiB0cnVlKi9cbiAgICAgICAgICAgICAgICAgICAgcyA9IChuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgcykpKCk7XG4gICAgICAgICAgICAgICAgICAgIC8qanNsaW50IGV2aWw6IGZhbHNlKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgKiBzbGljZSBvYmplY3QgYnkgc3BlY2lmaWVkIGtleXNcbiAgICAgICAgKi9cbiAgICAgICAgc2xpY2VPYmo6IGZ1bmN0aW9uKG9iaiwga2V5cywgY2FzZVNlbnNpdGl2ZSAvKiBkZWZhdWx0OiBmYWxzZSAqLykge1xuICAgICAgICAgICAgdmFyIGtleSwga2V5TG93ZXIsIG5ld09iaiA9IHt9O1xuXG4gICAgICAgICAgICBpZiAoISQuaXNBcnJheShrZXlzKSB8fCAha2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGNhc2VTZW5zaXRpdmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy93aGVuIGdldHRpbmcgZGF0YS0qIGF0dHJpYnV0ZXMgdmlhICQuZGF0YSgpIGl0J3MgY29udmVydGVkIHRvIGxvd2VyY2FzZS5cbiAgICAgICAgICAgICAgICAvL2RldGFpbHM6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzYwMjU2NS91c2luZy1kYXRhLWF0dHJpYnV0ZXMtd2l0aC1qcXVlcnlcbiAgICAgICAgICAgICAgICAvL3dvcmthcm91bmQgaXMgY29kZSBiZWxvdy5cbiAgICAgICAgICAgICAgICBrZXlMb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5TG93ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleUxvd2VyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgZXhjbHVkZSBjb21wbGV4IG9iamVjdHMgZnJvbSAkLmRhdGEoKSBiZWZvcmUgcGFzcyB0byBjb25maWdcbiAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29uZmlnRGF0YTogZnVuY3Rpb24oJGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgICAgICAkLmVhY2goJGVsZW1lbnQuZGF0YSgpLCBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIHYgIT09ICdvYmplY3QnIHx8ICh2ICYmIHR5cGVvZiB2ID09PSAnb2JqZWN0JyAmJiAodi5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0IHx8IHYuY29uc3RydWN0b3IgPT09IEFycmF5KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICAgcmV0dXJucyBrZXlzIG9mIG9iamVjdFxuICAgICAgICAqL1xuICAgICAgICBvYmplY3RLZXlzOiBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMobyk7ICBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG8gIT09IE9iamVjdChvKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBrPVtdLCBwO1xuICAgICAgICAgICAgICAgIGZvciAocCBpbiBvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobyxwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgay5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgIC8qKlxuICAgICAgICBtZXRob2QgdG8gZXNjYXBlIGh0bWwuXG4gICAgICAgKiovXG4gICAgICAgZXNjYXBlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgcmV0dXJuICQoJzxkaXY+JykudGV4dChzdHIpLmh0bWwoKTtcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIC8qXG4gICAgICAgIHJldHVybnMgYXJyYXkgaXRlbXMgZnJvbSBzb3VyY2VEYXRhIGhhdmluZyB2YWx1ZSBwcm9wZXJ0eSBlcXVhbCBvciBpbkFycmF5IG9mICd2YWx1ZSdcbiAgICAgICAqL1xuICAgICAgIGl0ZW1zQnlWYWx1ZTogZnVuY3Rpb24odmFsdWUsIHNvdXJjZURhdGEsIHZhbHVlUHJvcCkge1xuICAgICAgICAgICBpZighc291cmNlRGF0YSB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIFxuICAgICAgICAgICBpZiAodHlwZW9mKHZhbHVlUHJvcCkgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgdmFyIGlkS2V5ID0gdmFsdWVQcm9wIHx8ICd2YWx1ZSc7XG4gICAgICAgICAgICAgICB2YWx1ZVByb3AgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZVtpZEtleV07IH07XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgdmFyIGlzVmFsQXJyYXkgPSAkLmlzQXJyYXkodmFsdWUpLFxuICAgICAgICAgICByZXN1bHQgPSBbXSwgXG4gICAgICAgICAgIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICQuZWFjaChzb3VyY2VEYXRhLCBmdW5jdGlvbihpLCBvKSB7XG4gICAgICAgICAgICAgICBpZihvLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGF0Lml0ZW1zQnlWYWx1ZSh2YWx1ZSwgby5jaGlsZHJlbiwgdmFsdWVQcm9wKSk7XG4gICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgIC8qanNsaW50IGVxZXE6IHRydWUqL1xuICAgICAgICAgICAgICAgICAgIGlmKGlzVmFsQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgaWYoJC5ncmVwKHZhbHVlLCBmdW5jdGlvbih2KXsgIHJldHVybiB2ID09IChvICYmIHR5cGVvZiBvID09PSAnb2JqZWN0JyA/IHZhbHVlUHJvcChvKSA6IG8pOyB9KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG8pOyBcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtVmFsdWUgPSAobyAmJiAodHlwZW9mIG8gPT09ICdvYmplY3QnKSkgPyB2YWx1ZVByb3AobykgOiBvO1xuICAgICAgICAgICAgICAgICAgICAgICBpZih2YWx1ZSA9PSBpdGVtVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG8pOyBcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAvKmpzbGludCBlcWVxOiBmYWxzZSovXG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgIH0pO1xuICAgICAgICAgICBcbiAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIC8qXG4gICAgICAgUmV0dXJucyBpbnB1dCBieSBvcHRpb25zOiB0eXBlLCBtb2RlLiBcbiAgICAgICAqL1xuICAgICAgIGNyZWF0ZUlucHV0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgIHZhciBUeXBlQ29uc3RydWN0b3IsIHR5cGVPcHRpb25zLCBpbnB1dCxcbiAgICAgICAgICAgdHlwZSA9IG9wdGlvbnMudHlwZTtcblxuICAgICAgICAgICAvL2BkYXRlYCBpcyBzb21lIGtpbmQgb2YgdmlydHVhbCB0eXBlIHRoYXQgaXMgdHJhbnNmb3JtZWQgdG8gb25lIG9mIGV4YWN0IHR5cGVzXG4gICAgICAgICAgIC8vZGVwZW5kaW5nIG9uIG1vZGUgYW5kIGNvcmUgbGliXG4gICAgICAgICAgIGlmKHR5cGUgPT09ICdkYXRlJykge1xuICAgICAgICAgICAgICAgLy9pbmxpbmVcbiAgICAgICAgICAgICAgIGlmKG9wdGlvbnMubW9kZSA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgICAgICAgICBpZigkLmZuLmVkaXRhYmxldHlwZXMuZGF0ZWZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnZGF0ZWZpZWxkJztcbiAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGV1aWZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnZGF0ZXVpZmllbGQnO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIC8vcG9wdXBcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgaWYoJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdkYXRlJztcbiAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGV1aSkge1xuICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ2RhdGV1aSc7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAvL2lmIHR5cGUgc3RpbGwgYGRhdGVgIGFuZCBub3QgZXhpc3QgaW4gdHlwZXMsIHJlcGxhY2Ugd2l0aCBgY29tYm9kYXRlYCB0aGF0IGlzIGJhc2UgaW5wdXRcbiAgICAgICAgICAgICAgIGlmKHR5cGUgPT09ICdkYXRlJyAmJiAhJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICB0eXBlID0gJ2NvbWJvZGF0ZSc7XG4gICAgICAgICAgICAgICB9IFxuICAgICAgICAgICB9XG4gICAgICAgICAgIFxuICAgICAgICAgICAvL2BkYXRldGltZWAgc2hvdWxkIGJlIGRhdGV0aW1lZmllbGQgaW4gJ2lubGluZScgbW9kZVxuICAgICAgICAgICBpZih0eXBlID09PSAnZGF0ZXRpbWUnICYmIG9wdGlvbnMubW9kZSA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgICB0eXBlID0gJ2RhdGV0aW1lZmllbGQnOyAgXG4gICAgICAgICAgIH0gICAgICAgICAgIFxuXG4gICAgICAgICAgIC8vY2hhbmdlIHd5c2lodG1sNSB0byB0ZXh0YXJlYSBmb3IganF1ZXJ5IFVJIGFuZCBwbGFpbiB2ZXJzaW9uc1xuICAgICAgICAgICBpZih0eXBlID09PSAnd3lzaWh0bWw1JyAmJiAhJC5mbi5lZGl0YWJsZXR5cGVzW3R5cGVdKSB7XG4gICAgICAgICAgICAgICB0eXBlID0gJ3RleHRhcmVhJztcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vY3JlYXRlIGlucHV0IG9mIHNwZWNpZmllZCB0eXBlLiBJbnB1dCB3aWxsIGJlIHVzZWQgZm9yIGNvbnZlcnRpbmcgdmFsdWUsIG5vdCBpbiBmb3JtXG4gICAgICAgICAgIGlmKHR5cGVvZiAkLmZuLmVkaXRhYmxldHlwZXNbdHlwZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgIFR5cGVDb25zdHJ1Y3RvciA9ICQuZm4uZWRpdGFibGV0eXBlc1t0eXBlXTtcbiAgICAgICAgICAgICAgIHR5cGVPcHRpb25zID0gdGhpcy5zbGljZU9iaihvcHRpb25zLCB0aGlzLm9iamVjdEtleXMoVHlwZUNvbnN0cnVjdG9yLmRlZmF1bHRzKSk7XG4gICAgICAgICAgICAgICBpbnB1dCA9IG5ldyBUeXBlQ29uc3RydWN0b3IodHlwZU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgJC5lcnJvcignVW5rbm93biB0eXBlOiAnKyB0eXBlKTtcbiAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgXG4gICAgICAgICAgIH0gIFxuICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgLy9zZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MjY0ODk5L2RldGVjdC1jc3MtdHJhbnNpdGlvbnMtdXNpbmctamF2YXNjcmlwdC1hbmQtd2l0aG91dC1tb2Rlcm5penJcbiAgICAgICBzdXBwb3J0c1RyYW5zaXRpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgIHZhciBiID0gZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICAgICAgICAgICBzID0gYi5zdHlsZSxcbiAgICAgICAgICAgICAgIHAgPSAndHJhbnNpdGlvbicsXG4gICAgICAgICAgICAgICB2ID0gWydNb3onLCAnV2Via2l0JywgJ0todG1sJywgJ08nLCAnbXMnXTtcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICBpZih0eXBlb2Ygc1twXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyBcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vIFRlc3RzIGZvciB2ZW5kb3Igc3BlY2lmaWMgcHJvcFxuICAgICAgICAgICBwID0gcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHAuc3Vic3RyKDEpO1xuICAgICAgICAgICBmb3IodmFyIGk9MDsgaTx2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICBpZih0eXBlb2Ygc1t2W2ldICsgcF0gPT09ICdzdHJpbmcnKSB7IFxuICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyBcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgfSAgICAgICAgICAgIFxuICAgICAgIFxuICAgIH07ICAgICAgXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG5BdHRhY2hlcyBzdGFuZC1hbG9uZSBjb250YWluZXIgd2l0aCBlZGl0YWJsZS1mb3JtIHRvIEhUTUwgZWxlbWVudC4gRWxlbWVudCBpcyB1c2VkIG9ubHkgZm9yIHBvc2l0aW9uaW5nLCB2YWx1ZSBpcyBub3Qgc3RvcmVkIGFueXdoZXJlLjxicj5cblRoaXMgbWV0aG9kIGFwcGxpZWQgaW50ZXJuYWxseSBpbiA8Y29kZT4kKCkuZWRpdGFibGUoKTwvY29kZT4uIFlvdSBzaG91bGQgc3Vic2NyaWJlIG9uIGl0J3MgZXZlbnRzIChzYXZlIC8gY2FuY2VsKSB0byBnZXQgcHJvZml0IG9mIGl0Ljxicj5cbkZpbmFsIHJlYWxpemF0aW9uIGNhbiBiZSBkaWZmZXJlbnQ6IGJvb3RzdHJhcC1wb3BvdmVyLCBqcXVlcnl1aS10b29sdGlwLCBwb3NoeXRpcCwgaW5saW5lLWRpdi4gSXQgZGVwZW5kcyBvbiB3aGljaCBqcyBmaWxlIHlvdSBpbmNsdWRlLjxicj5cbkFwcGxpZWQgYXMgalF1ZXJ5IG1ldGhvZC5cblxuQGNsYXNzIGVkaXRhYmxlQ29udGFpbmVyXG5AdXNlcyBlZGl0YWJsZWZvcm1cbioqL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgUG9wdXAgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgSW5saW5lID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH07ICAgIFxuXG4gICAgLy9tZXRob2RzXG4gICAgUG9wdXAucHJvdG90eXBlID0ge1xuICAgICAgICBjb250YWluZXJOYW1lOiBudWxsLCAvL21ldGhvZCB0byBjYWxsIGNvbnRhaW5lciBvbiBlbGVtZW50XG4gICAgICAgIGNvbnRhaW5lckRhdGFOYW1lOiBudWxsLCAvL29iamVjdCBuYW1lIGluIGVsZW1lbnQncyAuZGF0YSgpXG4gICAgICAgIGlubmVyQ3NzOiBudWxsLCAvL3RiZCBpbiBjaGlsZCBjbGFzc1xuICAgICAgICBjb250YWluZXJDbGFzczogJ2VkaXRhYmxlLWNvbnRhaW5lciBlZGl0YWJsZS1wb3B1cCcsIC8vY3NzIGNsYXNzIGFwcGxpZWQgdG8gY29udGFpbmVyIGVsZW1lbnRcbiAgICAgICAgZGVmYXVsdHM6IHt9LCAvL2NvbnRhaW5lciBpdHNlbGYgZGVmYXVsdHNcbiAgICAgICAgXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgICAgICAgICAgLy9zaW5jZSAxLjQuMSBjb250YWluZXIgZG8gbm90IHVzZSBkYXRhLSogZGlyZWN0bHkgYXMgdGhleSBhbHJlYWR5IG1lcmdlZCBpbnRvIG9wdGlvbnMuXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZUNvbnRhaW5lci5kZWZhdWx0cywgb3B0aW9ucyk7ICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnNwbGl0T3B0aW9ucygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3NldCBzY29wZSBvZiBmb3JtIGNhbGxiYWNrcyB0byBlbGVtZW50XG4gICAgICAgICAgICB0aGlzLmZvcm1PcHRpb25zLnNjb3BlID0gdGhpcy4kZWxlbWVudFswXTsgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuaW5pdENvbnRhaW5lcigpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2ZsYWcgdG8gaGlkZSBjb250YWluZXIsIHdoZW4gc2F2aW5nIHZhbHVlIHdpbGwgZmluaXNoXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRIaWRlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vYmluZCAnZGVzdHJveWVkJyBsaXN0ZW5lciB0byBkZXN0cm95IGNvbnRhaW5lciB3aGVuIGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIGRvbVxuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5vbignZGVzdHJveWVkJywgJC5wcm94eShmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgICAgfSwgdGhpcykpOyBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9hdHRhY2ggZG9jdW1lbnQgaGFuZGxlciB0byBjbG9zZSBjb250YWluZXJzIG9uIGNsaWNrIC8gZXNjYXBlXG4gICAgICAgICAgICBpZighJChkb2N1bWVudCkuZGF0YSgnZWRpdGFibGUtaGFuZGxlcnMtYXR0YWNoZWQnKSkge1xuICAgICAgICAgICAgICAgIC8vY2xvc2UgYWxsIG9uIGVzY2FwZVxuICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLm9uKCdrZXl1cC5lZGl0YWJsZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLndoaWNoID09PSAyNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnLmVkaXRhYmxlLW9wZW4nKS5lZGl0YWJsZUNvbnRhaW5lcignaGlkZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy90b2RvOiByZXR1cm4gZm9jdXMgb24gZWxlbWVudCBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy9jbG9zZSBjb250YWluZXJzIHdoZW4gY2xpY2sgb3V0c2lkZSBcbiAgICAgICAgICAgICAgICAvLyhtb3VzZWRvd24gY291bGQgYmUgYmV0dGVyIHRoYW4gY2xpY2ssIGl0IGNsb3NlcyBldmVyeXRoaW5nIGFsc28gb24gZHJhZyBkcm9wKVxuICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLm9uKCdjbGljay5lZGl0YWJsZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICR0YXJnZXQgPSAkKGUudGFyZ2V0KSwgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVfY2xhc3NlcyA9IFsnLmVkaXRhYmxlLWNvbnRhaW5lcicsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcudWktZGF0ZXBpY2tlci1oZWFkZXInLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLmRhdGVwaWNrZXInLCAvL2luIGlubGluZSBtb2RlIGRhdGVwaWNrZXIgaXMgcmVuZGVyZWQgaW50byBib2R5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy5tb2RhbC1iYWNrZHJvcCcsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcuYm9vdHN0cmFwLXd5c2lodG1sNS1pbnNlcnQtaW1hZ2UtbW9kYWwnLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLmJvb3RzdHJhcC13eXNpaHRtbDUtaW5zZXJ0LWxpbmstbW9kYWwnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgZWxlbWVudCBpcyBkZXRhY2hlZC4gSXQgb2NjdXJzIHdoZW4gY2xpY2tpbmcgaW4gYm9vdHN0cmFwIGRhdGVwaWNrZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkLmNvbnRhaW5zKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9mb3Igc29tZSByZWFzb24gRkYgMjAgZ2VuZXJhdGVzIGV4dHJhIGV2ZW50IChjbGljaykgaW4gc2VsZWN0MiB3aWRnZXQgd2l0aCBlLnRhcmdldCA9IGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgIC8vd2UgbmVlZCB0byBmaWx0ZXIgaXQgdmlhIGNvbnN0cnVjdGlvbiBiZWxvdy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRhbGV0cy94LWVkaXRhYmxlL2lzc3Vlcy8xOTlcbiAgICAgICAgICAgICAgICAgICAgLy9Qb3NzaWJseSByZWxhdGVkIHRvIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTAxMTk3OTMvd2h5LWRvZXMtZmlyZWZveC1yZWFjdC1kaWZmZXJlbnRseS1mcm9tLXdlYmtpdC1hbmQtaWUtdG8tY2xpY2stZXZlbnQtb24tc2VsZWNcbiAgICAgICAgICAgICAgICAgICAgaWYoJHRhcmdldC5pcyhkb2N1bWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9pZiBjbGljayBpbnNpZGUgb25lIG9mIGV4Y2x1ZGUgY2xhc3NlcyAtLT4gbm8gbm90aGluZ1xuICAgICAgICAgICAgICAgICAgICBmb3IoaT0wOyBpPGV4Y2x1ZGVfY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCR0YXJnZXQuaXMoZXhjbHVkZV9jbGFzc2VzW2ldKSB8fCAkdGFyZ2V0LnBhcmVudHMoZXhjbHVkZV9jbGFzc2VzW2ldKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL2Nsb3NlIGFsbCBvcGVuIGNvbnRhaW5lcnMgKGV4Y2VwdCBvbmUgLSB0YXJnZXQpXG4gICAgICAgICAgICAgICAgICAgIFBvcHVwLnByb3RvdHlwZS5jbG9zZU90aGVycyhlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgJChkb2N1bWVudCkuZGF0YSgnZWRpdGFibGUtaGFuZGxlcnMtYXR0YWNoZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfSxcblxuICAgICAgICAvL3NwbGl0IG9wdGlvbnMgb24gY29udGFpbmVyT3B0aW9ucyBhbmQgZm9ybU9wdGlvbnNcbiAgICAgICAgc3BsaXRPcHRpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyT3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5mb3JtT3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZighJC5mblt0aGlzLmNvbnRhaW5lck5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuY29udGFpbmVyTmFtZSArICcgbm90IGZvdW5kLiBIYXZlIHlvdSBpbmNsdWRlZCBjb3JyZXNwb25kaW5nIGpzIGZpbGU/Jyk7ICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8va2V5cyBkZWZpbmVkIGluIGNvbnRhaW5lciBkZWZhdWx0cyBnbyB0byBjb250YWluZXIsIG90aGVycyBnbyB0byBmb3JtXG4gICAgICAgICAgICBmb3IodmFyIGsgaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICAgIGlmKGsgaW4gdGhpcy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lck9wdGlvbnNba10gPSB0aGlzLm9wdGlvbnNba107XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgIHRoaXMuZm9ybU9wdGlvbnNba10gPSB0aGlzLm9wdGlvbnNba107XG4gICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICBSZXR1cm5zIGpxdWVyeSBvYmplY3Qgb2YgY29udGFpbmVyXG4gICAgICAgIEBtZXRob2QgdGlwKClcbiAgICAgICAgKi8gICAgICAgICBcbiAgICAgICAgdGlwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcigpID8gdGhpcy5jb250YWluZXIoKS4kdGlwIDogbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKiByZXR1cm5zIGNvbnRhaW5lciBvYmplY3QgKi9cbiAgICAgICAgY29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXI7XG4gICAgICAgICAgICAvL2ZpcnN0LCB0cnkgZ2V0IGl0IGJ5IGBjb250YWluZXJEYXRhTmFtZWBcbiAgICAgICAgICAgIGlmKHRoaXMuY29udGFpbmVyRGF0YU5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZihjb250YWluZXIgPSB0aGlzLiRlbGVtZW50LmRhdGEodGhpcy5jb250YWluZXJEYXRhTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3NlY29uZCwgdHJ5IGBjb250YWluZXJOYW1lYFxuICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy4kZWxlbWVudC5kYXRhKHRoaXMuY29udGFpbmVyTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qIGNhbGwgbmF0aXZlIG1ldGhvZCBvZiB1bmRlcmx5aW5nIGNvbnRhaW5lciwgZS5nLiB0aGlzLiRlbGVtZW50LnBvcG92ZXIoJ21ldGhvZCcpICovIFxuICAgICAgICBjYWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnRbdGhpcy5jb250YWluZXJOYW1lXS5hcHBseSh0aGlzLiRlbGVtZW50LCBhcmd1bWVudHMpOyBcbiAgICAgICAgfSwgICAgICAgIFxuICAgICAgICBcbiAgICAgICAgaW5pdENvbnRhaW5lcjogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuY2FsbCh0aGlzLmNvbnRhaW5lck9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlckZvcm06IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kZm9ybVxuICAgICAgICAgICAgLmVkaXRhYmxlZm9ybSh0aGlzLmZvcm1PcHRpb25zKVxuICAgICAgICAgICAgLm9uKHtcbiAgICAgICAgICAgICAgICBzYXZlOiAkLnByb3h5KHRoaXMuc2F2ZSwgdGhpcyksIC8vY2xpY2sgb24gc3VibWl0IGJ1dHRvbiAodmFsdWUgY2hhbmdlZClcbiAgICAgICAgICAgICAgICBub2NoYW5nZTogJC5wcm94eShmdW5jdGlvbigpeyB0aGlzLmhpZGUoJ25vY2hhbmdlJyk7IH0sIHRoaXMpLCAvL2NsaWNrIG9uIHN1Ym1pdCBidXR0b24gKHZhbHVlIE5PVCBjaGFuZ2VkKSAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjYW5jZWw6ICQucHJveHkoZnVuY3Rpb24oKXsgdGhpcy5oaWRlKCdjYW5jZWwnKTsgfSwgdGhpcyksIC8vY2xpY2sgb24gY2FsY2VsIGJ1dHRvblxuICAgICAgICAgICAgICAgIHNob3c6ICQucHJveHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZGVsYXllZEhpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZSh0aGlzLmRlbGF5ZWRIaWRlLnJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGF5ZWRIaWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzKSwgLy9yZS1wb3NpdGlvbiBjb250YWluZXIgZXZlcnkgdGltZSBmb3JtIGlzIHNob3duIChvY2N1cnMgZWFjaCB0aW1lIGFmdGVyIGxvYWRpbmcgc3RhdGUpXG4gICAgICAgICAgICAgICAgcmVuZGVyaW5nOiAkLnByb3h5KHRoaXMuc2V0UG9zaXRpb24sIHRoaXMpLCAvL3RoaXMgYWxsb3dzIHRvIHBsYWNlIGNvbnRhaW5lciBjb3JyZWN0bHkgd2hlbiBsb2FkaW5nIHNob3duXG4gICAgICAgICAgICAgICAgcmVzaXplOiAkLnByb3h5KHRoaXMuc2V0UG9zaXRpb24sIHRoaXMpLCAvL3RoaXMgYWxsb3dzIHRvIHJlLXBvc2l0aW9uIGNvbnRhaW5lciB3aGVuIGZvcm0gc2l6ZSBpcyBjaGFuZ2VkIFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkOiAkLnByb3h5KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIC8qKiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIEZpcmVkIHdoZW4gY29udGFpbmVyIGlzIHNob3duIGFuZCBmb3JtIGlzIHJlbmRlcmVkIChmb3Igc2VsZWN0IHdpbGwgd2FpdCBmb3IgbG9hZGluZyBkcm9wZG93biBvcHRpb25zKS4gIFxuICAgICAgICAgICAgICAgICAgICAqKk5vdGU6KiogQm9vdHN0cmFwIHBvcG92ZXIgaGFzIG93biBgc2hvd25gIGV2ZW50IHRoYXQgbm93IGNhbm5vdCBiZSBzZXBhcmF0ZWQgZnJvbSB4LWVkaXRhYmxlJ3Mgb25lLlxuICAgICAgICAgICAgICAgICAgICBUaGUgd29ya2Fyb3VuZCBpcyB0byBjaGVjayBgYXJndW1lbnRzLmxlbmd0aGAgdGhhdCBpcyBhbHdheXMgYDJgIGZvciB4LWVkaXRhYmxlLiAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgQGV2ZW50IHNob3duIFxuICAgICAgICAgICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gZXZlbnQgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICQoJyN1c2VybmFtZScpLm9uKCdzaG93bicsIGZ1bmN0aW9uKGUsIGVkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZS5pbnB1dC4kaW5wdXQudmFsKCdvdmVyd3JpdGluZyB2YWx1ZSBvZiBpbnB1dC4uJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pOyAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAqKi8gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICBUT0RPOiBhZGRlZCBzZWNvbmQgcGFyYW0gbWFpbmx5IHRvIGRpc3Rpbmd1aXNoIGZyb20gYm9vdHN0cmFwJ3Mgc2hvd24gZXZlbnQuIEl0J3MgYSBob3RmaXggdGhhdCB3aWxsIGJlIHNvbHZlZCBpbiBmdXR1cmUgdmVyc2lvbnMgdmlhIG5hbWVzcGFjZWQgZXZlbnRzLiAgXG4gICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlckhhbmRsZXIoJ3Nob3duJywgJCh0aGlzLm9wdGlvbnMuc2NvcGUpLmRhdGEoJ2VkaXRhYmxlJykpOyBcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZWRpdGFibGVmb3JtKCdyZW5kZXInKTtcbiAgICAgICAgfSwgICAgICAgIFxuXG4gICAgICAgIC8qKlxuICAgICAgICBTaG93cyBjb250YWluZXIgd2l0aCBmb3JtXG4gICAgICAgIEBtZXRob2Qgc2hvdygpXG4gICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gY2xvc2VBbGwgV2hldGhlciB0byBjbG9zZSBhbGwgb3RoZXIgZWRpdGFibGUgY29udGFpbmVycyB3aGVuIHNob3dpbmcgdGhpcyBvbmUuIERlZmF1bHQgdHJ1ZS5cbiAgICAgICAgKiovXG4gICAgICAgIC8qIE5vdGU6IHBvc2h5dGlwIG93ZXJ3cml0ZXMgdGhpcyBtZXRob2QgdG90YWxseSEgKi8gICAgICAgICAgXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uIChjbG9zZUFsbCkge1xuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnZWRpdGFibGUtb3BlbicpO1xuICAgICAgICAgICAgaWYoY2xvc2VBbGwgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy9jbG9zZSBhbGwgb3BlbiBjb250YWluZXJzIChleGNlcHQgdGhpcylcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlT3RoZXJzKHRoaXMuJGVsZW1lbnRbMF0pOyAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vc2hvdyBjb250YWluZXIgaXRzZWxmXG4gICAgICAgICAgICB0aGlzLmlubmVyU2hvdygpO1xuICAgICAgICAgICAgdGhpcy50aXAoKS5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lckNsYXNzKTtcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIEN1cnJlbnRseSwgZm9ybSBpcyByZS1yZW5kZXJlZCBvbiBldmVyeSBzaG93LiBcbiAgICAgICAgICAgIFRoZSBtYWluIHJlYXNvbiBpcyB0aGF0IHdlIGRvbnQga25vdywgd2hhdCB3aWxsIGNvbnRhaW5lciBkbyB3aXRoIGNvbnRlbnQgd2hlbiBjbG9zZWQ6XG4gICAgICAgICAgICByZW1vdmUoKSwgZGV0YWNoKCkgb3IganVzdCBoaWRlKCkgLSBpdCBkZXBlbmRzIG9uIGNvbnRhaW5lci5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgRGV0YWNoaW5nIGZvcm0gaXRzZWxmIGJlZm9yZSBoaWRlIGFuZCByZS1pbnNlcnQgYmVmb3JlIHNob3cgaXMgZ29vZCBzb2x1dGlvbiwgXG4gICAgICAgICAgICBidXQgdmlzdWFsbHkgaXQgbG9va3MgdWdseSAtLT4gY29udGFpbmVyIGNoYW5nZXMgc2l6ZSBiZWZvcmUgaGlkZS4gIFxuICAgICAgICAgICAgKi8gICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaWYgZm9ybSBhbHJlYWR5IGV4aXN0IC0gZGVsZXRlIHByZXZpb3VzIGRhdGEgXG4gICAgICAgICAgICBpZih0aGlzLiRmb3JtKSB7XG4gICAgICAgICAgICAgICAgLy90b2RvOiBkZXN0cm95IHByZXYgZGF0YSFcbiAgICAgICAgICAgICAgICAvL3RoaXMuJGZvcm0uZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRmb3JtID0gJCgnPGRpdj4nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9pbnNlcnQgZm9ybSBpbnRvIGNvbnRhaW5lciBib2R5XG4gICAgICAgICAgICBpZih0aGlzLnRpcCgpLmlzKHRoaXMuaW5uZXJDc3MpKSB7XG4gICAgICAgICAgICAgICAgLy9mb3IgaW5saW5lIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgIHRoaXMudGlwKCkuYXBwZW5kKHRoaXMuJGZvcm0pOyBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aXAoKS5maW5kKHRoaXMuaW5uZXJDc3MpLmFwcGVuZCh0aGlzLiRmb3JtKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vcmVuZGVyIGZvcm1cbiAgICAgICAgICAgIHRoaXMucmVuZGVyRm9ybSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICBIaWRlcyBjb250YWluZXIgd2l0aCBmb3JtXG4gICAgICAgIEBtZXRob2QgaGlkZSgpXG4gICAgICAgIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gUmVhc29uIGNhdXNlZCBoaWRpbmcuIENhbiBiZSA8Y29kZT5zYXZlfGNhbmNlbHxvbmJsdXJ8bm9jaGFuZ2V8dW5kZWZpbmVkICg9bWFudWFsKTwvY29kZT5cbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uKHJlYXNvbikgeyAgXG4gICAgICAgICAgICBpZighdGhpcy50aXAoKSB8fCAhdGhpcy50aXAoKS5pcygnOnZpc2libGUnKSB8fCAhdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZWRpdGFibGUtb3BlbicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2lmIGZvcm0gaXMgc2F2aW5nIHZhbHVlLCBzY2hlZHVsZSBoaWRlXG4gICAgICAgICAgICBpZih0aGlzLiRmb3JtLmRhdGEoJ2VkaXRhYmxlZm9ybScpLmlzU2F2aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxheWVkSGlkZSA9IHtyZWFzb246IHJlYXNvbn07XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAgICBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxheWVkSGlkZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdlZGl0YWJsZS1vcGVuJyk7ICAgXG4gICAgICAgICAgICB0aGlzLmlubmVySGlkZSgpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEZpcmVkIHdoZW4gY29udGFpbmVyIHdhcyBoaWRkZW4uIEl0IG9jY3VycyBvbiBib3RoIHNhdmUgb3IgY2FuY2VsLiAgXG4gICAgICAgICAgICAqKk5vdGU6KiogQm9vdHN0cmFwIHBvcG92ZXIgaGFzIG93biBgaGlkZGVuYCBldmVudCB0aGF0IG5vdyBjYW5ub3QgYmUgc2VwYXJhdGVkIGZyb20geC1lZGl0YWJsZSdzIG9uZS5cbiAgICAgICAgICAgIFRoZSB3b3JrYXJvdW5kIGlzIHRvIGNoZWNrIGBhcmd1bWVudHMubGVuZ3RoYCB0aGF0IGlzIGFsd2F5cyBgMmAgZm9yIHgtZWRpdGFibGUuIFxuXG4gICAgICAgICAgICBAZXZlbnQgaGlkZGVuIFxuICAgICAgICAgICAgQHBhcmFtIHtvYmplY3R9IGV2ZW50IGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiBSZWFzb24gY2F1c2VkIGhpZGluZy4gQ2FuIGJlIDxjb2RlPnNhdmV8Y2FuY2VsfG9uYmx1cnxub2NoYW5nZXxtYW51YWw8L2NvZGU+XG4gICAgICAgICAgICBAZXhhbXBsZVxuICAgICAgICAgICAgJCgnI3VzZXJuYW1lJykub24oJ2hpZGRlbicsIGZ1bmN0aW9uKGUsIHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGlmKHJlYXNvbiA9PT0gJ3NhdmUnIHx8IHJlYXNvbiA9PT0gJ2NhbmNlbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9hdXRvLW9wZW4gbmV4dCBlZGl0YWJsZVxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJ3RyJykubmV4dCgpLmZpbmQoJy5lZGl0YWJsZScpLmVkaXRhYmxlKCdzaG93Jyk7XG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKiovXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXJIYW5kbGVyKCdoaWRkZW4nLCByZWFzb24gfHwgJ21hbnVhbCcpOyAgIFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qIGludGVybmFsIHNob3cgbWV0aG9kLiBUbyBiZSBvdmVyd3JpdHRlbiBpbiBjaGlsZCBjbGFzc2VzICovXG4gICAgICAgIGlubmVyU2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgIFxuICAgICAgICB9LCAgICAgICAgXG5cbiAgICAgICAgLyogaW50ZXJuYWwgaGlkZSBtZXRob2QuIFRvIGJlIG92ZXJ3cml0dGVuIGluIGNoaWxkIGNsYXNzZXMgKi9cbiAgICAgICAgaW5uZXJIaWRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBUb2dnbGVzIGNvbnRhaW5lciB2aXNpYmlsaXR5IChzaG93IC8gaGlkZSlcbiAgICAgICAgQG1ldGhvZCB0b2dnbGUoKVxuICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IGNsb3NlQWxsIFdoZXRoZXIgdG8gY2xvc2UgYWxsIG90aGVyIGVkaXRhYmxlIGNvbnRhaW5lcnMgd2hlbiBzaG93aW5nIHRoaXMgb25lLiBEZWZhdWx0IHRydWUuXG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbihjbG9zZUFsbCkge1xuICAgICAgICAgICAgaWYodGhpcy5jb250YWluZXIoKSAmJiB0aGlzLnRpcCgpICYmIHRoaXMudGlwKCkuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93KGNsb3NlQWxsKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgY29udGFpbmVyIHdoZW4gY29udGVudCBjaGFuZ2VkLlxuICAgICAgICBAbWV0aG9kIHNldFBvc2l0aW9uKClcbiAgICAgICAgKi8gICAgICAgXG4gICAgICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vdGJkIGluIGNoaWxkIGNsYXNzXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2F2ZTogZnVuY3Rpb24oZSwgcGFyYW1zKSB7XG4gICAgICAgICAgICAvKiogICAgICAgIFxuICAgICAgICAgICAgRmlyZWQgd2hlbiBuZXcgdmFsdWUgd2FzIHN1Ym1pdHRlZC4gWW91IGNhbiB1c2UgPGNvZGU+JCh0aGlzKS5kYXRhKCdlZGl0YWJsZUNvbnRhaW5lcicpPC9jb2RlPiBpbnNpZGUgaGFuZGxlciB0byBhY2Nlc3MgdG8gZWRpdGFibGVDb250YWluZXIgaW5zdGFuY2VcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgQGV2ZW50IHNhdmUgXG4gICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gZXZlbnQgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gcGFyYW1zIGFkZGl0aW9uYWwgcGFyYW1zXG4gICAgICAgICAgICBAcGFyYW0ge21peGVkfSBwYXJhbXMubmV3VmFsdWUgc3VibWl0dGVkIHZhbHVlXG4gICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gcGFyYW1zLnJlc3BvbnNlIGFqYXggcmVzcG9uc2VcbiAgICAgICAgICAgIEBleGFtcGxlXG4gICAgICAgICAgICAkKCcjdXNlcm5hbWUnKS5vbignc2F2ZScsIGZ1bmN0aW9uKGUsIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIC8vYXNzdW1pbmcgc2VydmVyIHJlc3BvbnNlOiAne3N1Y2Nlc3M6IHRydWV9J1xuICAgICAgICAgICAgICAgIHZhciBwayA9ICQodGhpcykuZGF0YSgnZWRpdGFibGVDb250YWluZXInKS5vcHRpb25zLnBrO1xuICAgICAgICAgICAgICAgIGlmKHBhcmFtcy5yZXNwb25zZSAmJiBwYXJhbXMucmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBhbGVydCgndmFsdWU6ICcgKyBwYXJhbXMubmV3VmFsdWUgKyAnIHdpdGggcGs6ICcgKyBwayArICcgc2F2ZWQhJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ2Vycm9yIScpOyBcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAqKi8gICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXJIYW5kbGVyKCdzYXZlJywgcGFyYW1zKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9oaWRlIG11c3QgYmUgYWZ0ZXIgdHJpZ2dlciwgYXMgc2F2aW5nIHZhbHVlIG1heSByZXF1aXJlIG1ldGhvZHMgb2YgcGx1Z2luLCBhcHBsaWVkIHRvIGlucHV0XG4gICAgICAgICAgICB0aGlzLmhpZGUoJ3NhdmUnKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgU2V0cyBuZXcgb3B0aW9uXG4gICAgICAgIFxuICAgICAgICBAbWV0aG9kIG9wdGlvbihrZXksIHZhbHVlKVxuICAgICAgICBAcGFyYW0ge3N0cmluZ30ga2V5IFxuICAgICAgICBAcGFyYW0ge21peGVkfSB2YWx1ZSBcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIG9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmKGtleSBpbiB0aGlzLmNvbnRhaW5lck9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lck9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29udGFpbmVyT3B0aW9uKGtleSwgdmFsdWUpOyBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtT3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYodGhpcy4kZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRmb3JtLmVkaXRhYmxlZm9ybSgnb3B0aW9uJywga2V5LCB2YWx1ZSk7ICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBzZXRDb250YWluZXJPcHRpb246IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbCgnb3B0aW9uJywga2V5LCB2YWx1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgIERlc3Ryb3lzIHRoZSBjb250YWluZXIgaW5zdGFuY2VcbiAgICAgICAgQG1ldGhvZCBkZXN0cm95KClcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJEZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignZGVzdHJveWVkJyk7XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZURhdGEoJ2VkaXRhYmxlQ29udGFpbmVyJyk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKiB0byBiZSBvdmVyd3JpdHRlbiBpbiBjaGlsZCBjbGFzc2VzICovXG4gICAgICAgIGlubmVyRGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgfSwgXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICBDbG9zZXMgb3RoZXIgY29udGFpbmVycyBleGNlcHQgb25lIHJlbGF0ZWQgdG8gcGFzc2VkIGVsZW1lbnQuIFxuICAgICAgICBPdGhlciBjb250YWluZXJzIGNhbiBiZSBjYW5jZWxsZWQgb3Igc3VibWl0dGVkIChkZXBlbmRzIG9uIG9uYmx1ciBvcHRpb24pXG4gICAgICAgICovXG4gICAgICAgIGNsb3NlT3RoZXJzOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAkKCcuZWRpdGFibGUtb3BlbicpLmVhY2goZnVuY3Rpb24oaSwgZWwpe1xuICAgICAgICAgICAgICAgIC8vZG8gbm90aGluZyB3aXRoIHBhc3NlZCBlbGVtZW50IGFuZCBpdCdzIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgaWYoZWwgPT09IGVsZW1lbnQgfHwgJChlbCkuZmluZChlbGVtZW50KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlIGNhbmNlbCBvciBzdWJtaXQgYWxsIG9wZW4gY29udGFpbmVycyBcbiAgICAgICAgICAgICAgICB2YXIgJGVsID0gJChlbCksXG4gICAgICAgICAgICAgICAgZWMgPSAkZWwuZGF0YSgnZWRpdGFibGVDb250YWluZXInKTtcblxuICAgICAgICAgICAgICAgIGlmKCFlYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47ICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoZWMub3B0aW9ucy5vbmJsdXIgPT09ICdjYW5jZWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICRlbC5kYXRhKCdlZGl0YWJsZUNvbnRhaW5lcicpLmhpZGUoJ29uYmx1cicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihlYy5vcHRpb25zLm9uYmx1ciA9PT0gJ3N1Ym1pdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgJGVsLmRhdGEoJ2VkaXRhYmxlQ29udGFpbmVyJykudGlwKCkuZmluZCgnZm9ybScpLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgQWN0aXZhdGVzIGlucHV0IG9mIHZpc2libGUgY29udGFpbmVyIChlLmcuIHNldCBmb2N1cylcbiAgICAgICAgQG1ldGhvZCBhY3RpdmF0ZSgpXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLnRpcCAmJiB0aGlzLnRpcCgpLmlzKCc6dmlzaWJsZScpICYmIHRoaXMuJGZvcm0pIHtcbiAgICAgICAgICAgICAgIHRoaXMuJGZvcm0uZGF0YSgnZWRpdGFibGVmb3JtJykuaW5wdXQuYWN0aXZhdGUoKTsgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gXG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgalF1ZXJ5IG1ldGhvZCB0byBpbml0aWFsaXplIGVkaXRhYmxlQ29udGFpbmVyLlxuICAgIFxuICAgIEBtZXRob2QgJCgpLmVkaXRhYmxlQ29udGFpbmVyKG9wdGlvbnMpXG4gICAgQHBhcmFtcyB7T2JqZWN0fSBvcHRpb25zXG4gICAgQGV4YW1wbGVcbiAgICAkKCcjZWRpdCcpLmVkaXRhYmxlQ29udGFpbmVyKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICB1cmw6ICcvcG9zdCcsXG4gICAgICAgIHBrOiAxLFxuICAgICAgICB2YWx1ZTogJ2hlbGxvJ1xuICAgIH0pO1xuICAgICoqLyAgXG4gICAgJC5mbi5lZGl0YWJsZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSxcbiAgICAgICAgICAgIGRhdGFLZXkgPSAnZWRpdGFibGVDb250YWluZXInLCBcbiAgICAgICAgICAgIGRhdGEgPSAkdGhpcy5kYXRhKGRhdGFLZXkpLFxuICAgICAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT09ICdvYmplY3QnICYmIG9wdGlvbixcbiAgICAgICAgICAgIENvbnN0cnVjdG9yID0gKG9wdGlvbnMubW9kZSA9PT0gJ2lubGluZScpID8gSW5saW5lIDogUG9wdXA7ICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5kYXRhKGRhdGFLZXksIChkYXRhID0gbmV3IENvbnN0cnVjdG9yKHRoaXMsIG9wdGlvbnMpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnc3RyaW5nJykgeyAvL2NhbGwgbWV0aG9kIFxuICAgICAgICAgICAgICAgIGRhdGFbb3B0aW9uXS5hcHBseShkYXRhLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG4gICAgICAgICAgICB9ICAgICAgICAgICAgXG4gICAgICAgIH0pO1xuICAgIH07ICAgICBcblxuICAgIC8vc3RvcmUgY29uc3RydWN0b3JzXG4gICAgJC5mbi5lZGl0YWJsZUNvbnRhaW5lci5Qb3B1cCA9IFBvcHVwO1xuICAgICQuZm4uZWRpdGFibGVDb250YWluZXIuSW5saW5lID0gSW5saW5lO1xuXG4gICAgLy9kZWZhdWx0c1xuICAgICQuZm4uZWRpdGFibGVDb250YWluZXIuZGVmYXVsdHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICBJbml0aWFsIHZhbHVlIG9mIGZvcm0gaW5wdXRcblxuICAgICAgICBAcHJvcGVydHkgdmFsdWUgXG4gICAgICAgIEB0eXBlIG1peGVkXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgQHByaXZhdGVcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBQbGFjZW1lbnQgb2YgY29udGFpbmVyIHJlbGF0aXZlIHRvIGVsZW1lbnQuIENhbiBiZSA8Y29kZT50b3B8cmlnaHR8Ym90dG9tfGxlZnQ8L2NvZGU+LiBOb3QgdXNlZCBmb3IgaW5saW5lIGNvbnRhaW5lci5cblxuICAgICAgICBAcHJvcGVydHkgcGxhY2VtZW50IFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgJ3RvcCdcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgcGxhY2VtZW50OiAndG9wJyxcbiAgICAgICAgLyoqXG4gICAgICAgIFdoZXRoZXIgdG8gaGlkZSBjb250YWluZXIgb24gc2F2ZS9jYW5jZWwuXG5cbiAgICAgICAgQHByb3BlcnR5IGF1dG9oaWRlIFxuICAgICAgICBAdHlwZSBib29sZWFuXG4gICAgICAgIEBkZWZhdWx0IHRydWVcbiAgICAgICAgQHByaXZhdGUgXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIGF1dG9oaWRlOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgQWN0aW9uIHdoZW4gdXNlciBjbGlja3Mgb3V0c2lkZSB0aGUgY29udGFpbmVyLiBDYW4gYmUgPGNvZGU+Y2FuY2VsfHN1Ym1pdHxpZ25vcmU8L2NvZGU+LiAgXG4gICAgICAgIFNldHRpbmcgPGNvZGU+aWdub3JlPC9jb2RlPiBhbGxvd3MgdG8gaGF2ZSBzZXZlcmFsIGNvbnRhaW5lcnMgb3Blbi4gXG5cbiAgICAgICAgQHByb3BlcnR5IG9uYmx1ciBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICdjYW5jZWwnXG4gICAgICAgIEBzaW5jZSAxLjEuMVxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBvbmJsdXI6ICdjYW5jZWwnLFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIEFuaW1hdGlvbiBzcGVlZCAoaW5saW5lIG1vZGUgb25seSlcbiAgICAgICAgQHByb3BlcnR5IGFuaW0gXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBhbmltOiBmYWxzZSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBNb2RlIG9mIGVkaXRhYmxlLCBjYW4gYmUgYHBvcHVwYCBvciBgaW5saW5lYCBcbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBtb2RlIFxuICAgICAgICBAdHlwZSBzdHJpbmcgICAgICAgICBcbiAgICAgICAgQGRlZmF1bHQgJ3BvcHVwJ1xuICAgICAgICBAc2luY2UgMS40LjAgICAgICAgIFxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBtb2RlOiAncG9wdXAnICAgICAgICBcbiAgICB9O1xuXG4gICAgLyogXG4gICAgKiB3b3JrYXJvdW5kIHRvIGhhdmUgJ2Rlc3Ryb3llZCcgZXZlbnQgdG8gZGVzdHJveSBwb3BvdmVyIHdoZW4gZWxlbWVudCBpcyBkZXN0cm95ZWRcbiAgICAqIHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIyMDA0OTQvanF1ZXJ5LXRyaWdnZXItZXZlbnQtd2hlbi1hbi1lbGVtZW50LWlzLXJlbW92ZWQtZnJvbS10aGUtZG9tXG4gICAgKi9cbiAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbC5kZXN0cm95ZWQgPSB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24obykge1xuICAgICAgICAgICAgaWYgKG8uaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIG8uaGFuZGxlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTsgICAgXG5cbn0od2luZG93LmpRdWVyeSkpO1xuXG4vKipcbiogRWRpdGFibGUgSW5saW5lIFxuKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBcbiAgICAvL2NvcHkgcHJvdG90eXBlIGZyb20gRWRpdGFibGVDb250YWluZXJcbiAgICAvL2V4dGVuZCBtZXRob2RzXG4gICAgJC5leHRlbmQoJC5mbi5lZGl0YWJsZUNvbnRhaW5lci5JbmxpbmUucHJvdG90eXBlLCAkLmZuLmVkaXRhYmxlQ29udGFpbmVyLlBvcHVwLnByb3RvdHlwZSwge1xuICAgICAgICBjb250YWluZXJOYW1lOiAnZWRpdGFibGVmb3JtJyxcbiAgICAgICAgaW5uZXJDc3M6ICcuZWRpdGFibGUtaW5saW5lJyxcbiAgICAgICAgY29udGFpbmVyQ2xhc3M6ICdlZGl0YWJsZS1jb250YWluZXIgZWRpdGFibGUtaW5saW5lJywgLy9jc3MgY2xhc3MgYXBwbGllZCB0byBjb250YWluZXIgZWxlbWVudFxuICAgICAgICAgICAgICAgICBcbiAgICAgICAgaW5pdENvbnRhaW5lcjogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIC8vY29udGFpbmVyIGlzIDxzcGFuPiBlbGVtZW50XG4gICAgICAgICAgICB0aGlzLiR0aXAgPSAkKCc8c3Bhbj48L3NwYW4+Jyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vY29udmVydCBhbmltIHRvIG1pbGlzZWNvbmRzIChpbnQpXG4gICAgICAgICAgICBpZighdGhpcy5vcHRpb25zLmFuaW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuYW5pbSA9IDA7XG4gICAgICAgICAgICB9ICAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBzcGxpdE9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy9hbGwgb3B0aW9ucyBhcmUgcGFzc2VkIHRvIGZvcm1cbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyT3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5mb3JtT3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHRpcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIHJldHVybiB0aGlzLiR0aXA7IFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgaW5uZXJTaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LmhpZGUoKTtcbiAgICAgICAgICAgIHRoaXMudGlwKCkuaW5zZXJ0QWZ0ZXIodGhpcy4kZWxlbWVudCkuc2hvdygpO1xuICAgICAgICB9LCBcbiAgICAgICAgXG4gICAgICAgIGlubmVySGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy4kdGlwLmhpZGUodGhpcy5vcHRpb25zLmFuaW0sICQucHJveHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5zaG93KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lckRlc3Ryb3koKTtcbiAgICAgICAgICAgIH0sIHRoaXMpKTsgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBpbm5lckRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYodGhpcy50aXAoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGlwKCkuZW1wdHkoKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBcbiAgICB9KTtcblxufSh3aW5kb3cualF1ZXJ5KSk7XG4vKipcbk1ha2VzIGVkaXRhYmxlIGFueSBIVE1MIGVsZW1lbnQgb24gdGhlIHBhZ2UuIEFwcGxpZWQgYXMgalF1ZXJ5IG1ldGhvZC5cblxuQGNsYXNzIGVkaXRhYmxlXG5AdXNlcyBlZGl0YWJsZUNvbnRhaW5lclxuKiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBFZGl0YWJsZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgICAgICAvL2RhdGEtKiBoYXMgbW9yZSBwcmlvcml0eSBvdmVyIGpzIG9wdGlvbnM6IGJlY2F1c2UgZHluYW1pY2FsbHkgY3JlYXRlZCBlbGVtZW50cyBtYXkgY2hhbmdlIGRhdGEtKiBcbiAgICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGUuZGVmYXVsdHMsIG9wdGlvbnMsICQuZm4uZWRpdGFibGV1dGlscy5nZXRDb25maWdEYXRhKHRoaXMuJGVsZW1lbnQpKTsgIFxuICAgICAgICBpZih0aGlzLm9wdGlvbnMuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdExpdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvL2NoZWNrIGZvciB0cmFuc2l0aW9uIHN1cHBvcnRcbiAgICAgICAgaWYodGhpcy5vcHRpb25zLmhpZ2hsaWdodCAmJiAhJC5mbi5lZGl0YWJsZXV0aWxzLnN1cHBvcnRzVHJhbnNpdGlvbnMoKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmhpZ2hsaWdodCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEVkaXRhYmxlLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IEVkaXRhYmxlLCBcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlzVmFsdWVCeVRleHQgPSBmYWxzZSwgXG4gICAgICAgICAgICAgICAgZG9BdXRvdGV4dCwgZmluYWxpemU7XG5cbiAgICAgICAgICAgIC8vbmFtZVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm5hbWUgPSB0aGlzLm9wdGlvbnMubmFtZSB8fCB0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJyk7XG4gICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2NyZWF0ZSBpbnB1dCBvZiBzcGVjaWZpZWQgdHlwZS4gSW5wdXQgbmVlZGVkIGFscmVhZHkgaGVyZSB0byBjb252ZXJ0IHZhbHVlIGZvciBpbml0aWFsIGRpc3BsYXkgKGUuZy4gc2hvdyB0ZXh0IGJ5IGlkIGZvciBzZWxlY3QpXG4gICAgICAgICAgICAvL2Fsc28gd2Ugc2V0IHNjb3BlIG9wdGlvbiB0byBoYXZlIGFjY2VzcyB0byBlbGVtZW50IGluc2lkZSBpbnB1dCBzcGVjaWZpYyBjYWxsYmFja3MgKGUuIGcuIHNvdXJjZSBhcyBmdW5jdGlvbilcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zY29wZSA9IHRoaXMuJGVsZW1lbnRbMF07IFxuICAgICAgICAgICAgdGhpcy5pbnB1dCA9ICQuZm4uZWRpdGFibGV1dGlscy5jcmVhdGVJbnB1dCh0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgaWYoIXRoaXMuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IFxuICAgICAgICAgICAgfSAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAvL3NldCB2YWx1ZSBmcm9tIHNldHRpbmdzIG9yIGJ5IGVsZW1lbnQncyB0ZXh0XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnZhbHVlID09PSB1bmRlZmluZWQgfHwgdGhpcy5vcHRpb25zLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuaW5wdXQuaHRtbDJ2YWx1ZSgkLnRyaW0odGhpcy4kZWxlbWVudC5odG1sKCkpKTtcbiAgICAgICAgICAgICAgICBpc1ZhbHVlQnlUZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgIHZhbHVlIGNhbiBiZSBzdHJpbmcgd2hlbiByZWNlaXZlZCBmcm9tICdkYXRhLXZhbHVlJyBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgIGZvciBjb21wbGV4dCBvYmplY3RzIHZhbHVlIGNhbiBiZSBzZXQgYXMganNvbiBzdHJpbmcgaW4gZGF0YS12YWx1ZSBhdHRyaWJ1dGUsIFxuICAgICAgICAgICAgICAgICAgZS5nLiBkYXRhLXZhbHVlPVwie2NpdHk6ICdNb3Njb3cnLCBzdHJlZXQ6ICdMZW5pbmEnfVwiXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudmFsdWUgPSAkLmZuLmVkaXRhYmxldXRpbHMudHJ5UGFyc2VKc29uKHRoaXMub3B0aW9ucy52YWx1ZSwgdHJ1ZSk7IFxuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiB0aGlzLm9wdGlvbnMudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmlucHV0LnN0cjJ2YWx1ZSh0aGlzLm9wdGlvbnMudmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm9wdGlvbnMudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2FkZCAnZWRpdGFibGUnIGNsYXNzIHRvIGV2ZXJ5IGVkaXRhYmxlIGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ2VkaXRhYmxlJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vc3BlY2lmaWNhbGx5IGZvciBcInRleHRhcmVhXCIgYWRkIGNsYXNzIC5lZGl0YWJsZS1wcmUtd3JhcHBlZCB0byBrZWVwIGxpbmVicmVha3NcbiAgICAgICAgICAgIGlmKHRoaXMuaW5wdXQudHlwZSA9PT0gJ3RleHRhcmVhJykge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ2VkaXRhYmxlLXByZS13cmFwcGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vYXR0YWNoIGhhbmRsZXIgYWN0aXZhdGluZyBlZGl0YWJsZS4gSW4gZGlzYWJsZWQgbW9kZSBpdCBqdXN0IHByZXZlbnQgZGVmYXVsdCBhY3Rpb24gKHVzZWZ1bCBmb3IgbGlua3MpXG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMudG9nZ2xlICE9PSAnbWFudWFsJykge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ2VkaXRhYmxlLWNsaWNrJyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5vbih0aGlzLm9wdGlvbnMudG9nZ2xlICsgJy5lZGl0YWJsZScsICQucHJveHkoZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICAgICAgIC8vcHJldmVudCBmb2xsb3dpbmcgbGluayBpZiBlZGl0YWJsZSBlbmFibGVkXG4gICAgICAgICAgICAgICAgICAgIGlmKCF0aGlzLm9wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9zdG9wIHByb3BhZ2F0aW9uIG5vdCByZXF1aXJlZCBiZWNhdXNlIGluIGRvY3VtZW50IGNsaWNrIGhhbmRsZXIgaXQgY2hlY2tzIGV2ZW50IHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAvL2Uuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMudG9nZ2xlID09PSAnbW91c2VlbnRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZm9yIGhvdmVyIG9ubHkgc2hvdyBjb250YWluZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy93aGVuIHRvZ2dsZT0nY2xpY2snIHdlIHNob3VsZCBub3QgY2xvc2UgYWxsIG90aGVyIGNvbnRhaW5lcnMgYXMgdGhleSB3aWxsIGJlIGNsb3NlZCBhdXRvbWF0aWNhbGx5IGluIGRvY3VtZW50IGNsaWNrIGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xvc2VBbGwgPSAodGhpcy5vcHRpb25zLnRvZ2dsZSAhPT0gJ2NsaWNrJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZShjbG9zZUFsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cigndGFiaW5kZXgnLCAtMSk7IC8vZG8gbm90IHN0b3AgZm9jdXMgb24gZWxlbWVudCB3aGVuIHRvZ2dsZWQgbWFudWFsbHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9pZiBkaXNwbGF5IGlzIGZ1bmN0aW9uIGl0J3MgZmFyIG1vcmUgY29udmluaWVudCB0byBoYXZlIGF1dG90ZXh0ID0gYWx3YXlzIHRvIHJlbmRlciBjb3JyZWN0bHkgb24gaW5pdFxuICAgICAgICAgICAgLy9zZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpdGFsZXRzL3gtZWRpdGFibGUteWlpL2lzc3Vlcy8zNFxuICAgICAgICAgICAgaWYodHlwZW9mIHRoaXMub3B0aW9ucy5kaXNwbGF5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmF1dG90ZXh0ID0gJ2Fsd2F5cyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vY2hlY2sgY29uZGl0aW9ucyBmb3IgYXV0b3RleHQ6XG4gICAgICAgICAgICBzd2l0Y2godGhpcy5vcHRpb25zLmF1dG90ZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2Fsd2F5cyc6XG4gICAgICAgICAgICAgICBkb0F1dG90ZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgICAgICAgICAgIC8vaWYgZWxlbWVudCB0ZXh0IGlzIGVtcHR5IGFuZCB2YWx1ZSBpcyBkZWZpbmVkIGFuZCB2YWx1ZSBub3QgZ2VuZXJhdGVkIGJ5IHRleHQgLS0+IHJ1biBhdXRvdGV4dFxuICAgICAgICAgICAgICAgIGRvQXV0b3RleHQgPSAhJC50cmltKHRoaXMuJGVsZW1lbnQudGV4dCgpKS5sZW5ndGggJiYgdGhpcy52YWx1ZSAhPT0gbnVsbCAmJiB0aGlzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWlzVmFsdWVCeVRleHQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgZG9BdXRvdGV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2RlcGVuZGluZyBvbiBhdXRvdGV4dCBydW4gcmVuZGVyKCkgb3IganVzdCBmaW5pbGl6ZSBpbml0XG4gICAgICAgICAgICAkLndoZW4oZG9BdXRvdGV4dCA/IHRoaXMucmVuZGVyKCkgOiB0cnVlKS50aGVuKCQucHJveHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlKCk7IFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIC8qKiAgICAgICAgXG4gICAgICAgICAgICAgICBGaXJlZCB3aGVuIGVsZW1lbnQgd2FzIGluaXRpYWxpemVkIGJ5IGAkKCkuZWRpdGFibGUoKWAgbWV0aG9kLiBcbiAgICAgICAgICAgICAgIFBsZWFzZSBub3RlIHRoYXQgeW91IHNob3VsZCBzZXR1cCBgaW5pdGAgaGFuZGxlciAqKmJlZm9yZSoqIGFwcGx5aW5nIGBlZGl0YWJsZWAuIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICBAZXZlbnQgaW5pdCBcbiAgICAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBldmVudCBldmVudCBvYmplY3RcbiAgICAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBlZGl0YWJsZSBlZGl0YWJsZSBpbnN0YW5jZSAoYXMgaGVyZSBpdCBjYW5ub3QgYWNjZXNzZWQgdmlhIGRhdGEoJ2VkaXRhYmxlJykpXG4gICAgICAgICAgICAgICBAc2luY2UgMS4yLjBcbiAgICAgICAgICAgICAgIEBleGFtcGxlXG4gICAgICAgICAgICAgICAkKCcjdXNlcm5hbWUnKS5vbignaW5pdCcsIGZ1bmN0aW9uKGUsIGVkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgYWxlcnQoJ2luaXRpYWxpemVkICcgKyBlZGl0YWJsZS5vcHRpb25zLm5hbWUpO1xuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAkKCcjdXNlcm5hbWUnKS5lZGl0YWJsZSgpO1xuICAgICAgICAgICAgICAgKiovICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VySGFuZGxlcignaW5pdCcsIHRoaXMpO1xuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qXG4gICAgICAgICBJbml0aWFsaXplcyBwYXJlbnQgZWxlbWVudCBmb3IgbGl2ZSBlZGl0YWJsZXMgXG4gICAgICAgICovXG4gICAgICAgIGluaXRMaXZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgLy9zdG9yZSBzZWxlY3RvciBcbiAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gdGhpcy5vcHRpb25zLnNlbGVjdG9yO1xuICAgICAgICAgICAvL21vZGlmeSBvcHRpb25zIGZvciBjaGlsZCBlbGVtZW50c1xuICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2VsZWN0b3IgPSBmYWxzZTsgXG4gICAgICAgICAgIHRoaXMub3B0aW9ucy5hdXRvdGV4dCA9ICduZXZlcic7XG4gICAgICAgICAgIC8vbGlzdGVuIHRvZ2dsZSBldmVudHNcbiAgICAgICAgICAgdGhpcy4kZWxlbWVudC5vbih0aGlzLm9wdGlvbnMudG9nZ2xlICsgJy5lZGl0YWJsZScsIHNlbGVjdG9yLCAkLnByb3h5KGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgICAgdmFyICR0YXJnZXQgPSAkKGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgIGlmKCEkdGFyZ2V0LmRhdGEoJ2VkaXRhYmxlJykpIHtcbiAgICAgICAgICAgICAgICAgICAvL2lmIGRlbGVnYXRlZCBlbGVtZW50IGluaXRpYWxseSBlbXB0eSwgd2UgbmVlZCB0byBjbGVhciBpdCdzIHRleHQgKHRoYXQgd2FzIG1hbnVhbGx5IHNldCB0byBgZW1wdHlgIGJ5IHVzZXIpXG4gICAgICAgICAgICAgICAgICAgLy9zZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpdGFsZXRzL3gtZWRpdGFibGUvaXNzdWVzLzEzNyBcbiAgICAgICAgICAgICAgICAgICBpZigkdGFyZ2V0Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy5lbXB0eWNsYXNzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICR0YXJnZXQuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgJHRhcmdldC5lZGl0YWJsZSh0aGlzLm9wdGlvbnMpLnRyaWdnZXIoZSk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgIH0sIHRoaXMpKTsgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICBSZW5kZXJzIHZhbHVlIGludG8gZWxlbWVudCdzIHRleHQuXG4gICAgICAgIENhbiBjYWxsIGN1c3RvbSBkaXNwbGF5IG1ldGhvZCBmcm9tIG9wdGlvbnMuXG4gICAgICAgIENhbiByZXR1cm4gZGVmZXJyZWQgb2JqZWN0LlxuICAgICAgICBAbWV0aG9kIHJlbmRlcigpXG4gICAgICAgIEBwYXJhbSB7bWl4ZWR9IHJlc3BvbnNlIHNlcnZlciByZXNwb25zZSAoaWYgZXhpc3QpIHRvIHBhc3MgaW50byBkaXNwbGF5IGZ1bmN0aW9uXG4gICAgICAgICovICAgICAgICAgIFxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAvL2RvIG5vdCBkaXNwbGF5IGFueXRoaW5nXG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZGlzcGxheSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaWYgaW5wdXQgaGFzIGB2YWx1ZTJodG1sRmluYWxgIG1ldGhvZCwgd2UgcGFzcyBjYWxsYmFjayBpbiB0aGlyZCBwYXJhbSB0byBiZSBjYWxsZWQgd2hlbiBzb3VyY2UgaXMgbG9hZGVkXG4gICAgICAgICAgICBpZih0aGlzLmlucHV0LnZhbHVlMmh0bWxGaW5hbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlucHV0LnZhbHVlMmh0bWwodGhpcy52YWx1ZSwgdGhpcy4kZWxlbWVudFswXSwgdGhpcy5vcHRpb25zLmRpc3BsYXksIHJlc3BvbnNlKTsgXG4gICAgICAgICAgICAvL2lmIGRpc3BsYXkgbWV0aG9kIGRlZmluZWQgLS0+IHVzZSBpdCAgICBcbiAgICAgICAgICAgIH0gZWxzZSBpZih0eXBlb2YgdGhpcy5vcHRpb25zLmRpc3BsYXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmRpc3BsYXkuY2FsbCh0aGlzLiRlbGVtZW50WzBdLCB0aGlzLnZhbHVlLCByZXNwb25zZSk7XG4gICAgICAgICAgICAvL2Vsc2UgdXNlIGlucHV0J3Mgb3JpZ2luYWwgdmFsdWUyaHRtbCgpIG1ldGhvZCAgICBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQudmFsdWUyaHRtbCh0aGlzLnZhbHVlLCB0aGlzLiRlbGVtZW50WzBdKTsgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgRW5hYmxlcyBlZGl0YWJsZVxuICAgICAgICBAbWV0aG9kIGVuYWJsZSgpXG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgZW5hYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcygnZWRpdGFibGUtZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRW1wdHkodGhpcy5pc0VtcHR5KTtcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy50b2dnbGUgIT09ICdtYW51YWwnKSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy4kZWxlbWVudC5hdHRyKCd0YWJpbmRleCcpID09PSAnLTEnKSB7ICAgIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUF0dHIoJ3RhYmluZGV4Jyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgRGlzYWJsZXMgZWRpdGFibGVcbiAgICAgICAgQG1ldGhvZCBkaXNhYmxlKClcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRpc2FibGVkID0gdHJ1ZTsgXG4gICAgICAgICAgICB0aGlzLmhpZGUoKTsgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnZWRpdGFibGUtZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRW1wdHkodGhpcy5pc0VtcHR5KTtcbiAgICAgICAgICAgIC8vZG8gbm90IHN0b3AgZm9jdXMgb24gdGhpcyBlbGVtZW50XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ3RhYmluZGV4JywgLTEpOyAgICAgICAgICAgICAgICBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBUb2dnbGVzIGVuYWJsZWQgLyBkaXNhYmxlZCBzdGF0ZSBvZiBlZGl0YWJsZSBlbGVtZW50XG4gICAgICAgIEBtZXRob2QgdG9nZ2xlRGlzYWJsZWQoKVxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgdG9nZ2xlRGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7IFxuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZSgpOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgIFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIFNldHMgbmV3IG9wdGlvblxuICAgICAgICBcbiAgICAgICAgQG1ldGhvZCBvcHRpb24oa2V5LCB2YWx1ZSlcbiAgICAgICAgQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBrZXkgb3B0aW9uIG5hbWUgb3Igb2JqZWN0IHdpdGggc2V2ZXJhbCBvcHRpb25zXG4gICAgICAgIEBwYXJhbSB7bWl4ZWR9IHZhbHVlIG9wdGlvbiBuZXcgdmFsdWVcbiAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgJCgnLmVkaXRhYmxlJykuZWRpdGFibGUoJ29wdGlvbicsICdwaycsIDIpO1xuICAgICAgICAqKi8gICAgICAgICAgXG4gICAgICAgIG9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgLy9zZXQgb3B0aW9uKHMpIGJ5IG9iamVjdFxuICAgICAgICAgICAgaWYoa2V5ICYmIHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAkLmVhY2goa2V5LCAkLnByb3h5KGZ1bmN0aW9uKGssIHYpe1xuICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb24oJC50cmltKGspLCB2KTsgXG4gICAgICAgICAgICAgICB9LCB0aGlzKSk7IFxuICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3NldCBvcHRpb24gYnkgc3RyaW5nICAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2Rpc2FibGVkXG4gICAgICAgICAgICBpZihrZXkgPT09ICdkaXNhYmxlZCcpIHtcbiAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/IHRoaXMuZGlzYWJsZSgpIDogdGhpcy5lbmFibGUoKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vdmFsdWVcbiAgICAgICAgICAgIGlmKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3RyYW5zZmVyIG5ldyBvcHRpb24gdG8gY29udGFpbmVyISBcbiAgICAgICAgICAgIGlmKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIub3B0aW9uKGtleSwgdmFsdWUpOyAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3Bhc3Mgb3B0aW9uIHRvIGlucHV0IGRpcmVjdGx5IChhcyBpdCBwb2ludHMgdG8gdGhlIHNhbWUgaW4gZm9ybSlcbiAgICAgICAgICAgIGlmKHRoaXMuaW5wdXQub3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5vcHRpb24oa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgfSwgICAgICAgICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgKiBzZXQgZW1wdHl0ZXh0IGlmIGVsZW1lbnQgaXMgZW1wdHlcbiAgICAgICAgKi9cbiAgICAgICAgaGFuZGxlRW1wdHk6IGZ1bmN0aW9uIChpc0VtcHR5KSB7XG4gICAgICAgICAgICAvL2RvIG5vdCBoYW5kbGUgZW1wdHkgaWYgd2UgZG8gbm90IGRpc3BsYXkgYW55dGhpbmdcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5kaXNwbGF5ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogXG4gICAgICAgICAgICBpc0VtcHR5IG1heSBiZSBzZXQgZGlyZWN0bHkgYXMgcGFyYW0gb2YgbWV0aG9kLlxuICAgICAgICAgICAgSXQgaXMgcmVxdWlyZWQgd2hlbiB3ZSBlbmFibGUvZGlzYWJsZSBmaWVsZCBhbmQgY2FuJ3QgcmVseSBvbiBjb250ZW50IFxuICAgICAgICAgICAgYXMgbm9kZSBjb250ZW50IGlzIHRleHQ6IFwiRW1wdHlcIiB0aGF0IGlzIG5vdCBlbXB0eSAlKVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmKGlzRW1wdHkgIT09IHVuZGVmaW5lZCkgeyBcbiAgICAgICAgICAgICAgICB0aGlzLmlzRW1wdHkgPSBpc0VtcHR5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL2RldGVjdCBlbXB0eVxuICAgICAgICAgICAgICAgIC8vZm9yIHNvbWUgaW5wdXRzIHdlIG5lZWQgbW9yZSBzbWFydCBjaGVja1xuICAgICAgICAgICAgICAgIC8vZS5nLiB3eXNpaHRtbDUgbWF5IGhhdmUgPGJyPiwgPHA+PC9wPiwgPGltZz5cbiAgICAgICAgICAgICAgICBpZih0eXBlb2YodGhpcy5pbnB1dC5pc0VtcHR5KSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRW1wdHkgPSB0aGlzLmlucHV0LmlzRW1wdHkodGhpcy4kZWxlbWVudCk7ICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRW1wdHkgPSAkLnRyaW0odGhpcy4kZWxlbWVudC5odG1sKCkpID09PSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9lbXB0eXRleHQgc2hvd24gb25seSBmb3IgZW5hYmxlZFxuICAgICAgICAgICAgaWYoIXRoaXMub3B0aW9ucy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5odG1sKHRoaXMub3B0aW9ucy5lbXB0eXRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZW1wdHljbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZW1wdHljbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYodGhpcy5vcHRpb25zLmVtcHR5Y2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZW1wdHljbGFzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL2JlbG93IHJlcXVpcmVkIGlmIGVsZW1lbnQgZGlzYWJsZSBwcm9wZXJ0eSB3YXMgY2hhbmdlZFxuICAgICAgICAgICAgICAgIGlmKHRoaXMuaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5lbXB0eWNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5lbXB0eWNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIFNob3dzIGNvbnRhaW5lciB3aXRoIGZvcm1cbiAgICAgICAgQG1ldGhvZCBzaG93KClcbiAgICAgICAgQHBhcmFtIHtib29sZWFufSBjbG9zZUFsbCBXaGV0aGVyIHRvIGNsb3NlIGFsbCBvdGhlciBlZGl0YWJsZSBjb250YWluZXJzIHdoZW4gc2hvd2luZyB0aGlzIG9uZS4gRGVmYXVsdCB0cnVlLlxuICAgICAgICAqKi8gIFxuICAgICAgICBzaG93OiBmdW5jdGlvbiAoY2xvc2VBbGwpIHtcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9pbml0IGVkaXRhYmxlQ29udGFpbmVyOiBwb3BvdmVyLCB0b29sdGlwLCBpbmxpbmUsIGV0Yy4uXG4gICAgICAgICAgICBpZighdGhpcy5jb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyT3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiB0aGlzLmlucHV0IC8vcGFzcyBpbnB1dCB0byBmb3JtIChhcyBpdCBpcyBhbHJlYWR5IGNyZWF0ZWQpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5lZGl0YWJsZUNvbnRhaW5lcihjb250YWluZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAvL2xpc3RlbiBgc2F2ZWAgZXZlbnQgXG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5vbihcInNhdmUuaW50ZXJuYWxcIiwgJC5wcm94eSh0aGlzLnNhdmUsIHRoaXMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuJGVsZW1lbnQuZGF0YSgnZWRpdGFibGVDb250YWluZXInKTsgXG4gICAgICAgICAgICB9IGVsc2UgaWYodGhpcy5jb250YWluZXIudGlwKCkuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9ICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vc2hvdyBjb250YWluZXJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnNob3coY2xvc2VBbGwpO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIEhpZGVzIGNvbnRhaW5lciB3aXRoIGZvcm1cbiAgICAgICAgQG1ldGhvZCBoaWRlKClcbiAgICAgICAgKiovICAgICAgIFxuICAgICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7ICAgXG4gICAgICAgICAgICBpZih0aGlzLmNvbnRhaW5lcikgeyAgXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIFRvZ2dsZXMgY29udGFpbmVyIHZpc2liaWxpdHkgKHNob3cgLyBoaWRlKVxuICAgICAgICBAbWV0aG9kIHRvZ2dsZSgpXG4gICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gY2xvc2VBbGwgV2hldGhlciB0byBjbG9zZSBhbGwgb3RoZXIgZWRpdGFibGUgY29udGFpbmVycyB3aGVuIHNob3dpbmcgdGhpcyBvbmUuIERlZmF1bHQgdHJ1ZS5cbiAgICAgICAgKiovICBcbiAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbihjbG9zZUFsbCkge1xuICAgICAgICAgICAgaWYodGhpcy5jb250YWluZXIgJiYgdGhpcy5jb250YWluZXIudGlwKCkuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93KGNsb3NlQWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgICogY2FsbGVkIHdoZW4gZm9ybSB3YXMgc3VibWl0dGVkXG4gICAgICAgICovICAgICAgICAgIFxuICAgICAgICBzYXZlOiBmdW5jdGlvbihlLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIC8vbWFyayBlbGVtZW50IHdpdGggdW5zYXZlZCBjbGFzcyBpZiBuZWVkZWRcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy51bnNhdmVkY2xhc3MpIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICBBZGQgdW5zYXZlZCBjc3MgdG8gZWxlbWVudCBpZjpcbiAgICAgICAgICAgICAgICAgIC0gdXJsIGlzIG5vdCB1c2VyJ3MgZnVuY3Rpb24gXG4gICAgICAgICAgICAgICAgICAtIHZhbHVlIHdhcyBub3Qgc2VudCB0byBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgIC0gcGFyYW1zLnJlc3BvbnNlID09PSB1bmRlZmluZWQsIHRoYXQgbWVhbnMgZGF0YSB3YXMgbm90IHNlbnRcbiAgICAgICAgICAgICAgICAgIC0gdmFsdWUgY2hhbmdlZCBcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBzZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VudCA9IHNlbnQgfHwgdHlwZW9mIHRoaXMub3B0aW9ucy51cmwgPT09ICdmdW5jdGlvbic7XG4gICAgICAgICAgICAgICAgc2VudCA9IHNlbnQgfHwgdGhpcy5vcHRpb25zLmRpc3BsYXkgPT09IGZhbHNlOyBcbiAgICAgICAgICAgICAgICBzZW50ID0gc2VudCB8fCBwYXJhbXMucmVzcG9uc2UgIT09IHVuZGVmaW5lZDsgXG4gICAgICAgICAgICAgICAgc2VudCA9IHNlbnQgfHwgKHRoaXMub3B0aW9ucy5zYXZlbm9jaGFuZ2UgJiYgdGhpcy5pbnB1dC52YWx1ZTJzdHIodGhpcy52YWx1ZSkgIT09IHRoaXMuaW5wdXQudmFsdWUyc3RyKHBhcmFtcy5uZXdWYWx1ZSkpOyBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihzZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLnVuc2F2ZWRjbGFzcyk7IFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnVuc2F2ZWRjbGFzcyk7ICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaGlnaGxpZ2h0IHdoZW4gc2F2aW5nXG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdmFyICRlID0gdGhpcy4kZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgYmdDb2xvciA9ICRlLmNzcygnYmFja2dyb3VuZC1jb2xvcicpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAkZS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIGlmKGJnQ29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJnQ29sb3IgPSAnJzsgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJGUuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJywgYmdDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgICRlLmFkZENsYXNzKCdlZGl0YWJsZS1iZy10cmFuc2l0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgJGUucmVtb3ZlQ2xhc3MoJ2VkaXRhYmxlLWJnLXRyYW5zaXRpb24nKTsgIFxuICAgICAgICAgICAgICAgICAgICB9LCAxNzAwKTtcbiAgICAgICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vc2V0IG5ldyB2YWx1ZVxuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZShwYXJhbXMubmV3VmFsdWUsIGZhbHNlLCBwYXJhbXMucmVzcG9uc2UpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvKiogICAgICAgIFxuICAgICAgICAgICAgRmlyZWQgd2hlbiBuZXcgdmFsdWUgd2FzIHN1Ym1pdHRlZC4gWW91IGNhbiB1c2UgPGNvZGU+JCh0aGlzKS5kYXRhKCdlZGl0YWJsZScpPC9jb2RlPiB0byBhY2Nlc3MgdG8gZWRpdGFibGUgaW5zdGFuY2VcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgQGV2ZW50IHNhdmUgXG4gICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gZXZlbnQgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gcGFyYW1zIGFkZGl0aW9uYWwgcGFyYW1zXG4gICAgICAgICAgICBAcGFyYW0ge21peGVkfSBwYXJhbXMubmV3VmFsdWUgc3VibWl0dGVkIHZhbHVlXG4gICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gcGFyYW1zLnJlc3BvbnNlIGFqYXggcmVzcG9uc2VcbiAgICAgICAgICAgIEBleGFtcGxlXG4gICAgICAgICAgICAkKCcjdXNlcm5hbWUnKS5vbignc2F2ZScsIGZ1bmN0aW9uKGUsIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIGFsZXJ0KCdTYXZlZCB2YWx1ZTogJyArIHBhcmFtcy5uZXdWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICoqL1xuICAgICAgICAgICAgLy9ldmVudCBpdHNlbGYgaXMgdHJpZ2dlcmVkIGJ5IGVkaXRhYmxlQ29udGFpbmVyLiBEZXNjcmlwdGlvbiBoZXJlIGlzIG9ubHkgZm9yIGRvY3VtZW50YXRpb24gICAgICAgICAgICAgIFxuICAgICAgICB9LFxuXG4gICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy52YWxpZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudmFsaWRhdGUuY2FsbCh0aGlzLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBTZXRzIG5ldyB2YWx1ZSBvZiBlZGl0YWJsZVxuICAgICAgICBAbWV0aG9kIHNldFZhbHVlKHZhbHVlLCBjb252ZXJ0U3RyKVxuICAgICAgICBAcGFyYW0ge21peGVkfSB2YWx1ZSBuZXcgdmFsdWUgXG4gICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gY29udmVydFN0ciB3aGV0aGVyIHRvIGNvbnZlcnQgdmFsdWUgZnJvbSBzdHJpbmcgdG8gaW50ZXJuYWwgZm9ybWF0XG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24odmFsdWUsIGNvbnZlcnRTdHIsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZihjb252ZXJ0U3RyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuaW5wdXQuc3RyMnZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5jb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5vcHRpb24oJ3ZhbHVlJywgdGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkLndoZW4odGhpcy5yZW5kZXIocmVzcG9uc2UpKVxuICAgICAgICAgICAgLnRoZW4oJC5wcm94eShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUVtcHR5KCk7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgQWN0aXZhdGVzIGlucHV0IG9mIHZpc2libGUgY29udGFpbmVyIChlLmcuIHNldCBmb2N1cylcbiAgICAgICAgQG1ldGhvZCBhY3RpdmF0ZSgpXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWN0aXZhdGUoKTsgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgUmVtb3ZlcyBlZGl0YWJsZSBmZWF0dXJlIGZyb20gZWxlbWVudFxuICAgICAgICBAbWV0aG9kIGRlc3Ryb3koKVxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZih0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZGVzdHJveSgpOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy50b2dnbGUgIT09ICdtYW51YWwnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcygnZWRpdGFibGUtY2xpY2snKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZih0aGlzLm9wdGlvbnMudG9nZ2xlICsgJy5lZGl0YWJsZScpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoXCJzYXZlLmludGVybmFsXCIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdlZGl0YWJsZSBlZGl0YWJsZS1vcGVuIGVkaXRhYmxlLWRpc2FibGVkJyk7XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZURhdGEoJ2VkaXRhYmxlJyk7XG4gICAgICAgIH0gICAgICAgIFxuICAgIH07XG5cbiAgICAvKiBFRElUQUJMRSBQTFVHSU4gREVGSU5JVElPTlxuICAgICogPT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAgIC8qKlxuICAgIGpRdWVyeSBtZXRob2QgdG8gaW5pdGlhbGl6ZSBlZGl0YWJsZSBlbGVtZW50LlxuICAgIFxuICAgIEBtZXRob2QgJCgpLmVkaXRhYmxlKG9wdGlvbnMpXG4gICAgQHBhcmFtcyB7T2JqZWN0fSBvcHRpb25zXG4gICAgQGV4YW1wbGVcbiAgICAkKCcjdXNlcm5hbWUnKS5lZGl0YWJsZSh7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgdXJsOiAnL3Bvc3QnLFxuICAgICAgICBwazogMVxuICAgIH0pO1xuICAgICoqL1xuICAgICQuZm4uZWRpdGFibGUgPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIC8vc3BlY2lhbCBBUEkgbWV0aG9kcyByZXR1cm5pbmcgbm9uLWpxdWVyeSBvYmplY3RcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9LCBhcmdzID0gYXJndW1lbnRzLCBkYXRha2V5ID0gJ2VkaXRhYmxlJztcbiAgICAgICAgc3dpdGNoIChvcHRpb24pIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgUnVucyBjbGllbnQtc2lkZSB2YWxpZGF0aW9uIGZvciBhbGwgbWF0Y2hlZCBlZGl0YWJsZXNcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgQG1ldGhvZCB2YWxpZGF0ZSgpXG4gICAgICAgICAgICBAcmV0dXJucyB7T2JqZWN0fSB2YWxpZGF0aW9uIGVycm9ycyBtYXBcbiAgICAgICAgICAgIEBleGFtcGxlXG4gICAgICAgICAgICAkKCcjdXNlcm5hbWUsICNmdWxsbmFtZScpLmVkaXRhYmxlKCd2YWxpZGF0ZScpO1xuICAgICAgICAgICAgLy8gcG9zc2libGUgcmVzdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB1c2VybmFtZTogXCJ1c2VybmFtZSBpcyByZXF1aXJlZFwiLFxuICAgICAgICAgICAgICBmdWxsbmFtZTogXCJmdWxsbmFtZSBzaG91bGQgYmUgbWluaW11bSAzIGxldHRlcnMgbGVuZ3RoXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICoqL1xuICAgICAgICAgICAgY2FzZSAndmFsaWRhdGUnOlxuICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksIGRhdGEgPSAkdGhpcy5kYXRhKGRhdGFrZXkpLCBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgKGVycm9yID0gZGF0YS52YWxpZGF0ZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2RhdGEub3B0aW9ucy5uYW1lXSA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIFJldHVybnMgY3VycmVudCB2YWx1ZXMgb2YgZWRpdGFibGUgZWxlbWVudHMuICAgXG4gICAgICAgICAgICBOb3RlIHRoYXQgaXQgcmV0dXJucyBhbiAqKm9iamVjdCoqIHdpdGggbmFtZS12YWx1ZSBwYWlycywgbm90IGEgdmFsdWUgaXRzZWxmLiBJdCBhbGxvd3MgdG8gZ2V0IGRhdGEgZnJvbSBzZXZlcmFsIGVsZW1lbnRzLiAgICBcbiAgICAgICAgICAgIElmIHZhbHVlIG9mIHNvbWUgZWRpdGFibGUgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgIGl0IGlzIGV4Y2x1ZGVkIGZyb20gcmVzdWx0IG9iamVjdC5cbiAgICAgICAgICAgIFdoZW4gcGFyYW0gYGlzU2luZ2xlYCBpcyBzZXQgdG8gKip0cnVlKiogLSBpdCBpcyBzdXBwb3NlZCB5b3UgaGF2ZSBzaW5nbGUgZWxlbWVudCBhbmQgd2lsbCByZXR1cm4gdmFsdWUgb2YgZWRpdGFibGUgaW5zdGVhZCBvZiBvYmplY3QuICAgXG4gICAgICAgICAgICAgXG4gICAgICAgICAgICBAbWV0aG9kIGdldFZhbHVlKClcbiAgICAgICAgICAgIEBwYXJhbSB7Ym9vbH0gaXNTaW5nbGUgd2hldGhlciB0byByZXR1cm4ganVzdCB2YWx1ZSBvZiBzaW5nbGUgZWxlbWVudFxuICAgICAgICAgICAgQHJldHVybnMge09iamVjdH0gb2JqZWN0IG9mIGVsZW1lbnQgbmFtZXMgYW5kIHZhbHVlc1xuICAgICAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgICAgICQoJyN1c2VybmFtZSwgI2Z1bGxuYW1lJykuZWRpdGFibGUoJ2dldFZhbHVlJyk7XG4gICAgICAgICAgICAvL3Jlc3VsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgIHVzZXJuYW1lOiBcInN1cGVydXNlclwiLFxuICAgICAgICAgICAgZnVsbG5hbWU6IFwiSm9oblwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2lzU2luZ2xlID0gdHJ1ZVxuICAgICAgICAgICAgJCgnI3VzZXJuYW1lJykuZWRpdGFibGUoJ2dldFZhbHVlJywgdHJ1ZSk7XG4gICAgICAgICAgICAvL3Jlc3VsdCBcInN1cGVydXNlclwiIFxuICAgICAgICAgICAgKiovXG4gICAgICAgICAgICBjYXNlICdnZXRWYWx1ZSc6XG4gICAgICAgICAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiBhcmd1bWVudHNbMV0gPT09IHRydWUpIHsgLy9pc1NpbmdsZSA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5lcSgwKS5kYXRhKGRhdGFrZXkpLnZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLCBkYXRhID0gJHRoaXMuZGF0YShkYXRha2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBkYXRhLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2RhdGEub3B0aW9ucy5uYW1lXSA9IGRhdGEuaW5wdXQudmFsdWUyc3VibWl0KGRhdGEudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIFRoaXMgbWV0aG9kIGNvbGxlY3RzIHZhbHVlcyBmcm9tIHNldmVyYWwgZWRpdGFibGUgZWxlbWVudHMgYW5kIHN1Ym1pdCB0aGVtIGFsbCB0byBzZXJ2ZXIuICAgXG4gICAgICAgICAgICBJbnRlcm5hbGx5IGl0IHJ1bnMgY2xpZW50LXNpZGUgdmFsaWRhdGlvbiBmb3IgYWxsIGZpZWxkcyBhbmQgc3VibWl0cyBvbmx5IGluIGNhc2Ugb2Ygc3VjY2Vzcy4gIFxuICAgICAgICAgICAgU2VlIDxhIGhyZWY9XCIjbmV3cmVjb3JkXCI+Y3JlYXRpbmcgbmV3IHJlY29yZHM8L2E+IGZvciBkZXRhaWxzLiAgXG4gICAgICAgICAgICBTaW5jZSAxLjUuMSBgc3VibWl0YCBjYW4gYmUgYXBwbGllZCB0byBzaW5nbGUgZWxlbWVudCB0byBzZW5kIGRhdGEgcHJvZ3JhbW1hdGljYWxseS4gSW4gdGhhdCBjYXNlXG4gICAgICAgICAgICBgdXJsYCwgYHN1Y2Nlc3NgIGFuZCBgZXJyb3JgIGlzIHRha2VuIGZyb20gaW5pdGlhbCBvcHRpb25zIGFuZCB5b3UgY2FuIGp1c3QgY2FsbCBgJCgnI3VzZXJuYW1lJykuZWRpdGFibGUoJ3N1Ym1pdCcpYC4gXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIEBtZXRob2Qgc3VibWl0KG9wdGlvbnMpXG4gICAgICAgICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBcbiAgICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnVybCB1cmwgdG8gc3VibWl0IGRhdGEgXG4gICAgICAgICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5kYXRhIGFkZGl0aW9uYWwgZGF0YSB0byBzdWJtaXRcbiAgICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmFqYXhPcHRpb25zIGFkZGl0aW9uYWwgYWpheCBvcHRpb25zXG4gICAgICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLmVycm9yKG9iaikgZXJyb3IgaGFuZGxlciBcbiAgICAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuc3VjY2VzcyhvYmosY29uZmlnKSBzdWNjZXNzIGhhbmRsZXJcbiAgICAgICAgICAgIEByZXR1cm5zIHtPYmplY3R9IGpRdWVyeSBvYmplY3RcbiAgICAgICAgICAgICoqL1xuICAgICAgICAgICAgY2FzZSAnc3VibWl0JzogIC8vY29sbGVjdHMgdmFsdWUsIHZhbGlkYXRlIGFuZCBzdWJtaXQgdG8gc2VydmVyIGZvciBjcmVhdGluZyBuZXcgcmVjb3JkXG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IGFyZ3VtZW50c1sxXSB8fCB7fSxcbiAgICAgICAgICAgICAgICAkZWxlbXMgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGVycm9ycyA9IHRoaXMuZWRpdGFibGUoJ3ZhbGlkYXRlJyk7XG5cbiAgICAgICAgICAgICAgICAvLyB2YWxpZGF0aW9uIG9rXG4gICAgICAgICAgICAgICAgaWYoJC5pc0VtcHR5T2JqZWN0KGVycm9ycykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFqYXhPcHRpb25zID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHNpbmdsZSBlbGVtZW50IHVzZSB1cmwsIHN1Y2Nlc3MgZXRjIGZyb20gb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICBpZigkZWxlbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWRpdGFibGUgPSAkZWxlbXMuZGF0YSgnZWRpdGFibGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc3RhbmRhcmQgcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGVkaXRhYmxlLm9wdGlvbnMubmFtZSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZWRpdGFibGUuaW5wdXQudmFsdWUyc3VibWl0KGVkaXRhYmxlLnZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwazogKHR5cGVvZiBlZGl0YWJsZS5vcHRpb25zLnBrID09PSAnZnVuY3Rpb24nKSA/IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZS5vcHRpb25zLnBrLmNhbGwoZWRpdGFibGUub3B0aW9ucy5zY29wZSkgOiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdGFibGUub3B0aW9ucy5wayBcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYWRkaXRpb25hbCBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBlZGl0YWJsZS5vcHRpb25zLnBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IGVkaXRhYmxlLm9wdGlvbnMucGFyYW1zLmNhbGwoZWRpdGFibGUub3B0aW9ucy5zY29wZSwgcGFyYW1zKTsgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RyeSBwYXJzZSBqc29uIGluIHNpbmdsZSBxdW90ZXMgKGZyb20gZGF0YS1wYXJhbXMgYXR0cmlidXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlLm9wdGlvbnMucGFyYW1zID0gJC5mbi5lZGl0YWJsZXV0aWxzLnRyeVBhcnNlSnNvbihlZGl0YWJsZS5vcHRpb25zLnBhcmFtcywgdHJ1ZSk7ICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQocGFyYW1zLCBlZGl0YWJsZS5vcHRpb25zLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFqYXhPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZWRpdGFibGUub3B0aW9ucy51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdQT1NUJyAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2Ugc3VjY2VzcyAvIGVycm9yIGZyb20gb3B0aW9ucyBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5zdWNjZXNzID0gY29uZmlnLnN1Y2Nlc3MgfHwgZWRpdGFibGUub3B0aW9ucy5zdWNjZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmVycm9yID0gY29uZmlnLmVycm9yIHx8IGVkaXRhYmxlLm9wdGlvbnMuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gbXVsdGlwbGUgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmVkaXRhYmxlKCdnZXRWYWx1ZScpOyBcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgYWpheE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBjb25maWcudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlcywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1BPU1QnXG4gICAgICAgICAgICAgICAgICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgICAgICAgICAvLyBhamF4IHN1Y2Nlc3MgY2FsbGFiY2sgKHJlc3BvbnNlIDIwMCBPSylcbiAgICAgICAgICAgICAgICAgICAgYWpheE9wdGlvbnMuc3VjY2VzcyA9IHR5cGVvZiBjb25maWcuc3VjY2VzcyA9PT0gJ2Z1bmN0aW9uJyA/IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnN1Y2Nlc3MuY2FsbCgkZWxlbXMsIHJlc3BvbnNlLCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSA6ICQubm9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gYWpheCBlcnJvciBjYWxsYWJja1xuICAgICAgICAgICAgICAgICAgICBhamF4T3B0aW9ucy5lcnJvciA9IHR5cGVvZiBjb25maWcuZXJyb3IgPT09ICdmdW5jdGlvbicgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmVycm9yLmFwcGx5KCRlbGVtcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gOiAkLm5vb3A7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBleHRlbmQgYWpheE9wdGlvbnMgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKGNvbmZpZy5hamF4T3B0aW9ucykgeyBcbiAgICAgICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKGFqYXhPcHRpb25zLCBjb25maWcuYWpheE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBleHRyYSBkYXRhIFxuICAgICAgICAgICAgICAgICAgICBpZihjb25maWcuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQoYWpheE9wdGlvbnMuZGF0YSwgY29uZmlnLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBwZXJmb3JtIGFqYXggcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICAkLmFqYXgoYWpheE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vY2xpZW50LXNpZGUgdmFsaWRhdGlvbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgY29uZmlnLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZXJyb3IuY2FsbCgkZWxlbXMsIGVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vcmV0dXJuIGpxdWVyeSBvYmplY3RcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLCBcbiAgICAgICAgICAgICAgICBkYXRhID0gJHRoaXMuZGF0YShkYXRha2V5KSwgXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT09ICdvYmplY3QnICYmIG9wdGlvbjtcblxuICAgICAgICAgICAgLy9mb3IgZGVsZWdhdGVkIHRhcmdldHMgZG8gbm90IHN0b3JlIGBlZGl0YWJsZWAgb2JqZWN0IGZvciBlbGVtZW50XG4gICAgICAgICAgICAvL2l0J3MgYWxsb3dzIHNldmVyYWwgZGlmZmVyZW50IHNlbGVjdG9ycy5cbiAgICAgICAgICAgIC8vc2VlOiBodHRwczovL2dpdGh1Yi5jb20vdml0YWxldHMveC1lZGl0YWJsZS9pc3N1ZXMvMzEyICAgIFxuICAgICAgICAgICAgaWYob3B0aW9ucyAmJiBvcHRpb25zLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBFZGl0YWJsZSh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm47IFxuICAgICAgICAgICAgfSAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuZGF0YShkYXRha2V5LCAoZGF0YSA9IG5ldyBFZGl0YWJsZSh0aGlzLCBvcHRpb25zKSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PT0gJ3N0cmluZycpIHsgLy9jYWxsIG1ldGhvZCBcbiAgICAgICAgICAgICAgICBkYXRhW29wdGlvbl0uYXBwbHkoZGF0YSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgfSk7XG4gICAgfTsgICAgXG4gICAgICAgICAgICBcblxuICAgICQuZm4uZWRpdGFibGUuZGVmYXVsdHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICBUeXBlIG9mIGlucHV0LiBDYW4gYmUgPGNvZGU+dGV4dHx0ZXh0YXJlYXxzZWxlY3R8ZGF0ZXxjaGVja2xpc3Q8L2NvZGU+IGFuZCBtb3JlXG5cbiAgICAgICAgQHByb3BlcnR5IHR5cGUgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCAndGV4dCdcbiAgICAgICAgKiovXG4gICAgICAgIHR5cGU6ICd0ZXh0JywgICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgU2V0cyBkaXNhYmxlZCBzdGF0ZSBvZiBlZGl0YWJsZVxuXG4gICAgICAgIEBwcm9wZXJ0eSBkaXNhYmxlZCBcbiAgICAgICAgQHR5cGUgYm9vbGVhblxuICAgICAgICBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgSG93IHRvIHRvZ2dsZSBlZGl0YWJsZS4gQ2FuIGJlIDxjb2RlPmNsaWNrfGRibGNsaWNrfG1vdXNlZW50ZXJ8bWFudWFsPC9jb2RlPi4gICBcbiAgICAgICAgV2hlbiBzZXQgdG8gPGNvZGU+bWFudWFsPC9jb2RlPiB5b3Ugc2hvdWxkIG1hbnVhbGx5IGNhbGwgPGNvZGU+c2hvdy9oaWRlPC9jb2RlPiBtZXRob2RzIG9mIGVkaXRhYmxlLiAgICBcbiAgICAgICAgKipOb3RlKio6IGlmIHlvdSBjYWxsIDxjb2RlPnNob3c8L2NvZGU+IG9yIDxjb2RlPnRvZ2dsZTwvY29kZT4gaW5zaWRlICoqY2xpY2sqKiBoYW5kbGVyIG9mIHNvbWUgRE9NIGVsZW1lbnQsIFxuICAgICAgICB5b3UgbmVlZCB0byBhcHBseSA8Y29kZT5lLnN0b3BQcm9wYWdhdGlvbigpPC9jb2RlPiBiZWNhdXNlIGNvbnRhaW5lcnMgYXJlIGJlaW5nIGNsb3NlZCBvbiBhbnkgY2xpY2sgb24gZG9jdW1lbnQuXG4gICAgICAgIFxuICAgICAgICBAZXhhbXBsZVxuICAgICAgICAkKCcjZWRpdC1idXR0b24nKS5jbGljayhmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgJCgnI3VzZXJuYW1lJykuZWRpdGFibGUoJ3RvZ2dsZScpO1xuICAgICAgICB9KTtcblxuICAgICAgICBAcHJvcGVydHkgdG9nZ2xlIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgJ2NsaWNrJ1xuICAgICAgICAqKi8gICAgICAgICAgXG4gICAgICAgIHRvZ2dsZTogJ2NsaWNrJyxcbiAgICAgICAgLyoqXG4gICAgICAgIFRleHQgc2hvd24gd2hlbiBlbGVtZW50IGlzIGVtcHR5LlxuXG4gICAgICAgIEBwcm9wZXJ0eSBlbXB0eXRleHQgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCAnRW1wdHknXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBlbXB0eXRleHQ6ICdFbXB0eScsXG4gICAgICAgIC8qKlxuICAgICAgICBBbGxvd3MgdG8gYXV0b21hdGljYWxseSBzZXQgZWxlbWVudCdzIHRleHQgYmFzZWQgb24gaXQncyB2YWx1ZS4gQ2FuIGJlIDxjb2RlPmF1dG98YWx3YXlzfG5ldmVyPC9jb2RlPi4gVXNlZnVsIGZvciBzZWxlY3QgYW5kIGRhdGUuXG4gICAgICAgIEZvciBleGFtcGxlLCBpZiBkcm9wZG93biBsaXN0IGlzIDxjb2RlPnsxOiAnYScsIDI6ICdiJ308L2NvZGU+IGFuZCBlbGVtZW50J3MgdmFsdWUgc2V0IHRvIDxjb2RlPjE8L2NvZGU+LCBpdCdzIGh0bWwgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHNldCB0byA8Y29kZT4nYSc8L2NvZGU+LiAgXG4gICAgICAgIDxjb2RlPmF1dG88L2NvZGU+IC0gdGV4dCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2V0IG9ubHkgaWYgZWxlbWVudCBpcyBlbXB0eS4gIFxuICAgICAgICA8Y29kZT5hbHdheXN8bmV2ZXI8L2NvZGU+IC0gYWx3YXlzKG5ldmVyKSB0cnkgdG8gc2V0IGVsZW1lbnQncyB0ZXh0LlxuXG4gICAgICAgIEBwcm9wZXJ0eSBhdXRvdGV4dCBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICdhdXRvJ1xuICAgICAgICAqKi8gICAgICAgICAgXG4gICAgICAgIGF1dG90ZXh0OiAnYXV0bycsIFxuICAgICAgICAvKipcbiAgICAgICAgSW5pdGlhbCB2YWx1ZSBvZiBpbnB1dC4gSWYgbm90IHNldCwgdGFrZW4gZnJvbSBlbGVtZW50J3MgdGV4dC4gIFxuICAgICAgICBOb3RlLCB0aGF0IGlmIGVsZW1lbnQncyB0ZXh0IGlzIGVtcHR5IC0gdGV4dCBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBmcm9tIHZhbHVlIGFuZCBjYW4gYmUgY3VzdG9taXplZCAoc2VlIGBhdXRvdGV4dGAgb3B0aW9uKS4gIFxuICAgICAgICBGb3IgZXhhbXBsZSwgdG8gZGlzcGxheSBjdXJyZW5jeSBzaWduOlxuICAgICAgICBAZXhhbXBsZVxuICAgICAgICA8YSBpZD1cInByaWNlXCIgZGF0YS10eXBlPVwidGV4dFwiIGRhdGEtdmFsdWU9XCIxMDBcIj48L2E+XG4gICAgICAgIDxzY3JpcHQ+XG4gICAgICAgICQoJyNwcmljZScpLmVkaXRhYmxlKHtcbiAgICAgICAgICAgIC4uLlxuICAgICAgICAgICAgZGlzcGxheTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgJCh0aGlzKS50ZXh0KHZhbHVlICsgJyQnKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0pIFxuICAgICAgICA8L3NjcmlwdD5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IHZhbHVlIFxuICAgICAgICBAdHlwZSBtaXhlZFxuICAgICAgICBAZGVmYXVsdCBlbGVtZW50J3MgdGV4dFxuICAgICAgICAqKi9cbiAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBDYWxsYmFjayB0byBwZXJmb3JtIGN1c3RvbSBkaXNwbGF5aW5nIG9mIHZhbHVlIGluIGVsZW1lbnQncyB0ZXh0LiAgXG4gICAgICAgIElmIGBudWxsYCwgZGVmYXVsdCBpbnB1dCdzIGRpc3BsYXkgdXNlZC4gIFxuICAgICAgICBJZiBgZmFsc2VgLCBubyBkaXNwbGF5aW5nIG1ldGhvZHMgd2lsbCBiZSBjYWxsZWQsIGVsZW1lbnQncyB0ZXh0IHdpbGwgbmV2ZXIgY2hhbmdlLiAgXG4gICAgICAgIFJ1bnMgdW5kZXIgZWxlbWVudCdzIHNjb3BlLiAgXG4gICAgICAgIF8qKlBhcmFtZXRlcnM6KipfICBcbiAgICAgICAgXG4gICAgICAgICogYHZhbHVlYCBjdXJyZW50IHZhbHVlIHRvIGJlIGRpc3BsYXllZFxuICAgICAgICAqIGByZXNwb25zZWAgc2VydmVyIHJlc3BvbnNlIChpZiBkaXNwbGF5IGNhbGxlZCBhZnRlciBhamF4IHN1Ym1pdCksIHNpbmNlIDEuNC4wXG4gICAgICAgICBcbiAgICAgICAgRm9yIF9pbnB1dHMgd2l0aCBzb3VyY2VfIChzZWxlY3QsIGNoZWNrbGlzdCkgcGFyYW1ldGVycyBhcmUgZGlmZmVyZW50OiAgXG4gICAgICAgICAgXG4gICAgICAgICogYHZhbHVlYCBjdXJyZW50IHZhbHVlIHRvIGJlIGRpc3BsYXllZFxuICAgICAgICAqIGBzb3VyY2VEYXRhYCBhcnJheSBvZiBpdGVtcyBmb3IgY3VycmVudCBpbnB1dCAoZS5nLiBkcm9wZG93biBpdGVtcykgXG4gICAgICAgICogYHJlc3BvbnNlYCBzZXJ2ZXIgcmVzcG9uc2UgKGlmIGRpc3BsYXkgY2FsbGVkIGFmdGVyIGFqYXggc3VibWl0KSwgc2luY2UgMS40LjBcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICBUbyBnZXQgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW1zIHVzZSBgJC5mbi5lZGl0YWJsZXV0aWxzLml0ZW1zQnlWYWx1ZSh2YWx1ZSwgc291cmNlRGF0YSlgLlxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IGRpc3BsYXkgXG4gICAgICAgIEB0eXBlIGZ1bmN0aW9ufGJvb2xlYW5cbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICBAc2luY2UgMS4yLjBcbiAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgZGlzcGxheTogZnVuY3Rpb24odmFsdWUsIHNvdXJjZURhdGEpIHtcbiAgICAgICAgICAgLy9kaXNwbGF5IGNoZWNrbGlzdCBhcyBjb21tYS1zZXBhcmF0ZWQgdmFsdWVzXG4gICAgICAgICAgIHZhciBodG1sID0gW10sXG4gICAgICAgICAgICAgICBjaGVja2VkID0gJC5mbi5lZGl0YWJsZXV0aWxzLml0ZW1zQnlWYWx1ZSh2YWx1ZSwgc291cmNlRGF0YSk7XG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgaWYoY2hlY2tlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICQuZWFjaChjaGVja2VkLCBmdW5jdGlvbihpLCB2KSB7IGh0bWwucHVzaCgkLmZuLmVkaXRhYmxldXRpbHMuZXNjYXBlKHYudGV4dCkpOyB9KTtcbiAgICAgICAgICAgICAgICQodGhpcykuaHRtbChodG1sLmpvaW4oJywgJykpO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgJCh0aGlzKS5lbXB0eSgpOyBcbiAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgZGlzcGxheTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIENzcyBjbGFzcyBhcHBsaWVkIHdoZW4gZWRpdGFibGUgdGV4dCBpcyBlbXB0eS5cblxuICAgICAgICBAcHJvcGVydHkgZW1wdHljbGFzcyBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBzaW5jZSAxLjQuMSAgICAgICAgXG4gICAgICAgIEBkZWZhdWx0IGVkaXRhYmxlLWVtcHR5XG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIGVtcHR5Y2xhc3M6ICdlZGl0YWJsZS1lbXB0eScsXG4gICAgICAgIC8qKlxuICAgICAgICBDc3MgY2xhc3MgYXBwbGllZCB3aGVuIHZhbHVlIHdhcyBzdG9yZWQgYnV0IG5vdCBzZW50IHRvIHNlcnZlciAoYHBrYCBpcyBlbXB0eSBvciBgc2VuZCA9ICduZXZlcidgKS4gIFxuICAgICAgICBZb3UgbWF5IHNldCBpdCB0byBgbnVsbGAgaWYgeW91IHdvcmsgd2l0aCBlZGl0YWJsZXMgbG9jYWxseSBhbmQgc3VibWl0IHRoZW0gdG9nZXRoZXIuICBcblxuICAgICAgICBAcHJvcGVydHkgdW5zYXZlZGNsYXNzIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQHNpbmNlIDEuNC4xICAgICAgICBcbiAgICAgICAgQGRlZmF1bHQgZWRpdGFibGUtdW5zYXZlZFxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICB1bnNhdmVkY2xhc3M6ICdlZGl0YWJsZS11bnNhdmVkJyxcbiAgICAgICAgLyoqXG4gICAgICAgIElmIHNlbGVjdG9yIGlzIHByb3ZpZGVkLCBlZGl0YWJsZSB3aWxsIGJlIGRlbGVnYXRlZCB0byB0aGUgc3BlY2lmaWVkIHRhcmdldHMuICBcbiAgICAgICAgVXNlZnVsbCBmb3IgZHluYW1pY2FsbHkgZ2VuZXJhdGVkIERPTSBlbGVtZW50cy4gIFxuICAgICAgICAqKlBsZWFzZSBub3RlKiosIHRoYXQgZGVsZWdhdGVkIHRhcmdldHMgY2FuJ3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBgZW1wdHl0ZXh0YCBhbmQgYGF1dG90ZXh0YCBvcHRpb25zLCBcbiAgICAgICAgYXMgdGhleSBhY3R1YWxseSBiZWNvbWUgZWRpdGFibGUgb25seSBhZnRlciBmaXJzdCBjbGljay4gIFxuICAgICAgICBZb3Ugc2hvdWxkIG1hbnVhbGx5IHNldCBjbGFzcyBgZWRpdGFibGUtY2xpY2tgIHRvIHRoZXNlIGVsZW1lbnRzLiAgXG4gICAgICAgIEFsc28sIGlmIGVsZW1lbnQgb3JpZ2luYWxseSBlbXB0eSB5b3Ugc2hvdWxkIGFkZCBjbGFzcyBgZWRpdGFibGUtZW1wdHlgLCBzZXQgYGRhdGEtdmFsdWU9XCJcImAgYW5kIHdyaXRlIGVtcHR5dGV4dCBpbnRvIGVsZW1lbnQ6XG5cbiAgICAgICAgQHByb3BlcnR5IHNlbGVjdG9yIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQHNpbmNlIDEuNC4xICAgICAgICBcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICBAZXhhbXBsZVxuICAgICAgICA8ZGl2IGlkPVwidXNlclwiPlxuICAgICAgICAgIDwhLS0gZW1wdHkgLS0+XG4gICAgICAgICAgPGEgaHJlZj1cIiNcIiBkYXRhLW5hbWU9XCJ1c2VybmFtZVwiIGRhdGEtdHlwZT1cInRleHRcIiBjbGFzcz1cImVkaXRhYmxlLWNsaWNrIGVkaXRhYmxlLWVtcHR5XCIgZGF0YS12YWx1ZT1cIlwiIHRpdGxlPVwiVXNlcm5hbWVcIj5FbXB0eTwvYT5cbiAgICAgICAgICA8IS0tIG5vbi1lbXB0eSAtLT5cbiAgICAgICAgICA8YSBocmVmPVwiI1wiIGRhdGEtbmFtZT1cImdyb3VwXCIgZGF0YS10eXBlPVwic2VsZWN0XCIgZGF0YS1zb3VyY2U9XCIvZ3JvdXBzXCIgZGF0YS12YWx1ZT1cIjFcIiBjbGFzcz1cImVkaXRhYmxlLWNsaWNrXCIgdGl0bGU9XCJHcm91cFwiPk9wZXJhdG9yPC9hPlxuICAgICAgICA8L2Rpdj4gICAgIFxuICAgICAgICBcbiAgICAgICAgPHNjcmlwdD5cbiAgICAgICAgJCgnI3VzZXInKS5lZGl0YWJsZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2EnLFxuICAgICAgICAgICAgdXJsOiAnL3Bvc3QnLFxuICAgICAgICAgICAgcGs6IDFcbiAgICAgICAgfSk7XG4gICAgICAgIDwvc2NyaXB0PlxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgc2VsZWN0b3I6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBDb2xvciB1c2VkIHRvIGhpZ2hsaWdodCBlbGVtZW50IGFmdGVyIHVwZGF0ZS4gSW1wbGVtZW50ZWQgdmlhIENTUzMgdHJhbnNpdGlvbiwgd29ya3MgaW4gbW9kZXJuIGJyb3dzZXJzLlxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IGhpZ2hsaWdodCBcbiAgICAgICAgQHR5cGUgc3RyaW5nfGJvb2xlYW5cbiAgICAgICAgQHNpbmNlIDEuNC41ICAgICAgICBcbiAgICAgICAgQGRlZmF1bHQgI0ZGRkY4MCBcbiAgICAgICAgKiovXG4gICAgICAgIGhpZ2hsaWdodDogJyNGRkZGODAnXG4gICAgfTtcbiAgICBcbn0od2luZG93LmpRdWVyeSkpO1xuXG4vKipcbkFic3RyYWN0SW5wdXQgLSBiYXNlIGNsYXNzIGZvciBhbGwgZWRpdGFibGUgaW5wdXRzLlxuSXQgZGVmaW5lcyBpbnRlcmZhY2UgdG8gYmUgaW1wbGVtZW50ZWQgYnkgYW55IGlucHV0IHR5cGUuXG5UbyBjcmVhdGUgeW91ciBvd24gaW5wdXQgeW91IGNhbiBpbmhlcml0IGZyb20gdGhpcyBjbGFzcy5cblxuQGNsYXNzIGFic3RyYWN0aW5wdXRcbioqL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvL3R5cGVzXG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzID0ge307XG5cbiAgICB2YXIgQWJzdHJhY3RJbnB1dCA9IGZ1bmN0aW9uICgpIHsgfTtcblxuICAgIEFic3RyYWN0SW5wdXQucHJvdG90eXBlID0ge1xuICAgICAgIC8qKlxuICAgICAgICBJbml0aWFsaXplcyBpbnB1dFxuXG4gICAgICAgIEBtZXRob2QgaW5pdCgpIFxuICAgICAgICAqKi9cbiAgICAgICBpbml0OiBmdW5jdGlvbih0eXBlLCBvcHRpb25zLCBkZWZhdWx0cykge1xuICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgICAgIH0sXG5cbiAgICAgICAvKlxuICAgICAgIHRoaXMgbWV0aG9kIGNhbGxlZCBiZWZvcmUgcmVuZGVyIHRvIGluaXQgJHRwbCB0aGF0IGlzIGluc2VydGVkIGluIERPTVxuICAgICAgICovXG4gICAgICAgcHJlcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgdGhpcy4kdHBsID0gJCh0aGlzLm9wdGlvbnMudHBsKTsgLy93aG9sZSB0cGwgYXMganF1ZXJ5IG9iamVjdCAgICBcbiAgICAgICAgICAgdGhpcy4kaW5wdXQgPSB0aGlzLiR0cGw7ICAgICAgICAgLy9jb250cm9sIGl0c2VsZiwgY2FuIGJlIGNoYW5nZWQgaW4gcmVuZGVyIG1ldGhvZFxuICAgICAgICAgICB0aGlzLiRjbGVhciA9IG51bGw7ICAgICAgICAgICAgICAvL2NsZWFyIGJ1dHRvblxuICAgICAgICAgICB0aGlzLmVycm9yID0gbnVsbDsgICAgICAgICAgICAgICAvL2Vycm9yIG1lc3NhZ2UsIGlmIGlucHV0IGNhbm5vdCBiZSByZW5kZXJlZCAgICAgICAgICAgXG4gICAgICAgfSxcbiAgICAgICBcbiAgICAgICAvKipcbiAgICAgICAgUmVuZGVycyBpbnB1dCBmcm9tIHRwbC4gQ2FuIHJldHVybiBqUXVlcnkgZGVmZXJyZWQgb2JqZWN0LlxuICAgICAgICBDYW4gYmUgb3ZlcndyaXR0ZW4gaW4gY2hpbGQgb2JqZWN0c1xuXG4gICAgICAgIEBtZXRob2QgcmVuZGVyKClcbiAgICAgICAqKi9cbiAgICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgfSwgXG5cbiAgICAgICAvKipcbiAgICAgICAgU2V0cyBlbGVtZW50J3MgaHRtbCBieSB2YWx1ZS4gXG5cbiAgICAgICAgQG1ldGhvZCB2YWx1ZTJodG1sKHZhbHVlLCBlbGVtZW50KVxuICAgICAgICBAcGFyYW0ge21peGVkfSB2YWx1ZVxuICAgICAgICBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnRcbiAgICAgICAqKi9cbiAgICAgICB2YWx1ZTJodG1sOiBmdW5jdGlvbih2YWx1ZSwgZWxlbWVudCkge1xuICAgICAgICAgICAkKGVsZW1lbnQpW3RoaXMub3B0aW9ucy5lc2NhcGUgPyAndGV4dCcgOiAnaHRtbCddKCQudHJpbSh2YWx1ZSkpO1xuICAgICAgIH0sXG5cbiAgICAgICAvKipcbiAgICAgICAgQ29udmVydHMgZWxlbWVudCdzIGh0bWwgdG8gdmFsdWVcblxuICAgICAgICBAbWV0aG9kIGh0bWwydmFsdWUoaHRtbClcbiAgICAgICAgQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAgICAgICAgQHJldHVybnMge21peGVkfVxuICAgICAgICoqL1xuICAgICAgIGh0bWwydmFsdWU6IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgICAgICAgcmV0dXJuICQoJzxkaXY+JykuaHRtbChodG1sKS50ZXh0KCk7XG4gICAgICAgfSxcblxuICAgICAgIC8qKlxuICAgICAgICBDb252ZXJ0cyB2YWx1ZSB0byBzdHJpbmcgKGZvciBpbnRlcm5hbCBjb21wYXJlKS4gRm9yIHN1Ym1pdHRpbmcgdG8gc2VydmVyIHVzZWQgdmFsdWUyc3VibWl0KCkuXG5cbiAgICAgICAgQG1ldGhvZCB2YWx1ZTJzdHIodmFsdWUpIFxuICAgICAgICBAcGFyYW0ge21peGVkfSB2YWx1ZVxuICAgICAgICBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICoqL1xuICAgICAgIHZhbHVlMnN0cjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgIH0sIFxuXG4gICAgICAgLyoqXG4gICAgICAgIENvbnZlcnRzIHN0cmluZyByZWNlaXZlZCBmcm9tIHNlcnZlciBpbnRvIHZhbHVlLiBVc3VhbGx5IGZyb20gYGRhdGEtdmFsdWVgIGF0dHJpYnV0ZS5cblxuICAgICAgICBAbWV0aG9kIHN0cjJ2YWx1ZShzdHIpXG4gICAgICAgIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICAgICAgQHJldHVybnMge21peGVkfVxuICAgICAgICoqL1xuICAgICAgIHN0cjJ2YWx1ZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgfSwgXG4gICAgICAgXG4gICAgICAgLyoqXG4gICAgICAgIENvbnZlcnRzIHZhbHVlIGZvciBzdWJtaXR0aW5nIHRvIHNlcnZlci4gUmVzdWx0IGNhbiBiZSBzdHJpbmcgb3Igb2JqZWN0LlxuXG4gICAgICAgIEBtZXRob2QgdmFsdWUyc3VibWl0KHZhbHVlKSBcbiAgICAgICAgQHBhcmFtIHttaXhlZH0gdmFsdWVcbiAgICAgICAgQHJldHVybnMge21peGVkfVxuICAgICAgICoqL1xuICAgICAgIHZhbHVlMnN1Ym1pdDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgIH0sXG5cbiAgICAgICAvKipcbiAgICAgICAgU2V0cyB2YWx1ZSBvZiBpbnB1dC5cblxuICAgICAgICBAbWV0aG9kIHZhbHVlMmlucHV0KHZhbHVlKSBcbiAgICAgICAgQHBhcmFtIHttaXhlZH0gdmFsdWVcbiAgICAgICAqKi9cbiAgICAgICB2YWx1ZTJpbnB1dDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgdGhpcy4kaW5wdXQudmFsKHZhbHVlKTtcbiAgICAgICB9LFxuXG4gICAgICAgLyoqXG4gICAgICAgIFJldHVybnMgdmFsdWUgb2YgaW5wdXQuIFZhbHVlIGNhbiBiZSBvYmplY3QgKGUuZy4gZGF0ZXBpY2tlcilcblxuICAgICAgICBAbWV0aG9kIGlucHV0MnZhbHVlKCkgXG4gICAgICAgKiovXG4gICAgICAgaW5wdXQydmFsdWU6IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuJGlucHV0LnZhbCgpO1xuICAgICAgIH0sIFxuXG4gICAgICAgLyoqXG4gICAgICAgIEFjdGl2YXRlcyBpbnB1dC4gRm9yIHRleHQgaXQgc2V0cyBmb2N1cy5cblxuICAgICAgICBAbWV0aG9kIGFjdGl2YXRlKCkgXG4gICAgICAgKiovXG4gICAgICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICBpZih0aGlzLiRpbnB1dC5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgICAgdGhpcy4kaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgfVxuICAgICAgIH0sXG5cbiAgICAgICAvKipcbiAgICAgICAgQ3JlYXRlcyBpbnB1dC5cblxuICAgICAgICBAbWV0aG9kIGNsZWFyKCkgXG4gICAgICAgKiovICAgICAgICBcbiAgICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIHRoaXMuJGlucHV0LnZhbChudWxsKTtcbiAgICAgICB9LFxuXG4gICAgICAgLyoqXG4gICAgICAgIG1ldGhvZCB0byBlc2NhcGUgaHRtbC5cbiAgICAgICAqKi9cbiAgICAgICBlc2NhcGU6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICByZXR1cm4gJCgnPGRpdj4nKS50ZXh0KHN0cikuaHRtbCgpO1xuICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgLyoqXG4gICAgICAgIGF0dGFjaCBoYW5kbGVyIHRvIGF1dG9tYXRpY2FsbHkgc3VibWl0IGZvcm0gd2hlbiB2YWx1ZSBjaGFuZ2VkICh1c2VmdWwgd2hlbiBidXR0b25zIG5vdCBzaG93bilcbiAgICAgICAqKi9cbiAgICAgICBhdXRvc3VibWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgXG4gICAgICAgfSxcbiAgICAgICBcbiAgICAgICAvKipcbiAgICAgICBBZGRpdGlvbmFsIGFjdGlvbnMgd2hlbiBkZXN0cm95aW5nIGVsZW1lbnQgXG4gICAgICAgKiovXG4gICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgfSxcblxuICAgICAgIC8vIC0tLS0tLS0tIGhlbHBlciBmdW5jdGlvbnMgLS0tLS0tLS1cbiAgICAgICBzZXRDbGFzczogZnVuY3Rpb24oKSB7ICAgICAgICAgIFxuICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuaW5wdXRjbGFzcykge1xuICAgICAgICAgICAgICAgdGhpcy4kaW5wdXQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmlucHV0Y2xhc3MpOyBcbiAgICAgICAgICAgfSBcbiAgICAgICB9LFxuXG4gICAgICAgc2V0QXR0cjogZnVuY3Rpb24oYXR0cikge1xuICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zW2F0dHJdICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zW2F0dHJdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5hdHRyKGF0dHIsIHRoaXMub3B0aW9uc1thdHRyXSk7XG4gICAgICAgICAgIH0gXG4gICAgICAgfSxcbiAgICAgICBcbiAgICAgICBvcHRpb246IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgfVxuICAgICAgIFxuICAgIH07XG4gICAgICAgIFxuICAgIEFic3RyYWN0SW5wdXQuZGVmYXVsdHMgPSB7ICBcbiAgICAgICAgLyoqXG4gICAgICAgIEhUTUwgdGVtcGxhdGUgb2YgaW5wdXQuIE5vcm1hbGx5IHlvdSBzaG91bGQgbm90IGNoYW5nZSBpdC5cblxuICAgICAgICBAcHJvcGVydHkgdHBsIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgJydcbiAgICAgICAgKiovICAgXG4gICAgICAgIHRwbDogJycsXG4gICAgICAgIC8qKlxuICAgICAgICBDU1MgY2xhc3MgYXV0b21hdGljYWxseSBhcHBsaWVkIHRvIGlucHV0XG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgaW5wdXRjbGFzcyBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGlucHV0Y2xhc3M6IG51bGwsXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgSWYgYHRydWVgIC0gaHRtbCB3aWxsIGJlIGVzY2FwZWQgaW4gY29udGVudCBvZiBlbGVtZW50IHZpYSAkLnRleHQoKSBtZXRob2QuICBcbiAgICAgICAgSWYgYGZhbHNlYCAtIGh0bWwgd2lsbCBub3QgYmUgZXNjYXBlZCwgJC5odG1sKCkgdXNlZC4gIFxuICAgICAgICBXaGVuIHlvdSB1c2Ugb3duIGBkaXNwbGF5YCBmdW5jdGlvbiwgdGhpcyBvcHRpb24gb2J2aW9zbHkgaGFzIG5vIGVmZmVjdC5cbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBlc2NhcGUgXG4gICAgICAgIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgQHNpbmNlIDEuNS4wXG4gICAgICAgIEBkZWZhdWx0IHRydWVcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGVzY2FwZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgLy9zY29wZSBmb3IgZXh0ZXJuYWwgbWV0aG9kcyAoZS5nLiBzb3VyY2UgZGVmaW5lZCBhcyBmdW5jdGlvbilcbiAgICAgICAgLy9mb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAgICAgICAgc2NvcGU6IG51bGwsXG4gICAgICAgIFxuICAgICAgICAvL25lZWQgdG8gcmUtZGVjbGFyZSBzaG93YnV0dG9ucyBoZXJlIHRvIGdldCBpdCdzIHZhbHVlIGZyb20gY29tbW9uIGNvbmZpZyAocGFzc2VkIG9ubHkgb3B0aW9ucyBleGlzdGluZyBpbiBkZWZhdWx0cylcbiAgICAgICAgc2hvd2J1dHRvbnM6IHRydWUgXG4gICAgfTtcbiAgICBcbiAgICAkLmV4dGVuZCgkLmZuLmVkaXRhYmxldHlwZXMsIHthYnN0cmFjdGlucHV0OiBBYnN0cmFjdElucHV0fSk7XG4gICAgICAgIFxufSh3aW5kb3cualF1ZXJ5KSk7XG5cbi8qKlxuTGlzdCAtIGFic3RyYWN0IGNsYXNzIGZvciBpbnB1dHMgdGhhdCBoYXZlIHNvdXJjZSBvcHRpb24gbG9hZGVkIGZyb20ganMgYXJyYXkgb3IgdmlhIGFqYXhcblxuQGNsYXNzIGxpc3RcbkBleHRlbmRzIGFic3RyYWN0aW5wdXRcbioqL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgXG4gICAgdmFyIExpc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgIFxuICAgIH07XG5cbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChMaXN0LCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dCk7XG5cbiAgICAkLmV4dGVuZChMaXN0LnByb3RvdHlwZSwge1xuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkZWZlcnJlZCA9ICQuRGVmZXJyZWQoKTtcblxuICAgICAgICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm9uU291cmNlUmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGlzdCgpO1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gdGhpcy5vcHRpb25zLnNvdXJjZUVycm9yO1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGh0bWwydmFsdWU6IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy9jYW4ndCBzZXQgdmFsdWUgYnkgdGV4dFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgdmFsdWUyaHRtbDogZnVuY3Rpb24gKHZhbHVlLCBlbGVtZW50LCBkaXNwbGF5LCByZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBkaXNwbGF5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2N1c3RvbSBkaXNwbGF5IG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheS5jYWxsKGVsZW1lbnQsIHZhbHVlLCB0aGlzLnNvdXJjZURhdGEsIHJlc3BvbnNlKTsgXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlMmh0bWxGaW5hbCh2YWx1ZSwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9mb3IgbnVsbCB2YWx1ZSBqdXN0IGNhbGwgc3VjY2VzcyB3aXRob3V0IGxvYWRpbmcgc291cmNlXG4gICAgICAgICAgICBpZih2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgc3VjY2Vzcy5jYWxsKHRoaXMpOyAgIFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIHRoaXMub25Tb3VyY2VSZWFkeShzdWNjZXNzLCBmdW5jdGlvbiAoKSB7IGRlZmVycmVkLnJlc29sdmUoKTsgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG4gICAgICAgIH0sICBcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tIGFkZGl0aW9uYWwgZnVuY3Rpb25zIC0tLS0tLS0tLS0tLVxuXG4gICAgICAgIG9uU291cmNlUmVhZHk6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgLy9ydW4gc291cmNlIGlmIGl0IGZ1bmN0aW9uXG4gICAgICAgICAgICB2YXIgc291cmNlO1xuICAgICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMuc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IHRoaXMub3B0aW9ucy5zb3VyY2UuY2FsbCh0aGlzLm9wdGlvbnMuc2NvcGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlRGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy9ub3RlOiBpZiBmdW5jdGlvbiByZXR1cm5zIHRoZSBzYW1lIHNvdXJjZSBhcyBVUkwgLSBzb3VyY2VEYXRhIHdpbGwgYmUgdGFrZW4gZnJvbSBjYWhjZSBhbmQgbm8gZXh0cmEgcmVxdWVzdCBwZXJmb3JtZWRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc291cmNlID0gdGhpcy5vcHRpb25zLnNvdXJjZTtcbiAgICAgICAgICAgIH0gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9pZiBhbGxyZWFkeSBsb2FkZWQganVzdCBjYWxsIHN1Y2Nlc3NcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5zb3VyY2VDYWNoZSAmJiAkLmlzQXJyYXkodGhpcy5zb3VyY2VEYXRhKSkge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47IFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3RyeSBwYXJzZSBqc29uIGluIHNpbmdsZSBxdW90ZXMgKGZvciBkb3VibGUgcXVvdGVzIGpxdWVyeSBkb2VzIGF1dG9tYXRpY2FsbHkpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9ICQuZm4uZWRpdGFibGV1dGlscy50cnlQYXJzZUpzb24oc291cmNlLCBmYWxzZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vbG9hZGluZyBmcm9tIHVybFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy90cnkgdG8gZ2V0IHNvdXJjZURhdGEgZnJvbSBjYWNoZVxuICAgICAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5zb3VyY2VDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2FjaGVJRCA9IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkKGRvY3VtZW50KS5kYXRhKGNhY2hlSUQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKGRvY3VtZW50KS5kYXRhKGNhY2hlSUQsIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWNoZSA9ICQoZG9jdW1lbnQpLmRhdGEoY2FjaGVJRCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBmb3IgY2FjaGVkIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlLmxvYWRpbmcgPT09IGZhbHNlICYmIGNhY2hlLnNvdXJjZURhdGEpIHsgLy90YWtlIHNvdXJjZSBmcm9tIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZURhdGEgPSBjYWNoZS5zb3VyY2VEYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1ByZXBlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjYWNoZS5sb2FkaW5nID09PSB0cnVlKSB7IC8vY2FjaGUgaXMgbG9hZGluZywgcHV0IGNhbGxiYWNrIGluIHN0YWNrIHRvIGJlIGNhbGxlZCBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuY2FsbGJhY2tzLnB1c2goJC5wcm94eShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VEYXRhID0gY2FjaGUuc291cmNlRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvUHJlcGVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hbHNvIGNvbGxlY3RpbmcgZXJyb3IgY2FsbGJhY2tzXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5lcnJfY2FsbGJhY2tzLnB1c2goJC5wcm94eShlcnJvciwgdGhpcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvL25vIGNhY2hlIHlldCwgYWN0aXZhdGUgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuY2FsbGJhY2tzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5lcnJfY2FsbGJhY2tzID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9hamF4T3B0aW9ucyBmb3Igc291cmNlLiBDYW4gYmUgb3ZlcndyaXR0ZW4gYnQgb3B0aW9ucy5zb3VyY2VPcHRpb25zXG4gICAgICAgICAgICAgICAgdmFyIGFqYXhPcHRpb25zID0gJC5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2dldCcsXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogJC5wcm94eShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZURhdGEgPSB0aGlzLm1ha2VBcnJheShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCQuaXNBcnJheSh0aGlzLnNvdXJjZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zdG9yZSByZXN1bHQgaW4gY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc291cmNlRGF0YSA9IHRoaXMuc291cmNlRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ydW4gc3VjY2VzcyBjYWxsYmFja3MgZm9yIG90aGVyIGZpZWxkcyB3YWl0aW5nIGZvciB0aGlzIHNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2goY2FjaGUuY2FsbGJhY2tzLCBmdW5jdGlvbiAoKSB7IHRoaXMuY2FsbCgpOyB9KTsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9QcmVwZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzcy5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcnVuIGVycm9yIGNhbGxiYWNrcyBmb3Igb3RoZXIgZmllbGRzIHdhaXRpbmcgZm9yIHRoaXMgc291cmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChjYWNoZS5lcnJfY2FsbGJhY2tzLCBmdW5jdGlvbiAoKSB7IHRoaXMuY2FsbCgpOyB9KTsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICQucHJveHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ydW4gZXJyb3IgY2FsbGJhY2tzIGZvciBvdGhlciBmaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKGNhY2hlLmVycl9jYWxsYmFja3MsIGZ1bmN0aW9uICgpIHsgdGhpcy5jYWxsKCk7IH0pOyBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcylcbiAgICAgICAgICAgICAgICB9LCB0aGlzLm9wdGlvbnMuc291cmNlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9sb2FkaW5nIHNvdXJjZURhdGEgZnJvbSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAkLmFqYXgoYWpheE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSBlbHNlIHsgLy9vcHRpb25zIGFzIGpzb24vYXJyYXlcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZURhdGEgPSB0aGlzLm1ha2VBcnJheShzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZigkLmlzQXJyYXkodGhpcy5zb3VyY2VEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvUHJlcGVuZCgpO1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzLmNhbGwodGhpcyk7ICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZG9QcmVwZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMucHJlcGVuZCA9PT0gbnVsbCB8fCB0aGlzLm9wdGlvbnMucHJlcGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCEkLmlzQXJyYXkodGhpcy5wcmVwZW5kRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAvL3J1biBwcmVwZW5kIGlmIGl0IGlzIGZ1bmN0aW9uIChvbmNlKVxuICAgICAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24odGhpcy5vcHRpb25zLnByZXBlbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wcmVwZW5kID0gdGhpcy5vcHRpb25zLnByZXBlbmQuY2FsbCh0aGlzLm9wdGlvbnMuc2NvcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy90cnkgcGFyc2UganNvbiBpbiBzaW5nbGUgcXVvdGVzXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnByZXBlbmQgPSAkLmZuLmVkaXRhYmxldXRpbHMudHJ5UGFyc2VKc29uKHRoaXMub3B0aW9ucy5wcmVwZW5kLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgcHJlcGVuZCBmcm9tIHN0cmluZyB0byBvYmplY3RcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5wcmVwZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucHJlcGVuZCA9IHsnJzogdGhpcy5vcHRpb25zLnByZXBlbmR9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLnByZXBlbmREYXRhID0gdGhpcy5tYWtlQXJyYXkodGhpcy5vcHRpb25zLnByZXBlbmQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZigkLmlzQXJyYXkodGhpcy5wcmVwZW5kRGF0YSkgJiYgJC5pc0FycmF5KHRoaXMuc291cmNlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZURhdGEgPSB0aGlzLnByZXBlbmREYXRhLmNvbmNhdCh0aGlzLnNvdXJjZURhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qXG4gICAgICAgICByZW5kZXJzIGlucHV0IGxpc3RcbiAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyTGlzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyB0aGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcndyaXR0ZW4gaW4gY2hpbGQgY2xhc3NcbiAgICAgICAgfSxcbiAgICAgICBcbiAgICAgICAgIC8qXG4gICAgICAgICBzZXQgZWxlbWVudCdzIGh0bWwgYnkgdmFsdWVcbiAgICAgICAgKi9cbiAgICAgICAgdmFsdWUyaHRtbEZpbmFsOiBmdW5jdGlvbih2YWx1ZSwgZWxlbWVudCkge1xuICAgICAgICAgICAgLy8gdGhpcyBtZXRob2Qgc2hvdWxkIGJlIG92ZXJ3cml0dGVuIGluIGNoaWxkIGNsYXNzXG4gICAgICAgIH0sICAgICAgICBcblxuICAgICAgICAvKipcbiAgICAgICAgKiBjb252ZXJ0IGRhdGEgdG8gYXJyYXkgc3VpdGFibGUgZm9yIHNvdXJjZURhdGEsIGUuZy4gW3t2YWx1ZTogMSwgdGV4dDogJ2FiYyd9LCB7Li4ufV1cbiAgICAgICAgKi9cbiAgICAgICAgbWFrZUFycmF5OiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY291bnQsIG9iaiwgcmVzdWx0ID0gW10sIGl0ZW0sIGl0ZXJhdGVJdGVtO1xuICAgICAgICAgICAgaWYoIWRhdGEgfHwgdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZigkLmlzQXJyYXkoZGF0YSkpIHsgLy9hcnJheVxuICAgICAgICAgICAgICAgIC8qIFxuICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgaW5zaWRlIGl0ZW0gb2YgYXJyYXkgaWYgaXRlbSBpcyBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgQ2FjbHVsYXRlcyBjb3VudCBvZiBrZXlzIGluIGl0ZW0gYW5kIHN0b3JlIGluIG9iai4gXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpdGVyYXRlSXRlbSA9IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IHt2YWx1ZTogaywgdGV4dDogdn07XG4gICAgICAgICAgICAgICAgICAgIGlmKGNvdW50KysgPj0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOy8vIGV4aXQgZnJvbSBgZWFjaGAgaWYgaXRlbSBoYXMgbW9yZSB0aGFuIG9uZSBrZXkuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGRhdGFbaV07IFxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMDsgLy9jb3VudCBvZiBrZXlzIGluc2lkZSBpdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2goaXRlbSwgaXRlcmF0ZUl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jYXNlOiBbe3ZhbDE6ICd0ZXh0MSd9LCB7dmFsMjogJ3RleHQyfSAuLi5dXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjb3VudCA9PT0gMSkgeyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvYmopOyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Nhc2U6IFt7dmFsdWU6IDEsIHRleHQ6ICd0ZXh0MSd9LCB7dmFsdWU6IDIsIHRleHQ6ICd0ZXh0Mid9LCAuLi5dXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoY291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmVkIGNoZWNrIG9mIGV4aXN0YW5jZTogaXRlbS5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSAmJiBpdGVtLmhhc093blByb3BlcnR5KCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY2hpbGRyZW4gPSB0aGlzLm1ha2VBcnJheShpdGVtLmNoaWxkcmVuKTsgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2Nhc2U6IFsndGV4dDEnLCAndGV4dDInIC4uLl1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHt2YWx1ZTogaXRlbSwgdGV4dDogaXRlbX0pOyBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7ICAvL2Nhc2U6IHt2YWwxOiAndGV4dDEnLCB2YWwyOiAndGV4dDIsIC4uLn1cbiAgICAgICAgICAgICAgICAkLmVhY2goZGF0YSwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe3ZhbHVlOiBrLCB0ZXh0OiB2fSk7XG4gICAgICAgICAgICAgICAgfSk7ICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBvcHRpb246IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICBpZihrZXkgPT09ICdzb3VyY2UnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VEYXRhID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGtleSA9PT0gJ3ByZXBlbmQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmVwZW5kRGF0YSA9IG51bGw7XG4gICAgICAgICAgICB9ICAgICAgICAgICAgXG4gICAgICAgIH0gICAgICAgIFxuXG4gICAgfSk7ICAgICAgXG5cbiAgICBMaXN0LmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0LmRlZmF1bHRzLCB7XG4gICAgICAgIC8qKlxuICAgICAgICBTb3VyY2UgZGF0YSBmb3IgbGlzdC4gIFxuICAgICAgICBJZiAqKmFycmF5KiogLSBpdCBzaG91bGQgYmUgaW4gZm9ybWF0OiBgW3t2YWx1ZTogMSwgdGV4dDogXCJ0ZXh0MVwifSwge3ZhbHVlOiAyLCB0ZXh0OiBcInRleHQyXCJ9LCAuLi5dYCAgXG4gICAgICAgIEZvciBjb21wYWJpbGl0eSwgb2JqZWN0IGZvcm1hdCBpcyBhbHNvIHN1cHBvcnRlZDogYHtcIjFcIjogXCJ0ZXh0MVwiLCBcIjJcIjogXCJ0ZXh0MlwiIC4uLn1gIGJ1dCBpdCBkb2VzIG5vdCBndWFyYW50ZWUgZWxlbWVudHMgb3JkZXIuXG4gICAgICAgIFxuICAgICAgICBJZiAqKnN0cmluZyoqIC0gY29uc2lkZXJlZCBhamF4IHVybCB0byBsb2FkIGl0ZW1zLiBJbiB0aGF0IGNhc2UgcmVzdWx0cyB3aWxsIGJlIGNhY2hlZCBmb3IgZmllbGRzIHdpdGggdGhlIHNhbWUgc291cmNlIGFuZCBuYW1lLiBTZWUgYWxzbyBgc291cmNlQ2FjaGVgIG9wdGlvbi5cbiAgICAgICAgICBcbiAgICAgICAgSWYgKipmdW5jdGlvbioqLCBpdCBzaG91bGQgcmV0dXJuIGRhdGEgaW4gZm9ybWF0IGFib3ZlIChzaW5jZSAxLjQuMCkuXG4gICAgICAgIFxuICAgICAgICBTaW5jZSAxLjQuMSBrZXkgYGNoaWxkcmVuYCBzdXBwb3J0ZWQgdG8gcmVuZGVyIE9QVEdST1VQIChmb3IgKipzZWxlY3QqKiBpbnB1dCBvbmx5KS4gIFxuICAgICAgICBgW3t0ZXh0OiBcImdyb3VwMVwiLCBjaGlsZHJlbjogW3t2YWx1ZTogMSwgdGV4dDogXCJ0ZXh0MVwifSwge3ZhbHVlOiAyLCB0ZXh0OiBcInRleHQyXCJ9XX0sIC4uLl1gIFxuXG5cdFx0XG4gICAgICAgIEBwcm9wZXJ0eSBzb3VyY2UgXG4gICAgICAgIEB0eXBlIHN0cmluZyB8IGFycmF5IHwgb2JqZWN0IHwgZnVuY3Rpb25cbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgc291cmNlOiBudWxsLCBcbiAgICAgICAgLyoqXG4gICAgICAgIERhdGEgYXV0b21hdGljYWxseSBwcmVwZW5kZWQgdG8gdGhlIGJlZ2lubmluZyBvZiBkcm9wZG93biBsaXN0LlxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IHByZXBlbmQgXG4gICAgICAgIEB0eXBlIHN0cmluZyB8IGFycmF5IHwgb2JqZWN0IHwgZnVuY3Rpb25cbiAgICAgICAgQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHByZXBlbmQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgRXJyb3IgbWVzc2FnZSB3aGVuIGxpc3QgY2Fubm90IGJlIGxvYWRlZCAoZS5nLiBhamF4IGVycm9yKVxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IHNvdXJjZUVycm9yIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgRXJyb3Igd2hlbiBsb2FkaW5nIGxpc3RcbiAgICAgICAgKiovICAgICAgICAgIFxuICAgICAgICBzb3VyY2VFcnJvcjogJ0Vycm9yIHdoZW4gbG9hZGluZyBsaXN0JyxcbiAgICAgICAgLyoqXG4gICAgICAgIGlmIDxjb2RlPnRydWU8L2NvZGU+IGFuZCBzb3VyY2UgaXMgKipzdHJpbmcgdXJsKiogLSByZXN1bHRzIHdpbGwgYmUgY2FjaGVkIGZvciBmaWVsZHMgd2l0aCB0aGUgc2FtZSBzb3VyY2UuICAgIFxuICAgICAgICBVc2VmdWxsIGZvciBlZGl0YWJsZSBjb2x1bW4gaW4gZ3JpZCB0byBwcmV2ZW50IGV4dHJhIHJlcXVlc3RzLlxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IHNvdXJjZUNhY2hlIFxuICAgICAgICBAdHlwZSBib29sZWFuXG4gICAgICAgIEBkZWZhdWx0IHRydWVcbiAgICAgICAgQHNpbmNlIDEuMi4wXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIHNvdXJjZUNhY2hlOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgQWRkaXRpb25hbCBhamF4IG9wdGlvbnMgdG8gYmUgdXNlZCBpbiAkLmFqYXgoKSB3aGVuIGxvYWRpbmcgbGlzdCBmcm9tIHNlcnZlci5cbiAgICAgICAgVXNlZnVsIHRvIHNlbmQgZXh0cmEgcGFyYW1ldGVycyAoYGRhdGFgIGtleSkgb3IgY2hhbmdlIHJlcXVlc3QgbWV0aG9kIChgdHlwZWAga2V5KS5cbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBzb3VyY2VPcHRpb25zIFxuICAgICAgICBAdHlwZSBvYmplY3R8ZnVuY3Rpb25cbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICBAc2luY2UgMS41LjBcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgc291cmNlT3B0aW9uczogbnVsbFxuICAgIH0pO1xuXG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLmxpc3QgPSBMaXN0OyAgICAgIFxuXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG5UZXh0IGlucHV0XG5cbkBjbGFzcyB0ZXh0XG5AZXh0ZW5kcyBhYnN0cmFjdGlucHV0XG5AZmluYWxcbkBleGFtcGxlXG48YSBocmVmPVwiI1wiIGlkPVwidXNlcm5hbWVcIiBkYXRhLXR5cGU9XCJ0ZXh0XCIgZGF0YS1waz1cIjFcIj5hd2Vzb21lPC9hPlxuPHNjcmlwdD5cbiQoZnVuY3Rpb24oKXtcbiAgICAkKCcjdXNlcm5hbWUnKS5lZGl0YWJsZSh7XG4gICAgICAgIHVybDogJy9wb3N0JyxcbiAgICAgICAgdGl0bGU6ICdFbnRlciB1c2VybmFtZSdcbiAgICB9KTtcbn0pO1xuPC9zY3JpcHQ+XG4qKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIFxuICAgIHZhciBUZXh0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCd0ZXh0Jywgb3B0aW9ucywgVGV4dC5kZWZhdWx0cyk7XG4gICAgfTtcblxuICAgICQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KFRleHQsICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0KTtcblxuICAgICQuZXh0ZW5kKFRleHQucHJvdG90eXBlLCB7XG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIHRoaXMucmVuZGVyQ2xlYXIoKTtcbiAgICAgICAgICAgdGhpcy5zZXRDbGFzcygpO1xuICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3BsYWNlaG9sZGVyJyk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLiRpbnB1dC5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgJC5mbi5lZGl0YWJsZXV0aWxzLnNldEN1cnNvclBvc2l0aW9uKHRoaXMuJGlucHV0LmdldCgwKSwgdGhpcy4kaW5wdXQudmFsKCkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnRvZ2dsZUNsZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlQ2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvL3JlbmRlciBjbGVhciBidXR0b25cbiAgICAgICAgcmVuZGVyQ2xlYXI6ICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbGVhcikge1xuICAgICAgICAgICAgICAgdGhpcy4kY2xlYXIgPSAkKCc8c3BhbiBjbGFzcz1cImVkaXRhYmxlLWNsZWFyLXhcIj48L3NwYW4+Jyk7XG4gICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5hZnRlcih0aGlzLiRjbGVhcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmNzcygncGFkZGluZy1yaWdodCcsIDI0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAua2V5dXAoJC5wcm94eShmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Fycm93cywgZW50ZXIsIHRhYiwgZXRjXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih+JC5pbkFycmF5KGUua2V5Q29kZSwgWzQwLDM4LDksMTMsMjddKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQudG9nZ2xlQ2xlYXIoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAucGFyZW50KCkuY3NzKCdwb3NpdGlvbicsICdyZWxhdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgIHRoaXMuJGNsZWFyLmNsaWNrKCQucHJveHkodGhpcy5jbGVhciwgdGhpcykpOyAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgIH0gICAgICAgICAgICBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHBvc3RyZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIC8vbm93IGBjbGVhcmAgaXMgcG9zaXRpb25lZCB2aWEgY3NzXG4gICAgICAgICAgICBpZih0aGlzLiRjbGVhcikge1xuICAgICAgICAgICAgICAgIC8vY2FuIHBvc2l0aW9uIGNsZWFyIGJ1dHRvbiBvbmx5IGhlcmUsIHdoZW4gZm9ybSBpcyBzaG93biBhbmQgaGVpZ2h0IGNhbiBiZSBjYWxjdWxhdGVkXG4vLyAgICAgICAgICAgICAgICB2YXIgaCA9IHRoaXMuJGlucHV0Lm91dGVySGVpZ2h0KHRydWUpIHx8IDIwLFxuICAgICAgICAgICAgICAgIHZhciBoID0gdGhpcy4kY2xlYXIucGFyZW50KCkuaGVpZ2h0KCksXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhID0gKGggLSB0aGlzLiRjbGVhci5oZWlnaHQoKSkgLyAyO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL3RoaXMuJGNsZWFyLmNzcyh7Ym90dG9tOiBkZWx0YSwgcmlnaHQ6IGRlbHRhfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAqLyBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8vc2hvdyAvIGhpZGUgY2xlYXIgYnV0dG9uXG4gICAgICAgIHRvZ2dsZUNsZWFyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZighdGhpcy4kY2xlYXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLiRpbnB1dC52YWwoKS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdmlzaWJsZSA9IHRoaXMuJGNsZWFyLmlzKCc6dmlzaWJsZScpO1xuICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGxlbiAmJiAhdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGNsZWFyLnNob3coKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCFsZW4gJiYgdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGNsZWFyLmhpZGUoKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIHRoaXMuJGNsZWFyLmhpZGUoKTtcbiAgICAgICAgICAgdGhpcy4kaW5wdXQudmFsKCcnKS5mb2N1cygpO1xuICAgICAgICB9ICAgICAgICAgIFxuICAgIH0pO1xuXG4gICAgVGV4dC5kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dC5kZWZhdWx0cywge1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IHRwbCBcbiAgICAgICAgQGRlZmF1bHQgPGlucHV0IHR5cGU9XCJ0ZXh0XCI+XG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICB0cGw6ICc8aW5wdXQgdHlwZT1cInRleHRcIj4nLFxuICAgICAgICAvKipcbiAgICAgICAgUGxhY2Vob2xkZXIgYXR0cmlidXRlIG9mIGlucHV0LiBTaG93biB3aGVuIGlucHV0IGlzIGVtcHR5LlxuXG4gICAgICAgIEBwcm9wZXJ0eSBwbGFjZWhvbGRlciBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovICAgICAgICAgICAgIFxuICAgICAgICBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBXaGV0aGVyIHRvIHNob3cgYGNsZWFyYCBidXR0b24gXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgY2xlYXIgXG4gICAgICAgIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgQGRlZmF1bHQgdHJ1ZSAgICAgICAgXG4gICAgICAgICoqL1xuICAgICAgICBjbGVhcjogdHJ1ZVxuICAgIH0pO1xuXG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQgPSBUZXh0O1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG5UZXh0YXJlYSBpbnB1dFxuXG5AY2xhc3MgdGV4dGFyZWFcbkBleHRlbmRzIGFic3RyYWN0aW5wdXRcbkBmaW5hbFxuQGV4YW1wbGVcbjxhIGhyZWY9XCIjXCIgaWQ9XCJjb21tZW50c1wiIGRhdGEtdHlwZT1cInRleHRhcmVhXCIgZGF0YS1waz1cIjFcIj5hd2Vzb21lIGNvbW1lbnQhPC9hPlxuPHNjcmlwdD5cbiQoZnVuY3Rpb24oKXtcbiAgICAkKCcjY29tbWVudHMnKS5lZGl0YWJsZSh7XG4gICAgICAgIHVybDogJy9wb3N0JyxcbiAgICAgICAgdGl0bGU6ICdFbnRlciBjb21tZW50cycsXG4gICAgICAgIHJvd3M6IDEwXG4gICAgfSk7XG59KTtcbjwvc2NyaXB0PlxuKiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBcbiAgICB2YXIgVGV4dGFyZWEgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ3RleHRhcmVhJywgb3B0aW9ucywgVGV4dGFyZWEuZGVmYXVsdHMpO1xuICAgIH07XG5cbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChUZXh0YXJlYSwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQpO1xuXG4gICAgJC5leHRlbmQoVGV4dGFyZWEucHJvdG90eXBlLCB7XG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRDbGFzcygpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdwbGFjZWhvbGRlcicpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdyb3dzJyk7ICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vY3RybCArIGVudGVyXG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5rZXlkb3duKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUuY3RybEtleSAmJiBlLndoaWNoID09PSAxMykge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKS5zdWJtaXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgLy91c2luZyBgd2hpdGUtc3BhY2U6IHByZS13cmFwYCBzb2x2ZXMgXFxuICA8LS0+IEJSIGNvbnZlcnNpb24gdmVyeSBlbGVnYW50IVxuICAgICAgIC8qIFxuICAgICAgIHZhbHVlMmh0bWw6IGZ1bmN0aW9uKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgaHRtbCA9ICcnLCBsaW5lcztcbiAgICAgICAgICAgIGlmKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGluZXMgPSB2YWx1ZS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzW2ldID0gJCgnPGRpdj4nKS50ZXh0KGxpbmVzW2ldKS5odG1sKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGh0bWwgPSBsaW5lcy5qb2luKCc8YnI+Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkKGVsZW1lbnQpLmh0bWwoaHRtbCk7XG4gICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgIGh0bWwydmFsdWU6IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgICAgICAgIGlmKCFodG1sKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKFN0cmluZy5mcm9tQ2hhckNvZGUoMTApLCAnZycpO1xuICAgICAgICAgICAgdmFyIGxpbmVzID0gaHRtbC5zcGxpdCgvPGJyXFxzKlxcLz8+L2kpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gJCgnPGRpdj4nKS5odG1sKGxpbmVzW2ldKS50ZXh0KCk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgbmV3bGluZSBjaGFyYWN0ZXJzIChcXG4pIHRvIGF2b2lkIHRoZW0gYmVpbmcgY29udmVydGVkIGJ5IHZhbHVlMmh0bWwoKSBtZXRob2RcbiAgICAgICAgICAgICAgICAvLyB0aHVzIGFkZGluZyBleHRyYSA8YnI+IHRhZ3NcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHJlZ2V4LCAnJyk7XG5cbiAgICAgICAgICAgICAgICBsaW5lc1tpXSA9IHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGluZXMuam9pbihcIlxcblwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICQuZm4uZWRpdGFibGV0eXBlcy50ZXh0LnByb3RvdHlwZS5hY3RpdmF0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBUZXh0YXJlYS5kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dC5kZWZhdWx0cywge1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IHRwbFxuICAgICAgICBAZGVmYXVsdCA8dGV4dGFyZWE+PC90ZXh0YXJlYT5cbiAgICAgICAgKiovXG4gICAgICAgIHRwbDonPHRleHRhcmVhPjwvdGV4dGFyZWE+JyxcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBpbnB1dGNsYXNzXG4gICAgICAgIEBkZWZhdWx0IGlucHV0LWxhcmdlXG4gICAgICAgICoqL1xuICAgICAgICBpbnB1dGNsYXNzOiAnaW5wdXQtbGFyZ2UnLFxuICAgICAgICAvKipcbiAgICAgICAgUGxhY2Vob2xkZXIgYXR0cmlidXRlIG9mIGlucHV0LiBTaG93biB3aGVuIGlucHV0IGlzIGVtcHR5LlxuXG4gICAgICAgIEBwcm9wZXJ0eSBwbGFjZWhvbGRlclxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi9cbiAgICAgICAgcGxhY2Vob2xkZXI6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBOdW1iZXIgb2Ygcm93cyBpbiB0ZXh0YXJlYVxuXG4gICAgICAgIEBwcm9wZXJ0eSByb3dzXG4gICAgICAgIEB0eXBlIGludGVnZXJcbiAgICAgICAgQGRlZmF1bHQgN1xuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICByb3dzOiA3ICAgICAgICBcbiAgICB9KTtcblxuICAgICQuZm4uZWRpdGFibGV0eXBlcy50ZXh0YXJlYSA9IFRleHRhcmVhO1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG5TZWxlY3QgKGRyb3Bkb3duKVxuXG5AY2xhc3Mgc2VsZWN0XG5AZXh0ZW5kcyBsaXN0XG5AZmluYWxcbkBleGFtcGxlXG48YSBocmVmPVwiI1wiIGlkPVwic3RhdHVzXCIgZGF0YS10eXBlPVwic2VsZWN0XCIgZGF0YS1waz1cIjFcIiBkYXRhLXVybD1cIi9wb3N0XCIgZGF0YS10aXRsZT1cIlNlbGVjdCBzdGF0dXNcIj48L2E+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgICQoJyNzdGF0dXMnKS5lZGl0YWJsZSh7XG4gICAgICAgIHZhbHVlOiAyLCAgICBcbiAgICAgICAgc291cmNlOiBbXG4gICAgICAgICAgICAgIHt2YWx1ZTogMSwgdGV4dDogJ0FjdGl2ZSd9LFxuICAgICAgICAgICAgICB7dmFsdWU6IDIsIHRleHQ6ICdCbG9ja2VkJ30sXG4gICAgICAgICAgICAgIHt2YWx1ZTogMywgdGV4dDogJ0RlbGV0ZWQnfVxuICAgICAgICAgICBdXG4gICAgfSk7XG59KTtcbjwvc2NyaXB0PlxuKiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBcbiAgICB2YXIgU2VsZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCdzZWxlY3QnLCBvcHRpb25zLCBTZWxlY3QuZGVmYXVsdHMpO1xuICAgIH07XG5cbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChTZWxlY3QsICQuZm4uZWRpdGFibGV0eXBlcy5saXN0KTtcblxuICAgICQuZXh0ZW5kKFNlbGVjdC5wcm90b3R5cGUsIHtcbiAgICAgICAgcmVuZGVyTGlzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5lbXB0eSgpO1xuXG4gICAgICAgICAgICB2YXIgZmlsbEl0ZW1zID0gZnVuY3Rpb24oJGVsLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHI7XG4gICAgICAgICAgICAgICAgaWYoJC5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRhdGFbaV0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyLmxhYmVsID0gZGF0YVtpXS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRlbC5hcHBlbmQoZmlsbEl0ZW1zKCQoJzxvcHRncm91cD4nLCBhdHRyKSwgZGF0YVtpXS5jaGlsZHJlbikpOyBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ci52YWx1ZSA9IGRhdGFbaV0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGF0YVtpXS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGVsLmFwcGVuZCgkKCc8b3B0aW9uPicsIGF0dHIpLnRleHQoZGF0YVtpXS50ZXh0KSk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAkZWw7XG4gICAgICAgICAgICB9OyAgICAgICAgXG5cbiAgICAgICAgICAgIGZpbGxJdGVtcyh0aGlzLiRpbnB1dCwgdGhpcy5zb3VyY2VEYXRhKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5zZXRDbGFzcygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2VudGVyIHN1Ym1pdFxuICAgICAgICAgICAgdGhpcy4kaW5wdXQub24oJ2tleWRvd24uZWRpdGFibGUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLndoaWNoID09PSAxMykge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKS5zdWJtaXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTsgICAgICAgICAgICBcbiAgICAgICAgfSxcbiAgICAgICBcbiAgICAgICAgdmFsdWUyaHRtbEZpbmFsOiBmdW5jdGlvbih2YWx1ZSwgZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHRleHQgPSAnJywgXG4gICAgICAgICAgICAgICAgaXRlbXMgPSAkLmZuLmVkaXRhYmxldXRpbHMuaXRlbXNCeVZhbHVlKHZhbHVlLCB0aGlzLnNvdXJjZURhdGEpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGl0ZW1zWzBdLnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vJChlbGVtZW50KS50ZXh0KHRleHQpO1xuICAgICAgICAgICAgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQucHJvdG90eXBlLnZhbHVlMmh0bWwuY2FsbCh0aGlzLCB0ZXh0LCBlbGVtZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGF1dG9zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQub2ZmKCdrZXlkb3duLmVkaXRhYmxlJykub24oJ2NoYW5nZS5lZGl0YWJsZScsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5jbG9zZXN0KCdmb3JtJykuc3VibWl0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pOyAgICAgIFxuXG4gICAgU2VsZWN0LmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5saXN0LmRlZmF1bHRzLCB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgdHBsIFxuICAgICAgICBAZGVmYXVsdCA8c2VsZWN0Pjwvc2VsZWN0PlxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgdHBsOic8c2VsZWN0Pjwvc2VsZWN0PidcbiAgICB9KTtcblxuICAgICQuZm4uZWRpdGFibGV0eXBlcy5zZWxlY3QgPSBTZWxlY3Q7ICAgICAgXG5cbn0od2luZG93LmpRdWVyeSkpO1xuXG4vKipcbkxpc3Qgb2YgY2hlY2tib3hlcy4gXG5JbnRlcm5hbGx5IHZhbHVlIHN0b3JlZCBhcyBqYXZhc2NyaXB0IGFycmF5IG9mIHZhbHVlcy5cblxuQGNsYXNzIGNoZWNrbGlzdFxuQGV4dGVuZHMgbGlzdFxuQGZpbmFsXG5AZXhhbXBsZVxuPGEgaHJlZj1cIiNcIiBpZD1cIm9wdGlvbnNcIiBkYXRhLXR5cGU9XCJjaGVja2xpc3RcIiBkYXRhLXBrPVwiMVwiIGRhdGEtdXJsPVwiL3Bvc3RcIiBkYXRhLXRpdGxlPVwiU2VsZWN0IG9wdGlvbnNcIj48L2E+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgICQoJyNvcHRpb25zJykuZWRpdGFibGUoe1xuICAgICAgICB2YWx1ZTogWzIsIDNdLCAgICBcbiAgICAgICAgc291cmNlOiBbXG4gICAgICAgICAgICAgIHt2YWx1ZTogMSwgdGV4dDogJ29wdGlvbjEnfSxcbiAgICAgICAgICAgICAge3ZhbHVlOiAyLCB0ZXh0OiAnb3B0aW9uMid9LFxuICAgICAgICAgICAgICB7dmFsdWU6IDMsIHRleHQ6ICdvcHRpb24zJ31cbiAgICAgICAgICAgXVxuICAgIH0pO1xufSk7XG48L3NjcmlwdD5cbioqL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgXG4gICAgdmFyIENoZWNrbGlzdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdCgnY2hlY2tsaXN0Jywgb3B0aW9ucywgQ2hlY2tsaXN0LmRlZmF1bHRzKTtcbiAgICB9O1xuXG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoQ2hlY2tsaXN0LCAkLmZuLmVkaXRhYmxldHlwZXMubGlzdCk7XG5cbiAgICAkLmV4dGVuZChDaGVja2xpc3QucHJvdG90eXBlLCB7XG4gICAgICAgIHJlbmRlckxpc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyICRsYWJlbCwgJGRpdjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kdHBsLmVtcHR5KCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCEkLmlzQXJyYXkodGhpcy5zb3VyY2VEYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8dGhpcy5zb3VyY2VEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgJGxhYmVsID0gJCgnPGxhYmVsPicpLmFwcGVuZCgkKCc8aW5wdXQ+Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjaGVja2JveCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuc291cmNlRGF0YVtpXS52YWx1ZSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoJzxzcGFuPicpLnRleHQoJyAnK3RoaXMuc291cmNlRGF0YVtpXS50ZXh0KSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgJCgnPGRpdj4nKS5hcHBlbmQoJGxhYmVsKS5hcHBlbmRUbyh0aGlzLiR0cGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRpbnB1dCA9IHRoaXMuJHRwbC5maW5kKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3MoKTtcbiAgICAgICAgfSxcbiAgICAgICBcbiAgICAgICB2YWx1ZTJzdHI6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgIHJldHVybiAkLmlzQXJyYXkodmFsdWUpID8gdmFsdWUuc29ydCgpLmpvaW4oJC50cmltKHRoaXMub3B0aW9ucy5zZXBhcmF0b3IpKSA6ICcnO1xuICAgICAgIH0sICBcbiAgICAgICBcbiAgICAgICAvL3BhcnNlIHNlcGFyYXRlZCBzdHJpbmdcbiAgICAgICAgc3RyMnZhbHVlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgdmFyIHJlZywgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICBpZih0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyAmJiBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICByZWcgPSBuZXcgUmVnRXhwKCdcXFxccyonKyQudHJpbSh0aGlzLm9wdGlvbnMuc2VwYXJhdG9yKSsnXFxcXHMqJyk7XG4gICAgICAgICAgICAgICB2YWx1ZSA9IHN0ci5zcGxpdChyZWcpO1xuICAgICAgICAgICB9IGVsc2UgaWYoJC5pc0FycmF5KHN0cikpIHtcbiAgICAgICAgICAgICAgIHZhbHVlID0gc3RyOyBcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIHZhbHVlID0gW3N0cl07XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LCAgICAgICBcbiAgICAgICBcbiAgICAgICAvL3NldCBjaGVja2VkIG9uIHJlcXVpcmVkIGNoZWNrYm94ZXNcbiAgICAgICB2YWx1ZTJpbnB1dDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LnByb3AoJ2NoZWNrZWQnLCBmYWxzZSk7XG4gICAgICAgICAgICBpZigkLmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgdGhpcy4kaW5wdXQuZWFjaChmdW5jdGlvbihpLCBlbCkge1xuICAgICAgICAgICAgICAgICAgIHZhciAkZWwgPSAkKGVsKTtcbiAgICAgICAgICAgICAgICAgICAvLyBjYW5ub3QgdXNlICQuaW5BcnJheSBhcyBpdCBwZXJmb3JtcyBzdHJpY3QgY29tcGFyaXNvblxuICAgICAgICAgICAgICAgICAgICQuZWFjaCh2YWx1ZSwgZnVuY3Rpb24oaiwgdmFsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgLypqc2xpbnQgZXFlcTogdHJ1ZSovXG4gICAgICAgICAgICAgICAgICAgICAgIGlmKCRlbC52YWwoKSA9PSB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgLypqc2xpbnQgZXFlcTogZmFsc2UqLyAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJGVsLnByb3AoJ2NoZWNrZWQnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgfSk7IFxuICAgICAgICAgICAgfSAgXG4gICAgICAgIH0sICBcbiAgICAgICAgXG4gICAgICAgaW5wdXQydmFsdWU6IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgdmFyIGNoZWNrZWQgPSBbXTtcbiAgICAgICAgICAgdGhpcy4kaW5wdXQuZmlsdGVyKCc6Y2hlY2tlZCcpLmVhY2goZnVuY3Rpb24oaSwgZWwpIHtcbiAgICAgICAgICAgICAgIGNoZWNrZWQucHVzaCgkKGVsKS52YWwoKSk7XG4gICAgICAgICAgIH0pO1xuICAgICAgICAgICByZXR1cm4gY2hlY2tlZDtcbiAgICAgICB9LCAgICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgIC8vY29sbGVjdCB0ZXh0IG9mIGNoZWNrZWQgYm94ZXNcbiAgICAgICAgdmFsdWUyaHRtbEZpbmFsOiBmdW5jdGlvbih2YWx1ZSwgZWxlbWVudCkge1xuICAgICAgICAgICB2YXIgaHRtbCA9IFtdLFxuICAgICAgICAgICAgICAgY2hlY2tlZCA9ICQuZm4uZWRpdGFibGV1dGlscy5pdGVtc0J5VmFsdWUodmFsdWUsIHRoaXMuc291cmNlRGF0YSksXG4gICAgICAgICAgICAgICBlc2NhcGUgPSB0aGlzLm9wdGlvbnMuZXNjYXBlO1xuICAgICAgICAgICAgICAgXG4gICAgICAgICAgIGlmKGNoZWNrZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAkLmVhY2goY2hlY2tlZCwgZnVuY3Rpb24oaSwgdikge1xuICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gZXNjYXBlID8gJC5mbi5lZGl0YWJsZXV0aWxzLmVzY2FwZSh2LnRleHQpIDogdi50ZXh0OyBcbiAgICAgICAgICAgICAgICAgICBodG1sLnB1c2godGV4dCk7IFxuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAkKGVsZW1lbnQpLmh0bWwoaHRtbC5qb2luKCc8YnI+JykpO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgJChlbGVtZW50KS5lbXB0eSgpOyBcbiAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIHRoaXMuJGlucHV0LmZpcnN0KCkuZm9jdXMoKTtcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIGF1dG9zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICB0aGlzLiRpbnB1dC5vbigna2V5ZG93bicsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IDEzKSB7XG4gICAgICAgICAgICAgICAgICAgJCh0aGlzKS5jbG9zZXN0KCdmb3JtJykuc3VibWl0KCk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgIH0pO1xuICAgICAgIH1cbiAgICB9KTsgICAgICBcblxuICAgIENoZWNrbGlzdC5kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxldHlwZXMubGlzdC5kZWZhdWx0cywge1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IHRwbCBcbiAgICAgICAgQGRlZmF1bHQgPGRpdj48L2Rpdj5cbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHRwbDonPGRpdiBjbGFzcz1cImVkaXRhYmxlLWNoZWNrbGlzdFwiPjwvZGl2PicsXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IGlucHV0Y2xhc3MgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBpbnB1dGNsYXNzOiBudWxsLCAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgU2VwYXJhdG9yIG9mIHZhbHVlcyB3aGVuIHJlYWRpbmcgZnJvbSBgZGF0YS12YWx1ZWAgYXR0cmlidXRlXG5cbiAgICAgICAgQHByb3BlcnR5IHNlcGFyYXRvciBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICcsJ1xuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgc2VwYXJhdG9yOiAnLCdcbiAgICB9KTtcblxuICAgICQuZm4uZWRpdGFibGV0eXBlcy5jaGVja2xpc3QgPSBDaGVja2xpc3Q7ICAgICAgXG5cbn0od2luZG93LmpRdWVyeSkpO1xuXG4vKipcbkhUTUw1IGlucHV0IHR5cGVzLlxuRm9sbG93aW5nIHR5cGVzIGFyZSBzdXBwb3J0ZWQ6XG5cbiogcGFzc3dvcmRcbiogZW1haWxcbiogdXJsXG4qIHRlbFxuKiBudW1iZXJcbiogcmFuZ2VcbiogdGltZVxuXG5MZWFybiBtb3JlIGFib3V0IGh0bWw1IGlucHV0czogIFxuaHR0cDovL3d3dy53My5vcmcvd2lraS9IVE1MNV9mb3JtX2FkZGl0aW9ucyAgXG5UbyBjaGVjayBicm93c2VyIGNvbXBhdGliaWxpdHkgcGxlYXNlIHNlZTogIFxuaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9IVE1ML0VsZW1lbnQvSW5wdXRcbiAgICAgICAgICAgIFxuQGNsYXNzIGh0bWw1dHlwZXMgXG5AZXh0ZW5kcyB0ZXh0XG5AZmluYWxcbkBzaW5jZSAxLjMuMFxuQGV4YW1wbGVcbjxhIGhyZWY9XCIjXCIgaWQ9XCJlbWFpbFwiIGRhdGEtdHlwZT1cImVtYWlsXCIgZGF0YS1waz1cIjFcIj5hZG1pbkBleGFtcGxlLmNvbTwvYT5cbjxzY3JpcHQ+XG4kKGZ1bmN0aW9uKCl7XG4gICAgJCgnI2VtYWlsJykuZWRpdGFibGUoe1xuICAgICAgICB1cmw6ICcvcG9zdCcsXG4gICAgICAgIHRpdGxlOiAnRW50ZXIgZW1haWwnXG4gICAgfSk7XG59KTtcbjwvc2NyaXB0PlxuKiovXG5cbi8qKlxuQHByb3BlcnR5IHRwbCBcbkBkZWZhdWx0IGRlcGVuZHMgb24gdHlwZVxuKiovIFxuXG4vKlxuUGFzc3dvcmRcbiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBcbiAgICB2YXIgUGFzc3dvcmQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ3Bhc3N3b3JkJywgb3B0aW9ucywgUGFzc3dvcmQuZGVmYXVsdHMpO1xuICAgIH07XG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoUGFzc3dvcmQsICQuZm4uZWRpdGFibGV0eXBlcy50ZXh0KTtcbiAgICAkLmV4dGVuZChQYXNzd29yZC5wcm90b3R5cGUsIHtcbiAgICAgICAvL2RvIG5vdCBkaXNwbGF5IHBhc3N3b3JkLCBzaG93ICdbaGlkZGVuXScgaW5zdGVhZFxuICAgICAgIHZhbHVlMmh0bWw6IGZ1bmN0aW9uKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgICAgICAgIGlmKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAkKGVsZW1lbnQpLnRleHQoJ1toaWRkZW5dJyk7XG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAkKGVsZW1lbnQpLmVtcHR5KCk7IFxuICAgICAgICAgICB9XG4gICAgICAgfSxcbiAgICAgICAvL2FzIHBhc3N3b3JkIG5vdCBkaXNwbGF5ZWQsIHNob3VsZCBub3Qgc2V0IHZhbHVlIGJ5IGh0bWxcbiAgICAgICBodG1sMnZhbHVlOiBmdW5jdGlvbihodG1sKSB7XG4gICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgIH0gICAgICAgXG4gICAgfSk7ICAgIFxuICAgIFBhc3N3b3JkLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy50ZXh0LmRlZmF1bHRzLCB7XG4gICAgICAgIHRwbDogJzxpbnB1dCB0eXBlPVwicGFzc3dvcmRcIj4nXG4gICAgfSk7XG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLnBhc3N3b3JkID0gUGFzc3dvcmQ7XG59KHdpbmRvdy5qUXVlcnkpKTtcblxuXG4vKlxuRW1haWxcbiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBcbiAgICB2YXIgRW1haWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ2VtYWlsJywgb3B0aW9ucywgRW1haWwuZGVmYXVsdHMpO1xuICAgIH07XG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoRW1haWwsICQuZm4uZWRpdGFibGV0eXBlcy50ZXh0KTtcbiAgICBFbWFpbC5kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxldHlwZXMudGV4dC5kZWZhdWx0cywge1xuICAgICAgICB0cGw6ICc8aW5wdXQgdHlwZT1cImVtYWlsXCI+J1xuICAgIH0pO1xuICAgICQuZm4uZWRpdGFibGV0eXBlcy5lbWFpbCA9IEVtYWlsO1xufSh3aW5kb3cualF1ZXJ5KSk7XG5cblxuLypcblVybFxuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIFxuICAgIHZhciBVcmwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ3VybCcsIG9wdGlvbnMsIFVybC5kZWZhdWx0cyk7XG4gICAgfTtcbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChVcmwsICQuZm4uZWRpdGFibGV0eXBlcy50ZXh0KTtcbiAgICBVcmwuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQuZGVmYXVsdHMsIHtcbiAgICAgICAgdHBsOiAnPGlucHV0IHR5cGU9XCJ1cmxcIj4nXG4gICAgfSk7XG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLnVybCA9IFVybDtcbn0od2luZG93LmpRdWVyeSkpO1xuXG5cbi8qXG5UZWxcbiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBcbiAgICB2YXIgVGVsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCd0ZWwnLCBvcHRpb25zLCBUZWwuZGVmYXVsdHMpO1xuICAgIH07XG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoVGVsLCAkLmZuLmVkaXRhYmxldHlwZXMudGV4dCk7XG4gICAgVGVsLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy50ZXh0LmRlZmF1bHRzLCB7XG4gICAgICAgIHRwbDogJzxpbnB1dCB0eXBlPVwidGVsXCI+J1xuICAgIH0pO1xuICAgICQuZm4uZWRpdGFibGV0eXBlcy50ZWwgPSBUZWw7XG59KHdpbmRvdy5qUXVlcnkpKTtcblxuXG4vKlxuTnVtYmVyXG4qL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgXG4gICAgdmFyIE51bWJlcklucHV0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCdudW1iZXInLCBvcHRpb25zLCBOdW1iZXJJbnB1dC5kZWZhdWx0cyk7XG4gICAgfTtcbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChOdW1iZXJJbnB1dCwgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQpO1xuICAgICQuZXh0ZW5kKE51bWJlcklucHV0LnByb3RvdHlwZSwge1xuICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBOdW1iZXJJbnB1dC5zdXBlcmNsYXNzLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdtaW4nKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignbWF4Jyk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3N0ZXAnKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zdHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLiRjbGVhcikge1xuICAgICAgICAgICAgICAgIC8vaW5jcmVhc2UgcmlnaHQgZmZzZXQgIGZvciB1cC9kb3duIGFycm93c1xuICAgICAgICAgICAgICAgIHRoaXMuJGNsZWFyLmNzcyh7cmlnaHQ6IDI0fSk7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAvL2NhbiBwb3NpdGlvbiBjbGVhciBidXR0b24gb25seSBoZXJlLCB3aGVuIGZvcm0gaXMgc2hvd24gYW5kIGhlaWdodCBjYW4gYmUgY2FsY3VsYXRlZFxuICAgICAgICAgICAgICAgIHZhciBoID0gdGhpcy4kaW5wdXQub3V0ZXJIZWlnaHQodHJ1ZSkgfHwgMjAsXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhID0gKGggLSB0aGlzLiRjbGVhci5oZWlnaHQoKSkgLyAyO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vYWRkIDEycHggdG8gb2Zmc2V0IHJpZ2h0IGZvciB1cC9kb3duIGFycm93cyAgICBcbiAgICAgICAgICAgICAgICB0aGlzLiRjbGVhci5jc3Moe3RvcDogZGVsdGEsIHJpZ2h0OiBkZWx0YSArIDE2fSk7XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0gICAgICAgIFxuICAgIH0pOyAgICAgXG4gICAgTnVtYmVySW5wdXQuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQuZGVmYXVsdHMsIHtcbiAgICAgICAgdHBsOiAnPGlucHV0IHR5cGU9XCJudW1iZXJcIj4nLFxuICAgICAgICBpbnB1dGNsYXNzOiAnaW5wdXQtbWluaScsXG4gICAgICAgIG1pbjogbnVsbCxcbiAgICAgICAgbWF4OiBudWxsLFxuICAgICAgICBzdGVwOiBudWxsXG4gICAgfSk7XG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLm51bWJlciA9IE51bWJlcklucHV0O1xufSh3aW5kb3cualF1ZXJ5KSk7XG5cblxuLypcblJhbmdlIChpbmhlcml0IGZyb20gbnVtYmVyKVxuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIFxuICAgIHZhciBSYW5nZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdCgncmFuZ2UnLCBvcHRpb25zLCBSYW5nZS5kZWZhdWx0cyk7XG4gICAgfTtcbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChSYW5nZSwgJC5mbi5lZGl0YWJsZXR5cGVzLm51bWJlcik7XG4gICAgJC5leHRlbmQoUmFuZ2UucHJvdG90eXBlLCB7XG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQgPSB0aGlzLiR0cGwuZmlsdGVyKCdpbnB1dCcpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnNldENsYXNzKCk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ21pbicpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdtYXgnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignc3RlcCcpOyAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJGlucHV0Lm9uKCdpbnB1dCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5zaWJsaW5ncygnb3V0cHV0JykudGV4dCgkKHRoaXMpLnZhbCgpKTsgXG4gICAgICAgICAgICB9KTsgIFxuICAgICAgICB9LFxuICAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5mb2N1cygpO1xuICAgICAgICB9ICAgICAgICAgXG4gICAgfSk7XG4gICAgUmFuZ2UuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLm51bWJlci5kZWZhdWx0cywge1xuICAgICAgICB0cGw6ICc8aW5wdXQgdHlwZT1cInJhbmdlXCI+PG91dHB1dCBzdHlsZT1cIndpZHRoOiAzMHB4OyBkaXNwbGF5OiBpbmxpbmUtYmxvY2tcIj48L291dHB1dD4nLFxuICAgICAgICBpbnB1dGNsYXNzOiAnaW5wdXQtbWVkaXVtJ1xuICAgIH0pO1xuICAgICQuZm4uZWRpdGFibGV0eXBlcy5yYW5nZSA9IFJhbmdlO1xufSh3aW5kb3cualF1ZXJ5KSk7XG5cbi8qXG5UaW1lXG4qL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgVGltZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdCgndGltZScsIG9wdGlvbnMsIFRpbWUuZGVmYXVsdHMpO1xuICAgIH07XG4gICAgLy9pbmhlcml0IGZyb20gYWJzdHJhY3QsIGFzIGluaGVyaXRhbmNlIGZyb20gdGV4dCBnaXZlcyBzZWxlY3Rpb24gZXJyb3IuXG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoVGltZSwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQpO1xuICAgICQuZXh0ZW5kKFRpbWUucHJvdG90eXBlLCB7XG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIHRoaXMuc2V0Q2xhc3MoKTtcbiAgICAgICAgfSAgICAgICAgXG4gICAgfSk7XG4gICAgVGltZS5kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dC5kZWZhdWx0cywge1xuICAgICAgICB0cGw6ICc8aW5wdXQgdHlwZT1cInRpbWVcIj4nXG4gICAgfSk7XG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLnRpbWUgPSBUaW1lO1xufSh3aW5kb3cualF1ZXJ5KSk7XG5cbi8qKlxuU2VsZWN0MiBpbnB1dC4gQmFzZWQgb24gYW1hemluZyB3b3JrIG9mIElnb3IgVmF5bmJlcmcgaHR0cHM6Ly9naXRodWIuY29tL2l2YXluYmVyZy9zZWxlY3QyLiAgXG5QbGVhc2Ugc2VlIFtvcmlnaW5hbCBzZWxlY3QyIGRvY3NdKGh0dHA6Ly9pdmF5bmJlcmcuZ2l0aHViLmNvbS9zZWxlY3QyKSBmb3IgZGV0YWlsZWQgZGVzY3JpcHRpb24gYW5kIG9wdGlvbnMuICBcbiBcbllvdSBzaG91bGQgbWFudWFsbHkgZG93bmxvYWQgYW5kIGluY2x1ZGUgc2VsZWN0MiBkaXN0cmlidXRpdmU6ICBcblxuICAgIDxsaW5rIGhyZWY9XCJzZWxlY3QyL3NlbGVjdDIuY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiIHR5cGU9XCJ0ZXh0L2Nzc1wiPjwvbGluaz4gIFxuICAgIDxzY3JpcHQgc3JjPVwic2VsZWN0Mi9zZWxlY3QyLmpzXCI+PC9zY3JpcHQ+ICBcbiAgICBcblRvIG1ha2UgaXQgKipib290c3RyYXAtc3R5bGVkKiogeW91IGNhbiB1c2UgY3NzIGZyb20gW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS90MG0vc2VsZWN0Mi1ib290c3RyYXAtY3NzKTogXG5cbiAgICA8bGluayBocmVmPVwic2VsZWN0Mi1ib290c3RyYXAuY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiIHR5cGU9XCJ0ZXh0L2Nzc1wiPjwvbGluaz4gICAgXG4gICAgXG4qKk5vdGU6KiogY3VycmVudGx5IGBhdXRvdGV4dGAgZmVhdHVyZSBkb2VzIG5vdCB3b3JrIGZvciBzZWxlY3QyIHdpdGggYGFqYXhgIHJlbW90ZSBzb3VyY2UuICAgIFxuWW91IG5lZWQgaW5pdGlhbGx5IHB1dCBib3RoIGBkYXRhLXZhbHVlYCBhbmQgZWxlbWVudCdzIHRleHQgeW91c2VsZjogICAgXG5cbiAgICA8YSBocmVmPVwiI1wiIGRhdGEtdHlwZT1cInNlbGVjdDJcIiBkYXRhLXZhbHVlPVwiMVwiPlRleHQxPC9hPlxuICAgIFxuICAgIFxuQGNsYXNzIHNlbGVjdDJcbkBleHRlbmRzIGFic3RyYWN0aW5wdXRcbkBzaW5jZSAxLjQuMVxuQGZpbmFsXG5AZXhhbXBsZVxuPGEgaHJlZj1cIiNcIiBpZD1cImNvdW50cnlcIiBkYXRhLXR5cGU9XCJzZWxlY3QyXCIgZGF0YS1waz1cIjFcIiBkYXRhLXZhbHVlPVwicnVcIiBkYXRhLXVybD1cIi9wb3N0XCIgZGF0YS10aXRsZT1cIlNlbGVjdCBjb3VudHJ5XCI+PC9hPlxuPHNjcmlwdD5cbiQoZnVuY3Rpb24oKXtcbiAgICAvL2xvY2FsIHNvdXJjZVxuICAgICQoJyNjb3VudHJ5JykuZWRpdGFibGUoe1xuICAgICAgICBzb3VyY2U6IFtcbiAgICAgICAgICAgICAge2lkOiAnZ2InLCB0ZXh0OiAnR3JlYXQgQnJpdGFpbid9LFxuICAgICAgICAgICAgICB7aWQ6ICd1cycsIHRleHQ6ICdVbml0ZWQgU3RhdGVzJ30sXG4gICAgICAgICAgICAgIHtpZDogJ3J1JywgdGV4dDogJ1J1c3NpYSd9XG4gICAgICAgICAgIF0sXG4gICAgICAgIHNlbGVjdDI6IHtcbiAgICAgICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vcmVtb3RlIHNvdXJjZSAoc2ltcGxlKVxuICAgICQoJyNjb3VudHJ5JykuZWRpdGFibGUoe1xuICAgICAgICBzb3VyY2U6ICcvZ2V0Q291bnRyaWVzJyxcbiAgICAgICAgc2VsZWN0Mjoge1xuICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdTZWxlY3QgQ291bnRyeScsXG4gICAgICAgICAgICBtaW5pbXVtSW5wdXRMZW5ndGg6IDFcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vcmVtb3RlIHNvdXJjZSAoYWR2YW5jZWQpXG4gICAgJCgnI2NvdW50cnknKS5lZGl0YWJsZSh7XG4gICAgICAgIHNlbGVjdDI6IHtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAnU2VsZWN0IENvdW50cnknLFxuICAgICAgICAgICAgYWxsb3dDbGVhcjogdHJ1ZSxcbiAgICAgICAgICAgIG1pbmltdW1JbnB1dExlbmd0aDogMyxcbiAgICAgICAgICAgIGlkOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLkNvdW50cnlJZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhamF4OiB7XG4gICAgICAgICAgICAgICAgdXJsOiAnL2dldENvdW50cmllcycsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgICAgICBkYXRhOiBmdW5jdGlvbiAodGVybSwgcGFnZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBxdWVyeTogdGVybSB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVzdWx0czogZnVuY3Rpb24gKGRhdGEsIHBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0czogZGF0YSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JtYXRSZXN1bHQ6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uQ291bnRyeU5hbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9ybWF0U2VsZWN0aW9uOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLkNvdW50cnlOYW1lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluaXRTZWxlY3Rpb246IGZ1bmN0aW9uIChlbGVtZW50LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiAkLmdldCgnL2dldENvdW50cnlCeUlkJywgeyBxdWVyeTogZWxlbWVudC52YWwoKSB9LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0gIFxuICAgIH0pO1xufSk7XG48L3NjcmlwdD5cbioqL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgXG4gICAgdmFyIENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCdzZWxlY3QyJywgb3B0aW9ucywgQ29uc3RydWN0b3IuZGVmYXVsdHMpO1xuXG4gICAgICAgIG9wdGlvbnMuc2VsZWN0MiA9IG9wdGlvbnMuc2VsZWN0MiB8fCB7fTtcblxuICAgICAgICB0aGlzLnNvdXJjZURhdGEgPSBudWxsO1xuICAgICAgICBcbiAgICAgICAgLy9wbGFjZWhvbGRlclxuICAgICAgICBpZihvcHRpb25zLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNlbGVjdDIucGxhY2Vob2xkZXIgPSBvcHRpb25zLnBsYWNlaG9sZGVyO1xuICAgICAgICB9XG4gICAgICAgXG4gICAgICAgIC8vaWYgbm90IGB0YWdzYCBtb2RlLCB1c2Ugc291cmNlXG4gICAgICAgIGlmKCFvcHRpb25zLnNlbGVjdDIudGFncyAmJiBvcHRpb25zLnNvdXJjZSkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IG9wdGlvbnMuc291cmNlO1xuICAgICAgICAgICAgLy9pZiBzb3VyY2UgaXMgZnVuY3Rpb24sIGNhbGwgaXQgKG9uY2UhKVxuICAgICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihvcHRpb25zLnNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBvcHRpb25zLnNvdXJjZS5jYWxsKG9wdGlvbnMuc2NvcGUpO1xuICAgICAgICAgICAgfSAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNlbGVjdDIuYWpheCA9IG9wdGlvbnMuc2VsZWN0Mi5hamF4IHx8IHt9O1xuICAgICAgICAgICAgICAgIC8vc29tZSBkZWZhdWx0IGFqYXggcGFyYW1zXG4gICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuc2VsZWN0Mi5hamF4LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zZWxlY3QyLmFqYXguZGF0YSA9IGZ1bmN0aW9uKHRlcm0pIHtyZXR1cm4geyBxdWVyeTp0ZXJtIH07fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuc2VsZWN0Mi5hamF4LnJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zZWxlY3QyLmFqYXgucmVzdWx0cyA9IGZ1bmN0aW9uKGRhdGEpIHsgcmV0dXJuIHtyZXN1bHRzOmRhdGEgfTt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRpb25zLnNlbGVjdDIuYWpheC51cmwgPSBzb3VyY2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vY2hlY2sgZm9ybWF0IGFuZCBjb252ZXJ0IHgtZWRpdGFibGUgZm9ybWF0IHRvIHNlbGVjdDIgZm9ybWF0IChpZiBuZWVkZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VEYXRhID0gdGhpcy5jb252ZXJ0U291cmNlKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zZWxlY3QyLmRhdGEgPSB0aGlzLnNvdXJjZURhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gXG5cbiAgICAgICAgLy9vdmVycmlkaW5nIG9iamVjdHMgaW4gY29uZmlnIChhcyBieSBkZWZhdWx0IGpRdWVyeSBleHRlbmQoKSBpcyBub3QgcmVjdXJzaXZlKVxuICAgICAgICB0aGlzLm9wdGlvbnMuc2VsZWN0MiA9ICQuZXh0ZW5kKHt9LCBDb25zdHJ1Y3Rvci5kZWZhdWx0cy5zZWxlY3QyLCBvcHRpb25zLnNlbGVjdDIpO1xuXG4gICAgICAgIC8vZGV0ZWN0IHdoZXRoZXIgaXQgaXMgbXVsdGktdmFsdWVkXG4gICAgICAgIHRoaXMuaXNNdWx0aXBsZSA9IHRoaXMub3B0aW9ucy5zZWxlY3QyLnRhZ3MgfHwgdGhpcy5vcHRpb25zLnNlbGVjdDIubXVsdGlwbGU7XG4gICAgICAgIHRoaXMuaXNSZW1vdGUgPSAoJ2FqYXgnIGluIHRoaXMub3B0aW9ucy5zZWxlY3QyKTtcblxuICAgICAgICAvL3N0b3JlIGZ1bmN0aW9uIHJldHVybmluZyBJRCBvZiBpdGVtXG4gICAgICAgIC8vc2hvdWxkIGJlIGhlcmUgYXMgdXNlZCBpbmF1dG90ZXh0IGZvciBsb2NhbCBzb3VyY2VcbiAgICAgICAgdGhpcy5pZEZ1bmMgPSB0aGlzLm9wdGlvbnMuc2VsZWN0Mi5pZDtcbiAgICAgICAgaWYgKHR5cGVvZih0aGlzLmlkRnVuYykgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIGlkS2V5ID0gdGhpcy5pZEZ1bmMgfHwgJ2lkJztcbiAgICAgICAgICAgIHRoaXMuaWRGdW5jID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGVbaWRLZXldOyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy9zdG9yZSBmdW5jdGlvbiB0aGF0IHJlbmRlcnMgdGV4dCBpbiBzZWxlY3QyXG4gICAgICAgIHRoaXMuZm9ybWF0U2VsZWN0aW9uID0gdGhpcy5vcHRpb25zLnNlbGVjdDIuZm9ybWF0U2VsZWN0aW9uO1xuICAgICAgICBpZiAodHlwZW9mKHRoaXMuZm9ybWF0U2VsZWN0aW9uKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnRleHQ7IH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoQ29uc3RydWN0b3IsICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0KTtcblxuICAgICQuZXh0ZW5kKENvbnN0cnVjdG9yLnByb3RvdHlwZSwge1xuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRDbGFzcygpO1xuXG4gICAgICAgICAgICAvL2NhbiBub3QgYXBwbHkgc2VsZWN0MiBoZXJlIGFzIGl0IGNhbGxzIGluaXRTZWxlY3Rpb24gXG4gICAgICAgICAgICAvL292ZXIgaW5wdXQgdGhhdCBkb2VzIG5vdCBoYXZlIGNvcnJlY3QgdmFsdWUgeWV0LlxuICAgICAgICAgICAgLy9hcHBseSBzZWxlY3QyIG9ubHkgaW4gdmFsdWUyaW5wdXRcbiAgICAgICAgICAgIC8vdGhpcy4kaW5wdXQuc2VsZWN0Mih0aGlzLm9wdGlvbnMuc2VsZWN0Mik7XG5cbiAgICAgICAgICAgIC8vd2hlbiBkYXRhIGlzIGxvYWRlZCB2aWEgYWpheCwgd2UgbmVlZCB0byBrbm93IHdoZW4gaXQncyBkb25lIHRvIHBvcHVsYXRlIGxpc3REYXRhXG4gICAgICAgICAgICBpZih0aGlzLmlzUmVtb3RlKSB7XG4gICAgICAgICAgICAgICAgLy9saXN0ZW4gdG8gbG9hZGVkIGV2ZW50IHRvIHBvcHVsYXRlIGRhdGFcbiAgICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5vbignc2VsZWN0Mi1sb2FkZWQnLCAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VEYXRhID0gZS5pdGVtcy5yZXN1bHRzO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy90cmlnZ2VyIHJlc2l6ZSBvZiBlZGl0YWJsZWZvcm0gdG8gcmUtcG9zaXRpb24gY29udGFpbmVyIGluIG11bHRpLXZhbHVlZCBtb2RlXG4gICAgICAgICAgICBpZih0aGlzLmlzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgIHRoaXMuJGlucHV0Lm9uKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKS5wYXJlbnQoKS50cmlnZ2VySGFuZGxlcigncmVzaXplJyk7XG4gICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICB9LFxuXG4gICAgICAgdmFsdWUyaHRtbDogZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgdmFyIHRleHQgPSAnJywgZGF0YSxcbiAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5zZWxlY3QyLnRhZ3MpIHsgLy9pbiB0YWdzIG1vZGUganVzdCBhc3NpZ24gdmFsdWVcbiAgICAgICAgICAgICAgZGF0YSA9IHZhbHVlOyBcbiAgICAgICAgICAgICAgLy9kYXRhID0gJC5mbi5lZGl0YWJsZXV0aWxzLml0ZW1zQnlWYWx1ZSh2YWx1ZSwgdGhpcy5vcHRpb25zLnNlbGVjdDIudGFncywgdGhpcy5pZEZ1bmMpO1xuICAgICAgICAgICB9IGVsc2UgaWYodGhpcy5zb3VyY2VEYXRhKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSAkLmZuLmVkaXRhYmxldXRpbHMuaXRlbXNCeVZhbHVlKHZhbHVlLCB0aGlzLnNvdXJjZURhdGEsIHRoaXMuaWRGdW5jKTsgXG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vY2FuIG5vdCBnZXQgbGlzdCBvZiBwb3NzaWJsZSB2YWx1ZXMgXG4gICAgICAgICAgICAgIC8vKGUuZy4gYXV0b3RleHQgZm9yIHNlbGVjdDIgd2l0aCBhamF4IHNvdXJjZSlcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vZGF0YSBtYXkgYmUgYXJyYXkgKHdoZW4gbXVsdGlwbGUgdmFsdWVzIGFsbG93ZWQpXG4gICAgICAgICAgIGlmKCQuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgLy9jb2xsZWN0IHNlbGVjdGVkIGRhdGEgYW5kIHNob3cgd2l0aCBzZXBhcmF0b3JcbiAgICAgICAgICAgICAgIHRleHQgPSBbXTtcbiAgICAgICAgICAgICAgICQuZWFjaChkYXRhLCBmdW5jdGlvbihrLCB2KXtcbiAgICAgICAgICAgICAgICAgICB0ZXh0LnB1c2godiAmJiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgPyB0aGF0LmZvcm1hdFNlbGVjdGlvbih2KSA6IHYpO1xuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgIH0gZWxzZSBpZihkYXRhKSB7XG4gICAgICAgICAgICAgICB0ZXh0ID0gdGhhdC5mb3JtYXRTZWxlY3Rpb24oZGF0YSk7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICB0ZXh0ID0gJC5pc0FycmF5KHRleHQpID8gdGV4dC5qb2luKHRoaXMub3B0aW9ucy52aWV3c2VwYXJhdG9yKSA6IHRleHQ7XG5cbiAgICAgICAgICAgLy8kKGVsZW1lbnQpLnRleHQodGV4dCk7XG4gICAgICAgICAgIENvbnN0cnVjdG9yLnN1cGVyY2xhc3MudmFsdWUyaHRtbC5jYWxsKHRoaXMsIHRleHQsIGVsZW1lbnQpOyBcbiAgICAgICB9LFxuXG4gICAgICAgaHRtbDJ2YWx1ZTogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNlbGVjdDIudGFncyA/IHRoaXMuc3RyMnZhbHVlKGh0bWwsIHRoaXMub3B0aW9ucy52aWV3c2VwYXJhdG9yKSA6IG51bGw7XG4gICAgICAgfSxcblxuICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAvLyBpZiB2YWx1ZSBhcnJheSA9PiBqb2luIGl0IGFueXdheVxuICAgICAgICAgICBpZigkLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuam9pbih0aGlzLmdldFNlcGFyYXRvcigpKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vZm9yIHJlbW90ZSBzb3VyY2UganVzdCBzZXQgdmFsdWUsIHRleHQgaXMgdXBkYXRlZCBieSBpbml0U2VsZWN0aW9uXG4gICAgICAgICAgIGlmKCF0aGlzLiRpbnB1dC5kYXRhKCdzZWxlY3QyJykpIHtcbiAgICAgICAgICAgICAgIHRoaXMuJGlucHV0LnZhbCh2YWx1ZSk7XG4gICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5zZWxlY3QyKHRoaXMub3B0aW9ucy5zZWxlY3QyKTtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIC8vc2Vjb25kIGFyZ3VtZW50IG5lZWRlZCB0byBzZXBhcmF0ZSBpbml0aWFsIGNoYW5nZSBmcm9tIHVzZXIncyBjbGljayAoZm9yIGF1dG9zdWJtaXQpICAgXG4gICAgICAgICAgICAgICB0aGlzLiRpbnB1dC52YWwodmFsdWUpLnRyaWdnZXIoJ2NoYW5nZScsIHRydWUpOyBcblxuICAgICAgICAgICAgICAgLy9VbmNhdWdodCBFcnJvcjogY2Fubm90IGNhbGwgdmFsKCkgaWYgaW5pdFNlbGVjdGlvbigpIGlzIG5vdCBkZWZpbmVkXG4gICAgICAgICAgICAgICAvL3RoaXMuJGlucHV0LnNlbGVjdDIoJ3ZhbCcsIHZhbHVlKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vIGlmIGRlZmluZWQgcmVtb3RlIHNvdXJjZSBBTkQgbm8gbXVsdGlwbGUgbW9kZSBBTkQgbm8gdXNlcidzIGluaXRTZWxlY3Rpb24gcHJvdmlkZWQgLS0+IFxuICAgICAgICAgICAvLyB3ZSBzaG91bGQgc29tZWhvdyBnZXQgdGV4dCBmb3IgcHJvdmlkZWQgaWQuXG4gICAgICAgICAgIC8vIFRoZSBzb2x1dGlvbiBpcyB0byB1c2UgZWxlbWVudCdzIHRleHQgYXMgdGV4dCBmb3IgdGhhdCBpZCAoZXhjbHVkZSBlbXB0eSlcbiAgICAgICAgICAgaWYodGhpcy5pc1JlbW90ZSAmJiAhdGhpcy5pc011bHRpcGxlICYmICF0aGlzLm9wdGlvbnMuc2VsZWN0Mi5pbml0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAvLyBjdXN0b21JZCBhbmQgY3VzdG9tVGV4dCBhcmUgbWV0aG9kcyB0byBleHRyYWN0IGBpZGAgYW5kIGB0ZXh0YCBmcm9tIGRhdGEgb2JqZWN0XG4gICAgICAgICAgICAgICAvLyB3ZSBjYW4gdXNlIHRoaXMgd29ya2Fyb3VuZCBvbmx5IGlmIHVzZXIgZGlkIG5vdCBkZWZpbmUgdGhlc2UgbWV0aG9kc1xuICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIGNhbnQgY29uc3RydWN0IGRhdGEgb2JqZWN0XG4gICAgICAgICAgICAgICB2YXIgY3VzdG9tSWQgPSB0aGlzLm9wdGlvbnMuc2VsZWN0Mi5pZCxcbiAgICAgICAgICAgICAgICAgICBjdXN0b21UZXh0ID0gdGhpcy5vcHRpb25zLnNlbGVjdDIuZm9ybWF0U2VsZWN0aW9uO1xuXG4gICAgICAgICAgICAgICBpZighY3VzdG9tSWQgJiYgIWN1c3RvbVRleHQpIHtcbiAgICAgICAgICAgICAgICAgICB2YXIgJGVsID0gJCh0aGlzLm9wdGlvbnMuc2NvcGUpO1xuICAgICAgICAgICAgICAgICAgIGlmICghJGVsLmRhdGEoJ2VkaXRhYmxlJykuaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHtpZDogdmFsdWUsIHRleHQ6ICRlbC50ZXh0KCl9O1xuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5zZWxlY3QyKCdkYXRhJywgZGF0YSk7IFxuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgaW5wdXQydmFsdWU6IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuJGlucHV0LnNlbGVjdDIoJ3ZhbCcpO1xuICAgICAgIH0sXG5cbiAgICAgICBzdHIydmFsdWU6IGZ1bmN0aW9uKHN0ciwgc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICBpZih0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJyB8fCAhdGhpcy5pc011bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VwYXJhdG9yID0gc2VwYXJhdG9yIHx8IHRoaXMuZ2V0U2VwYXJhdG9yKCk7XG5cbiAgICAgICAgICAgIHZhciB2YWwsIGksIGw7XG5cbiAgICAgICAgICAgIGlmIChzdHIgPT09IG51bGwgfHwgc3RyLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbCA9IHN0ci5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICB2YWxbaV0gPSAkLnRyaW0odmFsW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICB9LFxuXG4gICAgICAgIGF1dG9zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQub24oJ2NoYW5nZScsIGZ1bmN0aW9uKGUsIGlzSW5pdGlhbCl7XG4gICAgICAgICAgICAgICAgaWYoIWlzSW5pdGlhbCkge1xuICAgICAgICAgICAgICAgICAgJCh0aGlzKS5jbG9zZXN0KCdmb3JtJykuc3VibWl0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U2VwYXJhdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc2VsZWN0Mi5zZXBhcmF0b3IgfHwgJC5mbi5zZWxlY3QyLmRlZmF1bHRzLnNlcGFyYXRvcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICBDb252ZXJ0cyBzb3VyY2UgZnJvbSB4LWVkaXRhYmxlIGZvcm1hdDoge3ZhbHVlOiAxLCB0ZXh0OiBcIjFcIn0gdG9cbiAgICAgICAgc2VsZWN0MiBmb3JtYXQ6IHtpZDogMSwgdGV4dDogXCIxXCJ9XG4gICAgICAgICovXG4gICAgICAgIGNvbnZlcnRTb3VyY2U6IGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICAgICAgaWYoJC5pc0FycmF5KHNvdXJjZSkgJiYgc291cmNlLmxlbmd0aCAmJiBzb3VyY2VbMF0udmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGk8c291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHNvdXJjZVtpXS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VbaV0uaWQgPSBzb3VyY2VbaV0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc291cmNlW2ldLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYodGhpcy4kaW5wdXQuZGF0YSgnc2VsZWN0MicpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5wdXQuc2VsZWN0MignZGVzdHJveScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0pO1xuXG4gICAgQ29uc3RydWN0b3IuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQuZGVmYXVsdHMsIHtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSB0cGwgXG4gICAgICAgIEBkZWZhdWx0IDxpbnB1dCB0eXBlPVwiaGlkZGVuXCI+XG4gICAgICAgICoqL1xuICAgICAgICB0cGw6JzxpbnB1dCB0eXBlPVwiaGlkZGVuXCI+JyxcbiAgICAgICAgLyoqXG4gICAgICAgIENvbmZpZ3VyYXRpb24gb2Ygc2VsZWN0Mi4gW0Z1bGwgbGlzdCBvZiBvcHRpb25zXShodHRwOi8vaXZheW5iZXJnLmdpdGh1Yi5jb20vc2VsZWN0MikuXG5cbiAgICAgICAgQHByb3BlcnR5IHNlbGVjdDIgXG4gICAgICAgIEB0eXBlIG9iamVjdFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqL1xuICAgICAgICBzZWxlY3QyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgUGxhY2Vob2xkZXIgYXR0cmlidXRlIG9mIHNlbGVjdFxuXG4gICAgICAgIEBwcm9wZXJ0eSBwbGFjZWhvbGRlciBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovXG4gICAgICAgIHBsYWNlaG9sZGVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgU291cmNlIGRhdGEgZm9yIHNlbGVjdC4gSXQgd2lsbCBiZSBhc3NpZ25lZCB0byBzZWxlY3QyIGBkYXRhYCBwcm9wZXJ0eSBhbmQga2VwdCBoZXJlIGp1c3QgZm9yIGNvbnZlbmllbmNlLlxuICAgICAgICBQbGVhc2Ugbm90ZSwgdGhhdCBmb3JtYXQgaXMgZGlmZmVyZW50IGZyb20gc2ltcGxlIGBzZWxlY3RgIGlucHV0OiB1c2UgJ2lkJyBpbnN0ZWFkIG9mICd2YWx1ZScuXG4gICAgICAgIEUuZy4gYFt7aWQ6IDEsIHRleHQ6IFwidGV4dDFcIn0sIHtpZDogMiwgdGV4dDogXCJ0ZXh0MlwifSwgLi4uXWAuXG5cbiAgICAgICAgQHByb3BlcnR5IHNvdXJjZSBcbiAgICAgICAgQHR5cGUgYXJyYXl8c3RyaW5nfGZ1bmN0aW9uXG4gICAgICAgIEBkZWZhdWx0IG51bGwgICAgICAgIFxuICAgICAgICAqKi9cbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgU2VwYXJhdG9yIHVzZWQgdG8gZGlzcGxheSB0YWdzLlxuXG4gICAgICAgIEBwcm9wZXJ0eSB2aWV3c2VwYXJhdG9yIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgJywgJyAgICAgICAgXG4gICAgICAgICoqL1xuICAgICAgICB2aWV3c2VwYXJhdG9yOiAnLCAnXG4gICAgfSk7XG5cbiAgICAkLmZuLmVkaXRhYmxldHlwZXMuc2VsZWN0MiA9IENvbnN0cnVjdG9yO1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG4qIENvbWJvZGF0ZSAtIDEuMC41XG4qIERyb3Bkb3duIGRhdGUgYW5kIHRpbWUgcGlja2VyLlxuKiBDb252ZXJ0cyB0ZXh0IGlucHV0IGludG8gZHJvcGRvd25zIHRvIHBpY2sgZGF5LCBtb250aCwgeWVhciwgaG91ciwgbWludXRlIGFuZCBzZWNvbmQuXG4qIFVzZXMgbW9tZW50anMgYXMgZGF0ZXRpbWUgbGlicmFyeSBodHRwOi8vbW9tZW50anMuY29tLlxuKiBGb3IgaTE4biBpbmNsdWRlIGNvcnJlc3BvbmRpbmcgZmlsZSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1yd29vZC9tb21lbnQvdHJlZS9tYXN0ZXIvbGFuZyBcbipcbiogQ29uZnVzaW9uIGF0IG5vb24gYW5kIG1pZG5pZ2h0IC0gc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvMTItaG91cl9jbG9jayNDb25mdXNpb25fYXRfbm9vbl9hbmRfbWlkbmlnaHRcbiogSW4gY29tYm9kYXRlOiBcbiogMTI6MDAgcG0gLS0+IDEyOjAwICgyNC1oIGZvcm1hdCwgbWlkZGF5KVxuKiAxMjowMCBhbSAtLT4gMDA6MDAgKDI0LWggZm9ybWF0LCBtaWRuaWdodCwgc3RhcnQgb2YgZGF5KVxuKiBcbiogRGlmZmVycyBmcm9tIG1vbWVudGpzIHBhcnNlIHJ1bGVzOlxuKiAwMDowMCBwbSwgMTI6MDAgcG0gLS0+IDEyOjAwICgyNC1oIGZvcm1hdCwgZGF5IG5vdCBjaGFuZ2UpXG4qIDAwOjAwIGFtLCAxMjowMCBhbSAtLT4gMDA6MDAgKDI0LWggZm9ybWF0LCBkYXkgbm90IGNoYW5nZSlcbiogXG4qIFxuKiBBdXRob3I6IFZpdGFsaXkgUG90YXBvdlxuKiBQcm9qZWN0IHBhZ2U6IGh0dHA6Ly9naXRodWIuY29tL3ZpdGFsZXRzL2NvbWJvZGF0ZVxuKiBDb3B5cmlnaHQgKGMpIDIwMTIgVml0YWxpeSBQb3RhcG92LiBSZWxlYXNlZCB1bmRlciBNSVQgTGljZW5zZS5cbioqL1xuKGZ1bmN0aW9uICgkKSB7XG5cbiAgICB2YXIgQ29tYm9kYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgICAgIGlmKCF0aGlzLiRlbGVtZW50LmlzKCdpbnB1dCcpKSB7XG4gICAgICAgICAgICAkLmVycm9yKCdDb21ib2RhdGUgc2hvdWxkIGJlIGFwcGxpZWQgdG8gSU5QVVQgZWxlbWVudCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmNvbWJvZGF0ZS5kZWZhdWx0cywgb3B0aW9ucywgdGhpcy4kZWxlbWVudC5kYXRhKCkpO1xuICAgICAgICB0aGlzLmluaXQoKTsgIFxuICAgICB9O1xuXG4gICAgQ29tYm9kYXRlLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IENvbWJvZGF0ZSwgXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMubWFwID0ge1xuICAgICAgICAgICAgICAgIC8va2V5ICAgcmVnZXhwICAgIG1vbWVudC5tZXRob2RcbiAgICAgICAgICAgICAgICBkYXk6ICAgIFsnRCcsICAgICdkYXRlJ10sIFxuICAgICAgICAgICAgICAgIG1vbnRoOiAgWydNJywgICAgJ21vbnRoJ10sIFxuICAgICAgICAgICAgICAgIHllYXI6ICAgWydZJywgICAgJ3llYXInXSwgXG4gICAgICAgICAgICAgICAgaG91cjogICBbJ1tIaF0nLCAnaG91cnMnXSxcbiAgICAgICAgICAgICAgICBtaW51dGU6IFsnbScsICAgICdtaW51dGVzJ10sIFxuICAgICAgICAgICAgICAgIHNlY29uZDogWydzJywgICAgJ3NlY29uZHMnXSxcbiAgICAgICAgICAgICAgICBhbXBtOiAgIFsnW0FhXScsICcnXSBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJHdpZGdldCA9ICQoJzxzcGFuIGNsYXNzPVwiY29tYm9kYXRlXCI+PC9zcGFuPicpLmh0bWwodGhpcy5nZXRUZW1wbGF0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuaW5pdENvbWJvcygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3VwZGF0ZSBvcmlnaW5hbCBpbnB1dCBvbiBjaGFuZ2UgXG4gICAgICAgICAgICB0aGlzLiR3aWRnZXQub24oJ2NoYW5nZScsICdzZWxlY3QnLCAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnZhbCh0aGlzLmdldFZhbHVlKCkpLmNoYW5nZSgpO1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBkYXlzIGNvdW50IGlmIG1vbnRoIG9yIHllYXIgY2hhbmdlc1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21hcnREYXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkKGUudGFyZ2V0KS5pcygnLm1vbnRoJykgfHwgJChlLnRhcmdldCkuaXMoJy55ZWFyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsbENvbWJvKCdkYXknKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kd2lkZ2V0LmZpbmQoJ3NlbGVjdCcpLmNzcygnd2lkdGgnLCAnYXV0bycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBoaWRlIG9yaWdpbmFsIGlucHV0IGFuZCBpbnNlcnQgd2lkZ2V0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LmhpZGUoKS5hZnRlcih0aGlzLiR3aWRnZXQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBzZXQgaW5pdGlhbCB2YWx1ZVxuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLiRlbGVtZW50LnZhbCgpIHx8IHRoaXMub3B0aW9ucy52YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICAgUmVwbGFjZSB0b2tlbnMgaW4gdGVtcGxhdGUgd2l0aCA8c2VsZWN0PiBlbGVtZW50cyBcbiAgICAgICAgKi8gICAgICAgICBcbiAgICAgICAgZ2V0VGVtcGxhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHRwbCA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZTtcblxuICAgICAgICAgICAgLy9maXJzdCBwYXNzXG4gICAgICAgICAgICAkLmVhY2godGhpcy5tYXAsIGZ1bmN0aW9uKGssIHYpIHtcbiAgICAgICAgICAgICAgICB2ID0gdlswXTsgXG4gICAgICAgICAgICAgICAgdmFyIHIgPSBuZXcgUmVnRXhwKHYrJysnKSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB2Lmxlbmd0aCA+IDEgPyB2LnN1YnN0cmluZygxLCAyKSA6IHY7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRwbCA9IHRwbC5yZXBsYWNlKHIsICd7Jyt0b2tlbisnfScpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vcmVwbGFjZSBzcGFjZXMgd2l0aCAmbmJzcDtcbiAgICAgICAgICAgIHRwbCA9IHRwbC5yZXBsYWNlKC8gL2csICcmbmJzcDsnKTtcblxuICAgICAgICAgICAgLy9zZWNvbmQgcGFzc1xuICAgICAgICAgICAgJC5lYWNoKHRoaXMubWFwLCBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgICAgICAgICAgdiA9IHZbMF07XG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gdi5sZW5ndGggPiAxID8gdi5zdWJzdHJpbmcoMSwgMikgOiB2O1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0cGwgPSB0cGwucmVwbGFjZSgneycrdG9rZW4rJ30nLCAnPHNlbGVjdCBjbGFzcz1cIicraysnXCI+PC9zZWxlY3Q+Jyk7XG4gICAgICAgICAgICB9KTsgICBcblxuICAgICAgICAgICAgcmV0dXJuIHRwbDtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgICBJbml0aWFsaXplIGNvbWJvcyB0aGF0IHByZXNlbnRzIGluIHRlbXBsYXRlIFxuICAgICAgICAqLyAgICAgICAgXG4gICAgICAgIGluaXRDb21ib3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiB0aGlzLm1hcCkge1xuICAgICAgICAgICAgICAgIHZhciAkYyA9IHRoaXMuJHdpZGdldC5maW5kKCcuJytrKTtcbiAgICAgICAgICAgICAgICAvLyBzZXQgcHJvcGVydGllcyBsaWtlIHRoaXMuJGRheSwgdGhpcy4kbW9udGggZXRjLlxuICAgICAgICAgICAgICAgIHRoaXNbJyQnK2tdID0gJGMubGVuZ3RoID8gJGMgOiBudWxsO1xuICAgICAgICAgICAgICAgIC8vIGZpbGwgd2l0aCBpdGVtc1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsbENvbWJvKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qXG4gICAgICAgICBGaWxsIGNvbWJvIHdpdGggaXRlbXMgXG4gICAgICAgICovICAgICAgICBcbiAgICAgICAgZmlsbENvbWJvOiBmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICB2YXIgJGNvbWJvID0gdGhpc1snJCcra107XG4gICAgICAgICAgICBpZiAoISRjb21ibykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGVmaW5lIG1ldGhvZCBuYW1lIHRvIGZpbGwgaXRlbXMsIGUuZyBgZmlsbERheXNgXG4gICAgICAgICAgICB2YXIgZiA9ICdmaWxsJyArIGsuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrLnNsaWNlKDEpOyBcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IHRoaXNbZl0oKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9ICRjb21iby52YWwoKTtcblxuICAgICAgICAgICAgJGNvbWJvLmVtcHR5KCk7XG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICRjb21iby5hcHBlbmQoJzxvcHRpb24gdmFsdWU9XCInK2l0ZW1zW2ldWzBdKydcIj4nK2l0ZW1zW2ldWzFdKyc8L29wdGlvbj4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJGNvbWJvLnZhbCh2YWx1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgIEluaXRpYWxpemUgaXRlbXMgb2YgY29tYm9zLiBIYW5kbGVzIGBmaXJzdEl0ZW1gIG9wdGlvbiBcbiAgICAgICAgKi9cbiAgICAgICAgZmlsbENvbW1vbjogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gW10sXG4gICAgICAgICAgICAgICAgcmVsVGltZTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5maXJzdEl0ZW0gPT09ICduYW1lJykge1xuICAgICAgICAgICAgICAgIC8vbmVlZCBib3RoIHRvIHN1cHBvcnQgbW9tZW50IHZlciA8IDIgYW5kICA+PSAyXG4gICAgICAgICAgICAgICAgcmVsVGltZSA9IG1vbWVudC5yZWxhdGl2ZVRpbWUgfHwgbW9tZW50LmxhbmdEYXRhKCkuX3JlbGF0aXZlVGltZTsgXG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlciA9IHR5cGVvZiByZWxUaW1lW2tleV0gPT09ICdmdW5jdGlvbicgPyByZWxUaW1lW2tleV0oMSwgdHJ1ZSwga2V5LCBmYWxzZSkgOiByZWxUaW1lW2tleV07XG4gICAgICAgICAgICAgICAgLy90YWtlIGxhc3QgZW50cnkgKHNlZSBtb21lbnRqcyBsYW5nIGZpbGVzIHN0cnVjdHVyZSkgXG4gICAgICAgICAgICAgICAgaGVhZGVyID0gaGVhZGVyLnNwbGl0KCcgJykucmV2ZXJzZSgpWzBdOyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChbJycsIGhlYWRlcl0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHRoaXMub3B0aW9ucy5maXJzdEl0ZW0gPT09ICdlbXB0eScpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChbJycsICcnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9LCAgXG5cblxuICAgICAgICAvKlxuICAgICAgICBmaWxsIGRheVxuICAgICAgICAqL1xuICAgICAgICBmaWxsRGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IHRoaXMuZmlsbENvbW1vbignZCcpLCBuYW1lLCBpLFxuICAgICAgICAgICAgICAgIHR3b0RpZ2l0ID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ0REJykgIT09IC0xLFxuICAgICAgICAgICAgICAgIGRheXNDb3VudCA9IDMxO1xuXG4gICAgICAgICAgICAvLyBkZXRlY3QgZGF5cyBjb3VudCAoZGVwZW5kcyBvbiBtb250aCBhbmQgeWVhcilcbiAgICAgICAgICAgIC8vIG9yaWdpbmFsbHkgaHR0cHM6Ly9naXRodWIuY29tL3ZpdGFsZXRzL2NvbWJvZGF0ZS9wdWxsLzdcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21hcnREYXlzICYmIHRoaXMuJG1vbnRoICYmIHRoaXMuJHllYXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9udGggPSBwYXJzZUludCh0aGlzLiRtb250aC52YWwoKSwgMTApO1xuICAgICAgICAgICAgICAgIHZhciB5ZWFyID0gcGFyc2VJbnQodGhpcy4keWVhci52YWwoKSwgMTApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihtb250aCkgJiYgIWlzTmFOKHllYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRheXNDb3VudCA9IG1vbWVudChbeWVhciwgbW9udGhdKS5kYXlzSW5Nb250aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBkYXlzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSB0d29EaWdpdCA/IHRoaXMubGVhZFplcm8oaSkgOiBpO1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goW2ksIG5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdGVtczsgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgZmlsbCBtb250aFxuICAgICAgICAqL1xuICAgICAgICBmaWxsTW9udGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5maWxsQ29tbW9uKCdNJyksIG5hbWUsIGksIFxuICAgICAgICAgICAgICAgIGxvbmdOYW1lcyA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5pbmRleE9mKCdNTU1NJykgIT09IC0xLFxuICAgICAgICAgICAgICAgIHNob3J0TmFtZXMgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUuaW5kZXhPZignTU1NJykgIT09IC0xLFxuICAgICAgICAgICAgICAgIHR3b0RpZ2l0ID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ01NJykgIT09IC0xO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yKGk9MDsgaTw9MTE7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmKGxvbmdOYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAvL3NlZSBodHRwczovL2dpdGh1Yi5jb20vdGltcndvb2QvbW9tZW50anMuY29tL3B1bGwvMzZcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG1vbWVudCgpLmRhdGUoMSkubW9udGgoaSkuZm9ybWF0KCdNTU1NJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKHNob3J0TmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG1vbWVudCgpLmRhdGUoMSkubW9udGgoaSkuZm9ybWF0KCdNTU0nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYodHdvRGlnaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHRoaXMubGVhZFplcm8oaSsxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gaSsxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKFtpLCBuYW1lXSk7XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICB9LCAgXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICBmaWxsIHllYXJcbiAgICAgICAgKi9cbiAgICAgICAgZmlsbFllYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gW10sIG5hbWUsIGksIFxuICAgICAgICAgICAgICAgIGxvbmdOYW1lcyA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5pbmRleE9mKCdZWVlZJykgIT09IC0xO1xuICAgICAgICAgICBcbiAgICAgICAgICAgIGZvcihpPXRoaXMub3B0aW9ucy5tYXhZZWFyOyBpPj10aGlzLm9wdGlvbnMubWluWWVhcjsgaS0tKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IGxvbmdOYW1lcyA/IGkgOiAoaSsnJykuc3Vic3RyaW5nKDIpO1xuICAgICAgICAgICAgICAgIGl0ZW1zW3RoaXMub3B0aW9ucy55ZWFyRGVzY2VuZGluZyA/ICdwdXNoJyA6ICd1bnNoaWZ0J10oW2ksIG5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaXRlbXMgPSB0aGlzLmZpbGxDb21tb24oJ3knKS5jb25jYXQoaXRlbXMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7ICAgICAgICAgICAgICBcbiAgICAgICAgfSwgICAgXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICBmaWxsIGhvdXJcbiAgICAgICAgKi9cbiAgICAgICAgZmlsbEhvdXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5maWxsQ29tbW9uKCdoJyksIG5hbWUsIGksXG4gICAgICAgICAgICAgICAgaDEyID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ2gnKSAhPT0gLTEsXG4gICAgICAgICAgICAgICAgaDI0ID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ0gnKSAhPT0gLTEsXG4gICAgICAgICAgICAgICAgdHdvRGlnaXQgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdoaCcpICE9PSAtMSxcbiAgICAgICAgICAgICAgICBtaW4gPSBoMTIgPyAxIDogMCwgXG4gICAgICAgICAgICAgICAgbWF4ID0gaDEyID8gMTIgOiAyMztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGZvcihpPW1pbjsgaTw9bWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gdHdvRGlnaXQgPyB0aGlzLmxlYWRaZXJvKGkpIDogaTtcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKFtpLCBuYW1lXSk7XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zOyAgICAgICAgICAgICAgICAgXG4gICAgICAgIH0sICAgIFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgZmlsbCBtaW51dGVcbiAgICAgICAgKi9cbiAgICAgICAgZmlsbE1pbnV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLmZpbGxDb21tb24oJ20nKSwgbmFtZSwgaSxcbiAgICAgICAgICAgICAgICB0d29EaWdpdCA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5pbmRleE9mKCdtbScpICE9PSAtMTtcblxuICAgICAgICAgICAgZm9yKGk9MDsgaTw9NTk7IGkrPSB0aGlzLm9wdGlvbnMubWludXRlU3RlcCkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSB0d29EaWdpdCA/IHRoaXMubGVhZFplcm8oaSkgOiBpO1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goW2ksIG5hbWVdKTtcbiAgICAgICAgICAgIH0gICAgXG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7ICAgICAgICAgICAgICBcbiAgICAgICAgfSwgIFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgZmlsbCBzZWNvbmRcbiAgICAgICAgKi9cbiAgICAgICAgZmlsbFNlY29uZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLmZpbGxDb21tb24oJ3MnKSwgbmFtZSwgaSxcbiAgICAgICAgICAgICAgICB0d29EaWdpdCA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5pbmRleE9mKCdzcycpICE9PSAtMTtcblxuICAgICAgICAgICAgZm9yKGk9MDsgaTw9NTk7IGkrPSB0aGlzLm9wdGlvbnMuc2Vjb25kU3RlcCkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSB0d29EaWdpdCA/IHRoaXMubGVhZFplcm8oaSkgOiBpO1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goW2ksIG5hbWVdKTtcbiAgICAgICAgICAgIH0gICAgXG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7ICAgICAgICAgICAgICBcbiAgICAgICAgfSwgIFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgZmlsbCBhbXBtXG4gICAgICAgICovXG4gICAgICAgIGZpbGxBbXBtOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhbXBtTCA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5pbmRleE9mKCdhJykgIT09IC0xLFxuICAgICAgICAgICAgICAgIGFtcG1VID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ0EnKSAhPT0gLTEsICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaXRlbXMgPSBbXG4gICAgICAgICAgICAgICAgICAgIFsnYW0nLCBhbXBtTCA/ICdhbScgOiAnQU0nXSxcbiAgICAgICAgICAgICAgICAgICAgWydwbScsIGFtcG1MID8gJ3BtJyA6ICdQTSddXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtczsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxuICAgICAgICAvKlxuICAgICAgICAgUmV0dXJucyBjdXJyZW50IGRhdGUgdmFsdWUgZnJvbSBjb21ib3MuIFxuICAgICAgICAgSWYgZm9ybWF0IG5vdCBzcGVjaWZpZWQgLSBgb3B0aW9ucy5mb3JtYXRgIHVzZWQuXG4gICAgICAgICBJZiBmb3JtYXQgPSBgbnVsbGAgLSBNb21lbnQgb2JqZWN0IHJldHVybmVkLlxuICAgICAgICAqL1xuICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgICAgICB2YXIgZHQsIHZhbHVlcyA9IHt9LCBcbiAgICAgICAgICAgICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBub3RTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9nZXR0aW5nIHNlbGVjdGVkIHZhbHVlcyAgICBcbiAgICAgICAgICAgICQuZWFjaCh0aGlzLm1hcCwgZnVuY3Rpb24oaywgdikge1xuICAgICAgICAgICAgICAgIGlmKGsgPT09ICdhbXBtJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkZWYgPSBrID09PSAnZGF5JyA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFsdWVzW2tdID0gdGhhdFsnJCcra10gPyBwYXJzZUludCh0aGF0WyckJytrXS52YWwoKSwgMTApIDogZGVmOyBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihpc05hTih2YWx1ZXNba10pKSB7XG4gICAgICAgICAgICAgICAgICAgbm90U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaWYgYXQgbGVhc3Qgb25lIHZpc2libGUgY29tYm8gbm90IHNlbGVjdGVkIC0gcmV0dXJuIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgaWYobm90U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9jb252ZXJ0IGhvdXJzIDEyaCAtLT4gMjRoIFxuICAgICAgICAgICAgaWYodGhpcy4kYW1wbSkge1xuICAgICAgICAgICAgICAgIC8vMTI6MDAgcG0gLS0+IDEyOjAwICgyNC1oIGZvcm1hdCwgbWlkZGF5KSwgMTI6MDAgYW0gLS0+IDAwOjAwICgyNC1oIGZvcm1hdCwgbWlkbmlnaHQsIHN0YXJ0IG9mIGRheSlcbiAgICAgICAgICAgICAgICBpZih2YWx1ZXMuaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmhvdXIgPSB0aGlzLiRhbXBtLnZhbCgpID09PSAnYW0nID8gMCA6IDEyOyAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmhvdXIgPSB0aGlzLiRhbXBtLnZhbCgpID09PSAnYW0nID8gdmFsdWVzLmhvdXIgOiB2YWx1ZXMuaG91cisxMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBkdCA9IG1vbWVudChbdmFsdWVzLnllYXIsIHZhbHVlcy5tb250aCwgdmFsdWVzLmRheSwgdmFsdWVzLmhvdXIsIHZhbHVlcy5taW51dGUsIHZhbHVlcy5zZWNvbmRdKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9oaWdobGlnaHQgaW52YWxpZCBkYXRlXG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodChkdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLmZvcm1hdCA6IGZvcm1hdDtcbiAgICAgICAgICAgIGlmKGZvcm1hdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgcmV0dXJuIGR0LmlzVmFsaWQoKSA/IGR0IDogbnVsbDsgXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgcmV0dXJuIGR0LmlzVmFsaWQoKSA/IGR0LmZvcm1hdChmb3JtYXQpIDogJyc7IFxuICAgICAgICAgICAgfSAgICAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGR0ID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IG1vbWVudCh2YWx1ZSwgdGhpcy5vcHRpb25zLmZvcm1hdCkgOiBtb21lbnQodmFsdWUpLFxuICAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2Z1bmN0aW9uIHRvIGZpbmQgbmVhcmVzdCB2YWx1ZSBpbiBzZWxlY3Qgb3B0aW9uc1xuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0TmVhcmVzdCgkc2VsZWN0LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IHt9O1xuICAgICAgICAgICAgICAgICRzZWxlY3QuY2hpbGRyZW4oJ29wdGlvbicpLmVhY2goZnVuY3Rpb24oaSwgb3B0KXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdFZhbHVlID0gJChvcHQpLmF0dHIoJ3ZhbHVlJyksXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKG9wdFZhbHVlID09PSAnJykgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKG9wdFZhbHVlIC0gdmFsdWUpOyBcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGRlbHRhLmRpc3RhbmNlID09PSAndW5kZWZpbmVkJyB8fCBkaXN0YW5jZSA8IGRlbHRhLmRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IHt2YWx1ZTogb3B0VmFsdWUsIGRpc3RhbmNlOiBkaXN0YW5jZX07XG4gICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgfSk7IFxuICAgICAgICAgICAgICAgIHJldHVybiBkZWx0YS52YWx1ZTtcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGR0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIC8vcmVhZCB2YWx1ZXMgZnJvbSBkYXRlIG9iamVjdFxuICAgICAgICAgICAgICAgICQuZWFjaCh0aGlzLm1hcCwgZnVuY3Rpb24oaywgdikge1xuICAgICAgICAgICAgICAgICAgICBpZihrID09PSAnYW1wbScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNba10gPSBkdFt2WzFdXSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYodGhpcy4kYW1wbSkge1xuICAgICAgICAgICAgICAgICAgICAvLzEyOjAwIHBtIC0tPiAxMjowMCAoMjQtaCBmb3JtYXQsIG1pZGRheSksIDEyOjAwIGFtIC0tPiAwMDowMCAoMjQtaCBmb3JtYXQsIG1pZG5pZ2h0LCBzdGFydCBvZiBkYXkpXG4gICAgICAgICAgICAgICAgICAgIGlmKHZhbHVlcy5ob3VyID49IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuYW1wbSA9ICdwbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih2YWx1ZXMuaG91ciA+IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmhvdXIgLT0gMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuYW1wbSA9ICdhbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih2YWx1ZXMuaG91ciA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5ob3VyID0gMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgJC5lYWNoKHZhbHVlcywgZnVuY3Rpb24oaywgdikge1xuICAgICAgICAgICAgICAgICAgICAvL2NhbGwgdmFsKCkgZm9yIGVhY2ggZXhpc3RpbmcgY29tYm8sIGUuZy4gdGhpcy4kaG91ci52YWwoKVxuICAgICAgICAgICAgICAgICAgICBpZih0aGF0WyckJytrXSkge1xuICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGsgPT09ICdtaW51dGUnICYmIHRoYXQub3B0aW9ucy5taW51dGVTdGVwID4gMSAmJiB0aGF0Lm9wdGlvbnMucm91bmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gZ2V0TmVhcmVzdCh0aGF0WyckJytrXSwgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoayA9PT0gJ3NlY29uZCcgJiYgdGhhdC5vcHRpb25zLnNlY29uZFN0ZXAgPiAxICYmIHRoYXQub3B0aW9ucy5yb3VuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBnZXROZWFyZXN0KHRoYXRbJyQnK2tdLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXRbJyQnK2tdLnZhbCh2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGRheXMgY291bnRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNtYXJ0RGF5cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGxDb21ibygnZGF5Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnZhbChkdC5mb3JtYXQodGhpcy5vcHRpb25zLmZvcm1hdCkpLmNoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgIGhpZ2hsaWdodCBjb21ib3MgaWYgZGF0ZSBpcyBpbnZhbGlkXG4gICAgICAgICovXG4gICAgICAgIGhpZ2hsaWdodDogZnVuY3Rpb24oZHQpIHtcbiAgICAgICAgICAgIGlmKCFkdC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZXJyb3JDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiR3aWRnZXQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmVycm9yQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vc3RvcmUgb3JpZ2luYWwgYm9yZGVyIGNvbG9yXG4gICAgICAgICAgICAgICAgICAgIGlmKCF0aGlzLmJvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJvcmRlckNvbG9yID0gdGhpcy4kd2lkZ2V0LmZpbmQoJ3NlbGVjdCcpLmNzcygnYm9yZGVyLWNvbG9yJyk7IFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHdpZGdldC5maW5kKCdzZWxlY3QnKS5jc3MoJ2JvcmRlci1jb2xvcicsICdyZWQnKTtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZXJyb3JDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiR3aWRnZXQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmVycm9yQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHdpZGdldC5maW5kKCdzZWxlY3QnKS5jc3MoJ2JvcmRlci1jb2xvcicsIHRoaXMuYm9yZGVyQ29sb3IpO1xuICAgICAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgbGVhZFplcm86IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2IDw9IDkgPyAnMCcgKyB2IDogdjsgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuJHdpZGdldC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlRGF0YSgnY29tYm9kYXRlJykuc2hvdygpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvL3RvZG86IGNsZWFyIG1ldGhvZCAgICAgICAgXG4gICAgfTtcblxuICAgICQuZm4uY29tYm9kYXRlID0gZnVuY3Rpb24gKCBvcHRpb24gKSB7XG4gICAgICAgIHZhciBkLCBhcmdzID0gQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgYXJncy5zaGlmdCgpO1xuXG4gICAgICAgIC8vZ2V0VmFsdWUgcmV0dXJucyBkYXRlIGFzIHN0cmluZyAvIG9iamVjdCAobm90IGpRdWVyeSBvYmplY3QpXG4gICAgICAgIGlmKG9wdGlvbiA9PT0gJ2dldFZhbHVlJyAmJiB0aGlzLmxlbmd0aCAmJiAoZCA9IHRoaXMuZXEoMCkuZGF0YSgnY29tYm9kYXRlJykpKSB7XG4gICAgICAgICAgcmV0dXJuIGQuZ2V0VmFsdWUuYXBwbHkoZCwgYXJncyk7XG4gICAgICAgIH0gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxuICAgICAgICAgICAgZGF0YSA9ICR0aGlzLmRhdGEoJ2NvbWJvZGF0ZScpLFxuICAgICAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uO1xuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuZGF0YSgnY29tYm9kYXRlJywgKGRhdGEgPSBuZXcgQ29tYm9kYXRlKHRoaXMsIG9wdGlvbnMpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgZGF0YVtvcHRpb25dID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBkYXRhW29wdGlvbl0uYXBwbHkoZGF0YSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07ICBcbiAgICBcbiAgICAkLmZuLmNvbWJvZGF0ZS5kZWZhdWx0cyA9IHtcbiAgICAgICAgIC8vaW4gdGhpcyBmb3JtYXQgdmFsdWUgc3RvcmVkIGluIG9yaWdpbmFsIGlucHV0XG4gICAgICAgIGZvcm1hdDogJ0RELU1NLVlZWVkgSEg6bW0nLCAgICAgIFxuICAgICAgICAvL2luIHRoaXMgZm9ybWF0IGl0ZW1zIGluIGRyb3Bkb3ducyBhcmUgZGlzcGxheWVkXG4gICAgICAgIHRlbXBsYXRlOiAnRCAvIE1NTSAvIFlZWVkgICBIIDogbW0nLFxuICAgICAgICAvL2luaXRpYWwgdmFsdWUsIGNhbiBiZSBgbmV3IERhdGUoKWAgICAgXG4gICAgICAgIHZhbHVlOiBudWxsLCAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIG1pblllYXI6IDE5NzAsXG4gICAgICAgIG1heFllYXI6IDIwMTUsXG4gICAgICAgIHllYXJEZXNjZW5kaW5nOiB0cnVlLFxuICAgICAgICBtaW51dGVTdGVwOiA1LFxuICAgICAgICBzZWNvbmRTdGVwOiAxLFxuICAgICAgICBmaXJzdEl0ZW06ICdlbXB0eScsIC8vJ25hbWUnLCAnZW1wdHknLCAnbm9uZSdcbiAgICAgICAgZXJyb3JDbGFzczogbnVsbCxcbiAgICAgICAgcm91bmRUaW1lOiB0cnVlLCAvLyB3aGV0aGVyIHRvIHJvdW5kIG1pbnV0ZXMgYW5kIHNlY29uZHMgaWYgc3RlcCA+IDFcbiAgICAgICAgc21hcnREYXlzOiBmYWxzZSAvLyB3aGV0aGVyIGRheXMgaW4gY29tYm8gZGVwZW5kIG9uIHNlbGVjdGVkIG1vbnRoOiAzMSwgMzAsIDI4XG4gICAgfTtcblxufSh3aW5kb3cualF1ZXJ5KSk7XG4vKipcbkNvbWJvZGF0ZSBpbnB1dCAtIGRyb3Bkb3duIGRhdGUgYW5kIHRpbWUgcGlja2VyLiAgICBcbkJhc2VkIG9uIFtjb21ib2RhdGVdKGh0dHA6Ly92aXRhbGV0cy5naXRodWIuY29tL2NvbWJvZGF0ZSkgcGx1Z2luIChpbmNsdWRlZCkuIFRvIHVzZSBpdCB5b3Ugc2hvdWxkIG1hbnVhbGx5IGluY2x1ZGUgW21vbWVudGpzXShodHRwOi8vbW9tZW50anMuY29tKS5cblxuICAgIDxzY3JpcHQgc3JjPVwianMvbW9tZW50Lm1pbi5qc1wiPjwvc2NyaXB0PlxuICAgXG5BbGxvd3MgdG8gaW5wdXQ6XG5cbiogb25seSBkYXRlXG4qIG9ubHkgdGltZSBcbiogYm90aCBkYXRlIGFuZCB0aW1lICBcblxuUGxlYXNlIG5vdGUsIHRoYXQgZm9ybWF0IGlzIHRha2VuIGZyb20gbW9tZW50anMgYW5kICoqbm90IGNvbXBhdGlibGUqKiB3aXRoIGJvb3RzdHJhcC1kYXRlcGlja2VyIC8ganF1ZXJ5IFVJIGRhdGVwaWNrZXIuICBcbkludGVybmFsbHkgdmFsdWUgc3RvcmVkIGFzIGBtb21lbnRqc2Agb2JqZWN0LiBcblxuQGNsYXNzIGNvbWJvZGF0ZVxuQGV4dGVuZHMgYWJzdHJhY3RpbnB1dFxuQGZpbmFsXG5Ac2luY2UgMS40LjBcbkBleGFtcGxlXG48YSBocmVmPVwiI1wiIGlkPVwiZG9iXCIgZGF0YS10eXBlPVwiY29tYm9kYXRlXCIgZGF0YS1waz1cIjFcIiBkYXRhLXVybD1cIi9wb3N0XCIgZGF0YS12YWx1ZT1cIjE5ODQtMDUtMTVcIiBkYXRhLXRpdGxlPVwiU2VsZWN0IGRhdGVcIj48L2E+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgICQoJyNkb2InKS5lZGl0YWJsZSh7XG4gICAgICAgIGZvcm1hdDogJ1lZWVktTU0tREQnLCAgICBcbiAgICAgICAgdmlld2Zvcm1hdDogJ0RELk1NLllZWVknLCAgICBcbiAgICAgICAgdGVtcGxhdGU6ICdEIC8gTU1NTSAvIFlZWVknLCAgICBcbiAgICAgICAgY29tYm9kYXRlOiB7XG4gICAgICAgICAgICAgICAgbWluWWVhcjogMjAwMCxcbiAgICAgICAgICAgICAgICBtYXhZZWFyOiAyMDE1LFxuICAgICAgICAgICAgICAgIG1pbnV0ZVN0ZXA6IDFcbiAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59KTtcbjwvc2NyaXB0PlxuKiovXG5cbi8qZ2xvYmFsIG1vbWVudCovXG5cbihmdW5jdGlvbiAoJCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIFxuICAgIHZhciBDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdCgnY29tYm9kYXRlJywgb3B0aW9ucywgQ29uc3RydWN0b3IuZGVmYXVsdHMpO1xuICAgICAgICBcbiAgICAgICAgLy9ieSBkZWZhdWx0IHZpZXdmb3JtYXQgZXF1YWxzIHRvIGZvcm1hdFxuICAgICAgICBpZighdGhpcy5vcHRpb25zLnZpZXdmb3JtYXQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy52aWV3Zm9ybWF0ID0gdGhpcy5vcHRpb25zLmZvcm1hdDtcbiAgICAgICAgfSAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAvL3RyeSBwYXJzZSBjb21ib2RhdGUgY29uZmlnIGRlZmluZWQgYXMganNvbiBzdHJpbmcgaW4gZGF0YS1jb21ib2RhdGVcbiAgICAgICAgb3B0aW9ucy5jb21ib2RhdGUgPSAkLmZuLmVkaXRhYmxldXRpbHMudHJ5UGFyc2VKc29uKG9wdGlvbnMuY29tYm9kYXRlLCB0cnVlKTtcblxuICAgICAgICAvL292ZXJyaWRpbmcgY29tYm9kYXRlIGNvbmZpZyAoYXMgYnkgZGVmYXVsdCBqUXVlcnkgZXh0ZW5kKCkgaXMgbm90IHJlY3Vyc2l2ZSlcbiAgICAgICAgdGhpcy5vcHRpb25zLmNvbWJvZGF0ZSA9ICQuZXh0ZW5kKHt9LCBDb25zdHJ1Y3Rvci5kZWZhdWx0cy5jb21ib2RhdGUsIG9wdGlvbnMuY29tYm9kYXRlLCB7XG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMub3B0aW9ucy5mb3JtYXQsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogdGhpcy5vcHRpb25zLnRlbXBsYXRlXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChDb25zdHJ1Y3RvciwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQpOyAgICBcbiAgICBcbiAgICAkLmV4dGVuZChDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5jb21ib2RhdGUodGhpcy5vcHRpb25zLmNvbWJvZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoJC5mbi5lZGl0YWJsZWZvcm0uZW5naW5lID09PSAnYnMzJykge1xuICAgICAgICAgICAgICAgIHRoaXMuJGlucHV0LnNpYmxpbmdzKCkuZmluZCgnc2VsZWN0JykuYWRkQ2xhc3MoJ2Zvcm0tY29udHJvbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuaW5wdXRjbGFzcykge1xuICAgICAgICAgICAgICAgIHRoaXMuJGlucHV0LnNpYmxpbmdzKCkuZmluZCgnc2VsZWN0JykuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmlucHV0Y2xhc3MpO1xuICAgICAgICAgICAgfSAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9cImNsZWFyXCIgbGlua1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5jbGVhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuJGNsZWFyID0gJCgnPGEgaHJlZj1cIiNcIj48L2E+JykuaHRtbCh0aGlzLm9wdGlvbnMuY2xlYXIpLmNsaWNrKCQucHJveHkoZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLiR0cGwucGFyZW50KCkuYXBwZW5kKCQoJzxkaXYgY2xhc3M9XCJlZGl0YWJsZS1jbGVhclwiPicpLmFwcGVuZCh0aGlzLiRjbGVhcikpOyAgXG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgKi8gICAgICAgICAgICAgICBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHZhbHVlMmh0bWw6IGZ1bmN0aW9uKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHZhbHVlID8gdmFsdWUuZm9ybWF0KHRoaXMub3B0aW9ucy52aWV3Zm9ybWF0KSA6ICcnO1xuICAgICAgICAgICAgLy8kKGVsZW1lbnQpLnRleHQodGV4dCk7XG4gICAgICAgICAgICBDb25zdHJ1Y3Rvci5zdXBlcmNsYXNzLnZhbHVlMmh0bWwuY2FsbCh0aGlzLCB0ZXh0LCBlbGVtZW50KTsgIFxuICAgICAgICB9LFxuXG4gICAgICAgIGh0bWwydmFsdWU6IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sID8gbW9tZW50KGh0bWwsIHRoaXMub3B0aW9ucy52aWV3Zm9ybWF0KSA6IG51bGw7XG4gICAgICAgIH0sICAgXG4gICAgICAgIFxuICAgICAgICB2YWx1ZTJzdHI6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZS5mb3JtYXQodGhpcy5vcHRpb25zLmZvcm1hdCkgOiAnJztcbiAgICAgICB9LCBcbiAgICAgICBcbiAgICAgICBzdHIydmFsdWU6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICByZXR1cm4gc3RyID8gbW9tZW50KHN0ciwgdGhpcy5vcHRpb25zLmZvcm1hdCkgOiBudWxsO1xuICAgICAgIH0sIFxuICAgICAgIFxuICAgICAgIHZhbHVlMnN1Ym1pdDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUyc3RyKHZhbHVlKTtcbiAgICAgICB9LCAgICAgICAgICAgICAgICAgICAgXG5cbiAgICAgICB2YWx1ZTJpbnB1dDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgdGhpcy4kaW5wdXQuY29tYm9kYXRlKCdzZXRWYWx1ZScsIHZhbHVlKTtcbiAgICAgICB9LFxuICAgICAgICBcbiAgICAgICBpbnB1dDJ2YWx1ZTogZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICByZXR1cm4gdGhpcy4kaW5wdXQuY29tYm9kYXRlKCdnZXRWYWx1ZScsIG51bGwpO1xuICAgICAgIH0sICAgICAgIFxuICAgICAgIFxuICAgICAgIGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgdGhpcy4kaW5wdXQuc2libGluZ3MoJy5jb21ib2RhdGUnKS5maW5kKCdzZWxlY3QnKS5lcSgwKS5mb2N1cygpO1xuICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgLypcbiAgICAgICBjbGVhcjogIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuJGlucHV0LmRhdGEoJ2RhdGVwaWNrZXInKS5kYXRlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLiRpbnB1dC5maW5kKCcuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgIH0sXG4gICAgICAgKi9cbiAgICAgICBcbiAgICAgICBhdXRvc3VibWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgXG4gICAgICAgfVxuXG4gICAgfSk7XG4gICAgXG4gICAgQ29uc3RydWN0b3IuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQuZGVmYXVsdHMsIHtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSB0cGwgXG4gICAgICAgIEBkZWZhdWx0IDxpbnB1dCB0eXBlPVwidGV4dFwiPlxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgdHBsOic8aW5wdXQgdHlwZT1cInRleHRcIj4nLFxuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IGlucHV0Y2xhc3MgXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGlucHV0Y2xhc3M6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBGb3JtYXQgdXNlZCBmb3Igc2VuZGluZyB2YWx1ZSB0byBzZXJ2ZXIuIEFsc28gYXBwbGllZCB3aGVuIGNvbnZlcnRpbmcgZGF0ZSBmcm9tIDxjb2RlPmRhdGEtdmFsdWU8L2NvZGU+IGF0dHJpYnV0ZS48YnI+XG4gICAgICAgIFNlZSBsaXN0IG9mIHRva2VucyBpbiBbbW9tZW50anMgZG9jc10oaHR0cDovL21vbWVudGpzLmNvbS9kb2NzLyMvcGFyc2luZy9zdHJpbmctZm9ybWF0KSAgXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgZm9ybWF0IFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgWVlZWS1NTS1ERFxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgZm9ybWF0OidZWVlZLU1NLUREJyxcbiAgICAgICAgLyoqXG4gICAgICAgIEZvcm1hdCB1c2VkIGZvciBkaXNwbGF5aW5nIGRhdGUuIEFsc28gYXBwbGllZCB3aGVuIGNvbnZlcnRpbmcgZGF0ZSBmcm9tIGVsZW1lbnQncyB0ZXh0IG9uIGluaXQuICAgXG4gICAgICAgIElmIG5vdCBzcGVjaWZpZWQgZXF1YWxzIHRvIGBmb3JtYXRgLlxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IHZpZXdmb3JtYXQgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgdmlld2Zvcm1hdDogbnVsbCwgICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgVGVtcGxhdGUgdXNlZCBmb3IgZGlzcGxheWluZyBkcm9wZG93bnMuXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgdGVtcGxhdGUgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCBEIC8gTU1NIC8gWVlZWVxuICAgICAgICAqKi8gICAgICAgICAgXG4gICAgICAgIHRlbXBsYXRlOiAnRCAvIE1NTSAvIFlZWVknLCAgXG4gICAgICAgIC8qKlxuICAgICAgICBDb25maWd1cmF0aW9uIG9mIGNvbWJvZGF0ZS5cbiAgICAgICAgRnVsbCBsaXN0IG9mIG9wdGlvbnM6IGh0dHA6Ly92aXRhbGV0cy5naXRodWIuY29tL2NvbWJvZGF0ZS8jZG9jc1xuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IGNvbWJvZGF0ZSBcbiAgICAgICAgQHR5cGUgb2JqZWN0XG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovXG4gICAgICAgIGNvbWJvZGF0ZTogbnVsbFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgKG5vdCBpbXBsZW1lbnRlZCB5ZXQpXG4gICAgICAgIFRleHQgc2hvd24gYXMgY2xlYXIgZGF0ZSBidXR0b24uIFxuICAgICAgICBJZiA8Y29kZT5mYWxzZTwvY29kZT4gY2xlYXIgYnV0dG9uIHdpbGwgbm90IGJlIHJlbmRlcmVkLlxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IGNsZWFyIFxuICAgICAgICBAdHlwZSBib29sZWFufHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCAneCBjbGVhcicgICAgICAgICBcbiAgICAgICAgKi9cbiAgICAgICAgLy9jbGVhcjogJyZ0aW1lczsgY2xlYXInXG4gICAgfSk7ICAgXG5cbiAgICAkLmZuLmVkaXRhYmxldHlwZXMuY29tYm9kYXRlID0gQ29uc3RydWN0b3I7XG5cbn0od2luZG93LmpRdWVyeSkpO1xuXG4vKlxuRWRpdGFibGVmb3JtIGJhc2VkIG9uIFR3aXR0ZXIgQm9vdHN0cmFwIDNcbiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBcbiAgICAvL3N0b3JlIHBhcmVudCBtZXRob2RzXG4gICAgdmFyIHBJbml0SW5wdXQgPSAkLmZuLmVkaXRhYmxlZm9ybS5Db25zdHJ1Y3Rvci5wcm90b3R5cGUuaW5pdElucHV0O1xuICAgIFxuICAgICQuZXh0ZW5kKCQuZm4uZWRpdGFibGVmb3JtLkNvbnN0cnVjdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBpbml0VGVtcGxhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kZm9ybSA9ICQoJC5mbi5lZGl0YWJsZWZvcm0udGVtcGxhdGUpOyBcbiAgICAgICAgICAgIHRoaXMuJGZvcm0uZmluZCgnLmNvbnRyb2wtZ3JvdXAnKS5hZGRDbGFzcygnZm9ybS1ncm91cCcpO1xuICAgICAgICAgICAgdGhpcy4kZm9ybS5maW5kKCcuZWRpdGFibGUtZXJyb3ItYmxvY2snKS5hZGRDbGFzcygnaGVscC1ibG9jaycpO1xuICAgICAgICB9LFxuICAgICAgICBpbml0SW5wdXQ6IGZ1bmN0aW9uKCkgeyAgXG4gICAgICAgICAgICBwSW5pdElucHV0LmFwcGx5KHRoaXMpO1xuXG4gICAgICAgICAgICAvL2ZvciBiczMgc2V0IGRlZmF1bHQgY2xhc3MgYGlucHV0LXNtYCB0byBzdGFuZGFyZCBpbnB1dHNcbiAgICAgICAgICAgIHZhciBlbXB0eUlucHV0Q2xhc3MgPSB0aGlzLmlucHV0Lm9wdGlvbnMuaW5wdXRjbGFzcyA9PT0gbnVsbCB8fCB0aGlzLmlucHV0Lm9wdGlvbnMuaW5wdXRjbGFzcyA9PT0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdENsYXNzID0gJ2lucHV0LXNtJztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9iczMgYWRkIGBmb3JtLWNvbnRyb2xgIGNsYXNzIHRvIHN0YW5kYXJkIGlucHV0c1xuICAgICAgICAgICAgdmFyIHN0ZHR5cGVzID0gJ3RleHQsc2VsZWN0LHRleHRhcmVhLHBhc3N3b3JkLGVtYWlsLHVybCx0ZWwsbnVtYmVyLHJhbmdlLHRpbWUsdHlwZWFoZWFkanMnLnNwbGl0KCcsJyk7IFxuICAgICAgICAgICAgaWYofiQuaW5BcnJheSh0aGlzLmlucHV0LnR5cGUsIHN0ZHR5cGVzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuJGlucHV0LmFkZENsYXNzKCdmb3JtLWNvbnRyb2wnKTtcbiAgICAgICAgICAgICAgICBpZihlbXB0eUlucHV0Q2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5vcHRpb25zLmlucHV0Y2xhc3MgPSBkZWZhdWx0Q2xhc3M7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuJGlucHV0LmFkZENsYXNzKGRlZmF1bHRDbGFzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAgICAgICAgICAgICBcbiAgICAgICAgXG4gICAgICAgICAgICAvL2FwcGx5IGJzMyBzaXplIGNsYXNzIGFsc28gdG8gYnV0dG9ucyAodG8gZml0IHNpemUgb2YgY29udHJvbClcbiAgICAgICAgICAgIHZhciAkYnRuID0gdGhpcy4kZm9ybS5maW5kKCcuZWRpdGFibGUtYnV0dG9ucycpO1xuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBlbXB0eUlucHV0Q2xhc3MgPyBbZGVmYXVsdENsYXNzXSA6IHRoaXMuaW5wdXQub3B0aW9ucy5pbnB1dGNsYXNzLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxjbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gYGJ0bi1zbWAgaXMgZGVmYXVsdCBub3dcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIGlmKGNsYXNzZXNbaV0udG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0LXNtJykgeyBcbiAgICAgICAgICAgICAgICAgICAgJGJ0bi5maW5kKCdidXR0b24nKS5hZGRDbGFzcygnYnRuLXNtJyk7ICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZihjbGFzc2VzW2ldLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dC1sZycpIHtcbiAgICAgICAgICAgICAgICAgICAgJGJ0bi5maW5kKCdidXR0b24nKS5yZW1vdmVDbGFzcygnYnRuLXNtJykuYWRkQ2xhc3MoJ2J0bi1sZycpOyBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTsgICAgXG4gICAgXG4gICAgLy9idXR0b25zXG4gICAgJC5mbi5lZGl0YWJsZWZvcm0uYnV0dG9ucyA9IFxuICAgICAgJzxidXR0b24gdHlwZT1cInN1Ym1pdFwiIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5IGJ0bi1zbSBlZGl0YWJsZS1zdWJtaXRcIj4nK1xuICAgICAgICAnPGkgY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLW9rXCI+PC9pPicrXG4gICAgICAnPC9idXR0b24+JytcbiAgICAgICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdCBidG4tc20gZWRpdGFibGUtY2FuY2VsXCI+JytcbiAgICAgICAgJzxpIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1yZW1vdmVcIj48L2k+JytcbiAgICAgICc8L2J1dHRvbj4nOyAgICAgICAgIFxuICAgIFxuICAgIC8vZXJyb3IgY2xhc3Nlc1xuICAgICQuZm4uZWRpdGFibGVmb3JtLmVycm9yR3JvdXBDbGFzcyA9ICdoYXMtZXJyb3InO1xuICAgICQuZm4uZWRpdGFibGVmb3JtLmVycm9yQmxvY2tDbGFzcyA9IG51bGw7ICBcbiAgICAvL2VuZ2luZVxuICAgICQuZm4uZWRpdGFibGVmb3JtLmVuZ2luZSA9ICdiczMnOyAgXG59KHdpbmRvdy5qUXVlcnkpKTtcbi8qKlxuKiBFZGl0YWJsZSBQb3BvdmVyMyAoZm9yIEJvb3RzdHJhcCAzKSBcbiogLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIHJlcXVpcmVzIGJvb3RzdHJhcC1wb3BvdmVyLmpzXG4qL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvL2V4dGVuZCBtZXRob2RzXG4gICAgJC5leHRlbmQoJC5mbi5lZGl0YWJsZUNvbnRhaW5lci5Qb3B1cC5wcm90b3R5cGUsIHtcbiAgICAgICAgY29udGFpbmVyTmFtZTogJ3BvcG92ZXInLFxuICAgICAgICBjb250YWluZXJEYXRhTmFtZTogJ2JzLnBvcG92ZXInLFxuICAgICAgICBpbm5lckNzczogJy5wb3BvdmVyLWNvbnRlbnQnLFxuICAgICAgICBkZWZhdWx0czogJC5mbi5wb3BvdmVyLkNvbnN0cnVjdG9yLkRFRkFVTFRTLFxuXG4gICAgICAgIGluaXRDb250YWluZXI6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAkLmV4dGVuZCh0aGlzLmNvbnRhaW5lck9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyOiAnbWFudWFsJyxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29udGVudDogJyAnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiB0aGlzLmRlZmF1bHRzLnRlbXBsYXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9hcyB0ZW1wbGF0ZSBwcm9wZXJ0eSBpcyB1c2VkIGluIGlucHV0cywgaGlkZSBpdCBmcm9tIHBvcG92ZXJcbiAgICAgICAgICAgIHZhciB0O1xuICAgICAgICAgICAgaWYodGhpcy4kZWxlbWVudC5kYXRhKCd0ZW1wbGF0ZScpKSB7XG4gICAgICAgICAgICAgICB0ID0gdGhpcy4kZWxlbWVudC5kYXRhKCd0ZW1wbGF0ZScpO1xuICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVEYXRhKCd0ZW1wbGF0ZScpOyAgXG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmNhbGwodGhpcy5jb250YWluZXJPcHRpb25zKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYodCkge1xuICAgICAgICAgICAgICAgLy9yZXN0b3JlIGRhdGEoJ3RlbXBsYXRlJylcbiAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQuZGF0YSgndGVtcGxhdGUnLCB0KTsgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFxuICAgICAgICBcbiAgICAgICAgLyogc2hvdyAqL1xuICAgICAgICBpbm5lclNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbCgnc2hvdycpOyAgICAgICAgICAgICAgICBcbiAgICAgICAgfSwgIFxuICAgICAgICBcbiAgICAgICAgLyogaGlkZSAqL1xuICAgICAgICBpbm5lckhpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbCgnaGlkZScpOyAgICAgICBcbiAgICAgICAgfSwgXG4gICAgICAgIFxuICAgICAgICAvKiBkZXN0cm95ICovXG4gICAgICAgIGlubmVyRGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGwoJ2Rlc3Ryb3knKTtcbiAgICAgICAgfSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBzZXRDb250YWluZXJPcHRpb246IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyKCkub3B0aW9uc1trZXldID0gdmFsdWU7IFxuICAgICAgICB9LCAgICAgICAgICAgICAgIFxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIG1vdmUgcG9wb3ZlciB0byBuZXcgcG9zaXRpb24uIFRoaXMgZnVuY3Rpb24gbWFpbmx5IGNvcGllZCBmcm9tIGJvb3RzdHJhcC1wb3BvdmVyLlxuICAgICAgICAqL1xuICAgICAgICAvKmpzaGludCBsYXhjb21tYTogdHJ1ZSwgZXFlcWVxOiBmYWxzZSovXG4gICAgICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7IFxuXG4gICAgICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvKiAgICBcbiAgICAgICAgICAgICAgICB2YXIgJHRpcCA9IHRoaXMudGlwKClcbiAgICAgICAgICAgICAgICAsIGluc2lkZVxuICAgICAgICAgICAgICAgICwgcG9zXG4gICAgICAgICAgICAgICAgLCBhY3R1YWxXaWR0aFxuICAgICAgICAgICAgICAgICwgYWN0dWFsSGVpZ2h0XG4gICAgICAgICAgICAgICAgLCBwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAsIHRwXG4gICAgICAgICAgICAgICAgLCB0cHRcbiAgICAgICAgICAgICAgICAsIHRwYlxuICAgICAgICAgICAgICAgICwgdHBsXG4gICAgICAgICAgICAgICAgLCB0cHI7XG5cbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSB0eXBlb2YgdGhpcy5vcHRpb25zLnBsYWNlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnBsYWNlbWVudC5jYWxsKHRoaXMsICR0aXBbMF0sIHRoaXMuJGVsZW1lbnRbMF0pIDpcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucGxhY2VtZW50O1xuXG4gICAgICAgICAgICAgICAgaW5zaWRlID0gL2luLy50ZXN0KHBsYWNlbWVudCk7XG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAkdGlwXG4gICAgICAgICAgICAgIC8vICAuZGV0YWNoKClcbiAgICAgICAgICAgICAgLy92aXRhbGV0czogcmVtb3ZlIGFueSBwbGFjZW1lbnQgY2xhc3MgYmVjYXVzZSBvdGhlcndpc2UgdGhleSBkb250IGluZmx1ZW5jZSBvbiByZS1wb3NpdGlvbmluZyBvZiB2aXNpYmxlIHBvcG92ZXJcbiAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ3RvcCByaWdodCBib3R0b20gbGVmdCcpXG4gICAgICAgICAgICAgICAgLmNzcyh7IHRvcDogMCwgbGVmdDogMCwgZGlzcGxheTogJ2Jsb2NrJyB9KTtcbiAgICAgICAgICAgICAgLy8gIC5pbnNlcnRBZnRlcih0aGlzLiRlbGVtZW50KTtcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHBvcyA9IHRoaXMuZ2V0UG9zaXRpb24oaW5zaWRlKTtcblxuICAgICAgICAgICAgICAgIGFjdHVhbFdpZHRoID0gJHRpcFswXS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICBhY3R1YWxIZWlnaHQgPSAkdGlwWzBdLm9mZnNldEhlaWdodDtcblxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IGluc2lkZSA/IHBsYWNlbWVudC5zcGxpdCgnICcpWzFdIDogcGxhY2VtZW50O1xuXG4gICAgICAgICAgICAgICAgdHBiID0ge3RvcDogcG9zLnRvcCArIHBvcy5oZWlnaHQsIGxlZnQ6IHBvcy5sZWZ0ICsgcG9zLndpZHRoIC8gMiAtIGFjdHVhbFdpZHRoIC8gMn07XG4gICAgICAgICAgICAgICAgdHB0ID0ge3RvcDogcG9zLnRvcCAtIGFjdHVhbEhlaWdodCwgbGVmdDogcG9zLmxlZnQgKyBwb3Mud2lkdGggLyAyIC0gYWN0dWFsV2lkdGggLyAyfTtcbiAgICAgICAgICAgICAgICB0cGwgPSB7dG9wOiBwb3MudG9wICsgcG9zLmhlaWdodCAvIDIgLSBhY3R1YWxIZWlnaHQgLyAyLCBsZWZ0OiBwb3MubGVmdCAtIGFjdHVhbFdpZHRofTtcbiAgICAgICAgICAgICAgICB0cHIgPSB7dG9wOiBwb3MudG9wICsgcG9zLmhlaWdodCAvIDIgLSBhY3R1YWxIZWlnaHQgLyAyLCBsZWZ0OiBwb3MubGVmdCArIHBvcy53aWR0aH07XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0cGIudG9wICsgYWN0dWFsSGVpZ2h0KSA+ICgkKHdpbmRvdykuc2Nyb2xsVG9wKCkgKyAkKHdpbmRvdykuaGVpZ2h0KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRwdC50b3AgPiAkKHdpbmRvdykuc2Nyb2xsVG9wKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gJ3RvcCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgodHByLmxlZnQgKyBhY3R1YWxXaWR0aCkgPCAoJCh3aW5kb3cpLnNjcm9sbExlZnQoKSArICQod2luZG93KS53aWR0aCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHBsLmxlZnQgPiAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRwdC50b3AgPCAkKHdpbmRvdykuc2Nyb2xsVG9wKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRwYi50b3AgKyBhY3R1YWxIZWlnaHQpIDwgKCQod2luZG93KS5zY3JvbGxUb3AoKSArICQod2luZG93KS5oZWlnaHQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgodHByLmxlZnQgKyBhY3R1YWxXaWR0aCkgPCAoJCh3aW5kb3cpLnNjcm9sbExlZnQoKSArICQod2luZG93KS53aWR0aCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHBsLmxlZnQgPiAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cGwubGVmdCA8ICQod2luZG93KS5zY3JvbGxMZWZ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRwci5sZWZ0ICsgYWN0dWFsV2lkdGgpIDwgKCQod2luZG93KS5zY3JvbGxMZWZ0KCkgKyAkKHdpbmRvdykud2lkdGgoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRwdC50b3AgPiAkKHdpbmRvdykuc2Nyb2xsVG9wKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gJ3RvcCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0cHQudG9wID4gJCh3aW5kb3cpLnNjcm9sbFRvcCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICdib3R0b20nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodHByLmxlZnQgKyBhY3R1YWxXaWR0aCkgPiAoJCh3aW5kb3cpLnNjcm9sbExlZnQoKSArICQod2luZG93KS53aWR0aCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cGwubGVmdCA+ICQod2luZG93KS5zY3JvbGxMZWZ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHB0LnRvcCA+ICQod2luZG93KS5zY3JvbGxUb3AoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAndG9wJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRwdC50b3AgPiAkKHdpbmRvdykuc2Nyb2xsVG9wKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRwID0gdHBiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0cCA9IHRwdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRwID0gdHBsO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRwID0gdHByO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgJHRpcFxuICAgICAgICAgICAgICAgIC5vZmZzZXQodHApXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKHBsYWNlbWVudClcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2luJyk7XG4gICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgJHRpcCA9IHRoaXMudGlwKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSB0eXBlb2YgdGhpcy5vcHRpb25zLnBsYWNlbWVudCA9PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucGxhY2VtZW50LmNhbGwodGhpcywgJHRpcFswXSwgdGhpcy4kZWxlbWVudFswXSkgOlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wbGFjZW1lbnQ7ICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIHZhciBhdXRvVG9rZW4gPSAvXFxzP2F1dG8/XFxzPy9pO1xuICAgICAgICAgICAgdmFyIGF1dG9QbGFjZSA9IGF1dG9Ub2tlbi50ZXN0KHBsYWNlbWVudCk7XG4gICAgICAgICAgICBpZiAoYXV0b1BsYWNlKSB7XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gcGxhY2VtZW50LnJlcGxhY2UoYXV0b1Rva2VuLCAnJykgfHwgJ3RvcCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIHZhciBhY3R1YWxXaWR0aCA9ICR0aXBbMF0ub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICB2YXIgYWN0dWFsSGVpZ2h0ID0gJHRpcFswXS5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmIChhdXRvUGxhY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgJHBhcmVudCA9IHRoaXMuJGVsZW1lbnQucGFyZW50KCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgb3JnUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIHZhciBkb2NTY3JvbGwgICAgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRXaWR0aCAgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyID09ICdib2R5JyA/IHdpbmRvdy5pbm5lcldpZHRoICA6ICRwYXJlbnQub3V0ZXJXaWR0aCgpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRIZWlnaHQgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyID09ICdib2R5JyA/IHdpbmRvdy5pbm5lckhlaWdodCA6ICRwYXJlbnQub3V0ZXJIZWlnaHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50TGVmdCAgID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lciA9PSAnYm9keScgPyAwIDogJHBhcmVudC5vZmZzZXQoKS5sZWZ0O1xuXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gcGxhY2VtZW50ID09ICdib3R0b20nICYmIHBvcy50b3AgICArIHBvcy5oZWlnaHQgICsgYWN0dWFsSGVpZ2h0IC0gZG9jU2Nyb2xsID4gcGFyZW50SGVpZ2h0ICA/ICd0b3AnICAgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPT0gJ3RvcCcgICAgJiYgcG9zLnRvcCAgIC0gZG9jU2Nyb2xsICAgLSBhY3R1YWxIZWlnaHQgPCAwICAgICAgICAgICAgICAgICAgICAgICAgID8gJ2JvdHRvbScgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9PSAncmlnaHQnICAmJiBwb3MucmlnaHQgKyBhY3R1YWxXaWR0aCA+IHBhcmVudFdpZHRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnbGVmdCcgICA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID09ICdsZWZ0JyAgICYmIHBvcy5sZWZ0ICAtIGFjdHVhbFdpZHRoIDwgcGFyZW50TGVmdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdyaWdodCcgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAkdGlwXG4gICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3Mob3JnUGxhY2VtZW50KVxuICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHBsYWNlbWVudCk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgdmFyIGNhbGN1bGF0ZWRPZmZzZXQgPSB0aGlzLmdldENhbGN1bGF0ZWRPZmZzZXQocGxhY2VtZW50LCBwb3MsIGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQpO1xuXG4gICAgICAgICAgICB0aGlzLmFwcGx5UGxhY2VtZW50KGNhbGN1bGF0ZWRPZmZzZXQsIHBsYWNlbWVudCk7ICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0pLmNhbGwodGhpcy5jb250YWluZXIoKSk7XG4gICAgICAgICAgLypqc2hpbnQgbGF4Y29tbWE6IGZhbHNlLCBlcWVxZXE6IHRydWUqLyAgXG4gICAgICAgIH0gICAgICAgICAgICBcbiAgICB9KTtcblxufSh3aW5kb3cualF1ZXJ5KSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogYm9vdHN0cmFwLWRhdGVwaWNrZXIuanNcbiAqIGh0dHA6Ly93d3cuZXllY29uLnJvL2Jvb3RzdHJhcC1kYXRlcGlja2VyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDEyIFN0ZWZhbiBQZXRyZVxuICogSW1wcm92ZW1lbnRzIGJ5IEFuZHJldyBSb3dsc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbihmdW5jdGlvbiggJCApIHtcblxuXHRmdW5jdGlvbiBVVENEYXRlKCl7XG5cdFx0cmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KERhdGUsIGFyZ3VtZW50cykpO1xuXHR9XG5cdGZ1bmN0aW9uIFVUQ1RvZGF5KCl7XG5cdFx0dmFyIHRvZGF5ID0gbmV3IERhdGUoKTtcblx0XHRyZXR1cm4gVVRDRGF0ZSh0b2RheS5nZXRVVENGdWxsWWVhcigpLCB0b2RheS5nZXRVVENNb250aCgpLCB0b2RheS5nZXRVVENEYXRlKCkpO1xuXHR9XG5cblx0Ly8gUGlja2VyIG9iamVjdFxuXG5cdHZhciBEYXRlcGlja2VyID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdHRoaXMuX3Byb2Nlc3Nfb3B0aW9ucyhvcHRpb25zKTtcblxuXHRcdHRoaXMuZWxlbWVudCA9ICQoZWxlbWVudCk7XG5cdFx0dGhpcy5pc0lubGluZSA9IGZhbHNlO1xuXHRcdHRoaXMuaXNJbnB1dCA9IHRoaXMuZWxlbWVudC5pcygnaW5wdXQnKTtcblx0XHR0aGlzLmNvbXBvbmVudCA9IHRoaXMuZWxlbWVudC5pcygnLmRhdGUnKSA/IHRoaXMuZWxlbWVudC5maW5kKCcuYWRkLW9uLCAuYnRuJykgOiBmYWxzZTtcblx0XHR0aGlzLmhhc0lucHV0ID0gdGhpcy5jb21wb25lbnQgJiYgdGhpcy5lbGVtZW50LmZpbmQoJ2lucHV0JykubGVuZ3RoO1xuXHRcdGlmKHRoaXMuY29tcG9uZW50ICYmIHRoaXMuY29tcG9uZW50Lmxlbmd0aCA9PT0gMClcblx0XHRcdHRoaXMuY29tcG9uZW50ID0gZmFsc2U7XG5cblx0XHR0aGlzLnBpY2tlciA9ICQoRFBHbG9iYWwudGVtcGxhdGUpO1xuXHRcdHRoaXMuX2J1aWxkRXZlbnRzKCk7XG5cdFx0dGhpcy5fYXR0YWNoRXZlbnRzKCk7XG5cblx0XHRpZih0aGlzLmlzSW5saW5lKSB7XG5cdFx0XHR0aGlzLnBpY2tlci5hZGRDbGFzcygnZGF0ZXBpY2tlci1pbmxpbmUnKS5hcHBlbmRUbyh0aGlzLmVsZW1lbnQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBpY2tlci5hZGRDbGFzcygnZGF0ZXBpY2tlci1kcm9wZG93biBkcm9wZG93bi1tZW51Jyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuby5ydGwpe1xuXHRcdFx0dGhpcy5waWNrZXIuYWRkQ2xhc3MoJ2RhdGVwaWNrZXItcnRsJyk7XG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCcucHJldiBpLCAubmV4dCBpJylcblx0XHRcdFx0XHRcdC50b2dnbGVDbGFzcygnaWNvbi1hcnJvdy1sZWZ0IGljb24tYXJyb3ctcmlnaHQnKTtcblx0XHR9XG5cblxuXHRcdHRoaXMudmlld01vZGUgPSB0aGlzLm8uc3RhcnRWaWV3O1xuXG5cdFx0aWYgKHRoaXMuby5jYWxlbmRhcldlZWtzKVxuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgndGZvb3QgdGgudG9kYXknKVxuXHRcdFx0XHRcdFx0LmF0dHIoJ2NvbHNwYW4nLCBmdW5jdGlvbihpLCB2YWwpe1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQodmFsKSArIDE7XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdHRoaXMuX2FsbG93X3VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5zZXRTdGFydERhdGUodGhpcy5vLnN0YXJ0RGF0ZSk7XG5cdFx0dGhpcy5zZXRFbmREYXRlKHRoaXMuby5lbmREYXRlKTtcblx0XHR0aGlzLnNldERheXNPZldlZWtEaXNhYmxlZCh0aGlzLm8uZGF5c09mV2Vla0Rpc2FibGVkKTtcblxuXHRcdHRoaXMuZmlsbERvdygpO1xuXHRcdHRoaXMuZmlsbE1vbnRocygpO1xuXG5cdFx0dGhpcy5fYWxsb3dfdXBkYXRlID0gdHJ1ZTtcblxuXHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0dGhpcy5zaG93TW9kZSgpO1xuXG5cdFx0aWYodGhpcy5pc0lubGluZSkge1xuXHRcdFx0dGhpcy5zaG93KCk7XG5cdFx0fVxuXHR9O1xuXG5cdERhdGVwaWNrZXIucHJvdG90eXBlID0ge1xuXHRcdGNvbnN0cnVjdG9yOiBEYXRlcGlja2VyLFxuXG5cdFx0X3Byb2Nlc3Nfb3B0aW9uczogZnVuY3Rpb24ob3B0cyl7XG5cdFx0XHQvLyBTdG9yZSByYXcgb3B0aW9ucyBmb3IgcmVmZXJlbmNlXG5cdFx0XHR0aGlzLl9vID0gJC5leHRlbmQoe30sIHRoaXMuX28sIG9wdHMpO1xuXHRcdFx0Ly8gUHJvY2Vzc2VkIG9wdGlvbnNcblx0XHRcdHZhciBvID0gdGhpcy5vID0gJC5leHRlbmQoe30sIHRoaXMuX28pO1xuXG5cdFx0XHQvLyBDaGVjayBpZiBcImRlLURFXCIgc3R5bGUgZGF0ZSBpcyBhdmFpbGFibGUsIGlmIG5vdCBsYW5ndWFnZSBzaG91bGRcblx0XHRcdC8vIGZhbGxiYWNrIHRvIDIgbGV0dGVyIGNvZGUgZWcgXCJkZVwiXG5cdFx0XHR2YXIgbGFuZyA9IG8ubGFuZ3VhZ2U7XG5cdFx0XHRpZiAoIWRhdGVzW2xhbmddKSB7XG5cdFx0XHRcdGxhbmcgPSBsYW5nLnNwbGl0KCctJylbMF07XG5cdFx0XHRcdGlmICghZGF0ZXNbbGFuZ10pXG5cdFx0XHRcdFx0bGFuZyA9IGRlZmF1bHRzLmxhbmd1YWdlO1xuXHRcdFx0fVxuXHRcdFx0by5sYW5ndWFnZSA9IGxhbmc7XG5cblx0XHRcdHN3aXRjaChvLnN0YXJ0Vmlldyl7XG5cdFx0XHRcdGNhc2UgMjpcblx0XHRcdFx0Y2FzZSAnZGVjYWRlJzpcblx0XHRcdFx0XHRvLnN0YXJ0VmlldyA9IDI7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0Y2FzZSAneWVhcic6XG5cdFx0XHRcdFx0by5zdGFydFZpZXcgPSAxO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdG8uc3RhcnRWaWV3ID0gMDtcblx0XHRcdH1cblxuXHRcdFx0c3dpdGNoIChvLm1pblZpZXdNb2RlKSB7XG5cdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0Y2FzZSAnbW9udGhzJzpcblx0XHRcdFx0XHRvLm1pblZpZXdNb2RlID0gMTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRjYXNlICd5ZWFycyc6XG5cdFx0XHRcdFx0by5taW5WaWV3TW9kZSA9IDI7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0by5taW5WaWV3TW9kZSA9IDA7XG5cdFx0XHR9XG5cblx0XHRcdG8uc3RhcnRWaWV3ID0gTWF0aC5tYXgoby5zdGFydFZpZXcsIG8ubWluVmlld01vZGUpO1xuXG5cdFx0XHRvLndlZWtTdGFydCAlPSA3O1xuXHRcdFx0by53ZWVrRW5kID0gKChvLndlZWtTdGFydCArIDYpICUgNyk7XG5cblx0XHRcdHZhciBmb3JtYXQgPSBEUEdsb2JhbC5wYXJzZUZvcm1hdChvLmZvcm1hdClcblx0XHRcdGlmIChvLnN0YXJ0RGF0ZSAhPT0gLUluZmluaXR5KSB7XG5cdFx0XHRcdG8uc3RhcnREYXRlID0gRFBHbG9iYWwucGFyc2VEYXRlKG8uc3RhcnREYXRlLCBmb3JtYXQsIG8ubGFuZ3VhZ2UpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG8uZW5kRGF0ZSAhPT0gSW5maW5pdHkpIHtcblx0XHRcdFx0by5lbmREYXRlID0gRFBHbG9iYWwucGFyc2VEYXRlKG8uZW5kRGF0ZSwgZm9ybWF0LCBvLmxhbmd1YWdlKTtcblx0XHRcdH1cblxuXHRcdFx0by5kYXlzT2ZXZWVrRGlzYWJsZWQgPSBvLmRheXNPZldlZWtEaXNhYmxlZHx8W107XG5cdFx0XHRpZiAoISQuaXNBcnJheShvLmRheXNPZldlZWtEaXNhYmxlZCkpXG5cdFx0XHRcdG8uZGF5c09mV2Vla0Rpc2FibGVkID0gby5kYXlzT2ZXZWVrRGlzYWJsZWQuc3BsaXQoL1ssXFxzXSovKTtcblx0XHRcdG8uZGF5c09mV2Vla0Rpc2FibGVkID0gJC5tYXAoby5kYXlzT2ZXZWVrRGlzYWJsZWQsIGZ1bmN0aW9uIChkKSB7XG5cdFx0XHRcdHJldHVybiBwYXJzZUludChkLCAxMCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdF9ldmVudHM6IFtdLFxuXHRcdF9zZWNvbmRhcnlFdmVudHM6IFtdLFxuXHRcdF9hcHBseUV2ZW50czogZnVuY3Rpb24oZXZzKXtcblx0XHRcdGZvciAodmFyIGk9MCwgZWwsIGV2OyBpPGV2cy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdGVsID0gZXZzW2ldWzBdO1xuXHRcdFx0XHRldiA9IGV2c1tpXVsxXTtcblx0XHRcdFx0ZWwub24oZXYpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0X3VuYXBwbHlFdmVudHM6IGZ1bmN0aW9uKGV2cyl7XG5cdFx0XHRmb3IgKHZhciBpPTAsIGVsLCBldjsgaTxldnMubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRlbCA9IGV2c1tpXVswXTtcblx0XHRcdFx0ZXYgPSBldnNbaV1bMV07XG5cdFx0XHRcdGVsLm9mZihldik7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRfYnVpbGRFdmVudHM6IGZ1bmN0aW9uKCl7XG5cdFx0XHRpZiAodGhpcy5pc0lucHV0KSB7IC8vIHNpbmdsZSBpbnB1dFxuXHRcdFx0XHR0aGlzLl9ldmVudHMgPSBbXG5cdFx0XHRcdFx0W3RoaXMuZWxlbWVudCwge1xuXHRcdFx0XHRcdFx0Zm9jdXM6ICQucHJveHkodGhpcy5zaG93LCB0aGlzKSxcblx0XHRcdFx0XHRcdGtleXVwOiAkLnByb3h5KHRoaXMudXBkYXRlLCB0aGlzKSxcblx0XHRcdFx0XHRcdGtleWRvd246ICQucHJveHkodGhpcy5rZXlkb3duLCB0aGlzKVxuXHRcdFx0XHRcdH1dXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh0aGlzLmNvbXBvbmVudCAmJiB0aGlzLmhhc0lucHV0KXsgLy8gY29tcG9uZW50OiBpbnB1dCArIGJ1dHRvblxuXHRcdFx0XHR0aGlzLl9ldmVudHMgPSBbXG5cdFx0XHRcdFx0Ly8gRm9yIGNvbXBvbmVudHMgdGhhdCBhcmUgbm90IHJlYWRvbmx5LCBhbGxvdyBrZXlib2FyZCBuYXZcblx0XHRcdFx0XHRbdGhpcy5lbGVtZW50LmZpbmQoJ2lucHV0JyksIHtcblx0XHRcdFx0XHRcdGZvY3VzOiAkLnByb3h5KHRoaXMuc2hvdywgdGhpcyksXG5cdFx0XHRcdFx0XHRrZXl1cDogJC5wcm94eSh0aGlzLnVwZGF0ZSwgdGhpcyksXG5cdFx0XHRcdFx0XHRrZXlkb3duOiAkLnByb3h5KHRoaXMua2V5ZG93biwgdGhpcylcblx0XHRcdFx0XHR9XSxcblx0XHRcdFx0XHRbdGhpcy5jb21wb25lbnQsIHtcblx0XHRcdFx0XHRcdGNsaWNrOiAkLnByb3h5KHRoaXMuc2hvdywgdGhpcylcblx0XHRcdFx0XHR9XVxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAodGhpcy5lbGVtZW50LmlzKCdkaXYnKSkgeyAgLy8gaW5saW5lIGRhdGVwaWNrZXJcblx0XHRcdFx0dGhpcy5pc0lubGluZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dGhpcy5fZXZlbnRzID0gW1xuXHRcdFx0XHRcdFt0aGlzLmVsZW1lbnQsIHtcblx0XHRcdFx0XHRcdGNsaWNrOiAkLnByb3h5KHRoaXMuc2hvdywgdGhpcylcblx0XHRcdFx0XHR9XVxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9zZWNvbmRhcnlFdmVudHMgPSBbXG5cdFx0XHRcdFt0aGlzLnBpY2tlciwge1xuXHRcdFx0XHRcdGNsaWNrOiAkLnByb3h5KHRoaXMuY2xpY2ssIHRoaXMpXG5cdFx0XHRcdH1dLFxuXHRcdFx0XHRbJCh3aW5kb3cpLCB7XG5cdFx0XHRcdFx0cmVzaXplOiAkLnByb3h5KHRoaXMucGxhY2UsIHRoaXMpXG5cdFx0XHRcdH1dLFxuXHRcdFx0XHRbJChkb2N1bWVudCksIHtcblx0XHRcdFx0XHRtb3VzZWRvd246ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdC8vIENsaWNrZWQgb3V0c2lkZSB0aGUgZGF0ZXBpY2tlciwgaGlkZSBpdFxuXHRcdFx0XHRcdFx0aWYgKCEoXG5cdFx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC5pcyhlLnRhcmdldCkgfHxcblx0XHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoZS50YXJnZXQpLnNpemUoKSB8fFxuXHRcdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5pcyhlLnRhcmdldCkgfHxcblx0XHRcdFx0XHRcdFx0dGhpcy5waWNrZXIuZmluZChlLnRhcmdldCkuc2l6ZSgpXG5cdFx0XHRcdFx0XHQpKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuaGlkZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpXG5cdFx0XHRcdH1dXG5cdFx0XHRdO1xuXHRcdH0sXG5cdFx0X2F0dGFjaEV2ZW50czogZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMuX2RldGFjaEV2ZW50cygpO1xuXHRcdFx0dGhpcy5fYXBwbHlFdmVudHModGhpcy5fZXZlbnRzKTtcblx0XHR9LFxuXHRcdF9kZXRhY2hFdmVudHM6IGZ1bmN0aW9uKCl7XG5cdFx0XHR0aGlzLl91bmFwcGx5RXZlbnRzKHRoaXMuX2V2ZW50cyk7XG5cdFx0fSxcblx0XHRfYXR0YWNoU2Vjb25kYXJ5RXZlbnRzOiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5fZGV0YWNoU2Vjb25kYXJ5RXZlbnRzKCk7XG5cdFx0XHR0aGlzLl9hcHBseUV2ZW50cyh0aGlzLl9zZWNvbmRhcnlFdmVudHMpO1xuXHRcdH0sXG5cdFx0X2RldGFjaFNlY29uZGFyeUV2ZW50czogZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMuX3VuYXBwbHlFdmVudHModGhpcy5fc2Vjb25kYXJ5RXZlbnRzKTtcblx0XHR9LFxuXHRcdF90cmlnZ2VyOiBmdW5jdGlvbihldmVudCwgYWx0ZGF0ZSl7XG5cdFx0XHR2YXIgZGF0ZSA9IGFsdGRhdGUgfHwgdGhpcy5kYXRlLFxuXHRcdFx0XHRsb2NhbF9kYXRlID0gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkgKyAoZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpKjYwMDAwKSk7XG5cblx0XHRcdHRoaXMuZWxlbWVudC50cmlnZ2VyKHtcblx0XHRcdFx0dHlwZTogZXZlbnQsXG5cdFx0XHRcdGRhdGU6IGxvY2FsX2RhdGUsXG5cdFx0XHRcdGZvcm1hdDogJC5wcm94eShmdW5jdGlvbihhbHRmb3JtYXQpe1xuXHRcdFx0XHRcdHZhciBmb3JtYXQgPSBhbHRmb3JtYXQgfHwgdGhpcy5vLmZvcm1hdDtcblx0XHRcdFx0XHRyZXR1cm4gRFBHbG9iYWwuZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXQsIHRoaXMuby5sYW5ndWFnZSk7XG5cdFx0XHRcdH0sIHRoaXMpXG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0c2hvdzogZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYgKCF0aGlzLmlzSW5saW5lKVxuXHRcdFx0XHR0aGlzLnBpY2tlci5hcHBlbmRUbygnYm9keScpO1xuXHRcdFx0dGhpcy5waWNrZXIuc2hvdygpO1xuXHRcdFx0dGhpcy5oZWlnaHQgPSB0aGlzLmNvbXBvbmVudCA/IHRoaXMuY29tcG9uZW50Lm91dGVySGVpZ2h0KCkgOiB0aGlzLmVsZW1lbnQub3V0ZXJIZWlnaHQoKTtcblx0XHRcdHRoaXMucGxhY2UoKTtcblx0XHRcdHRoaXMuX2F0dGFjaFNlY29uZGFyeUV2ZW50cygpO1xuXHRcdFx0aWYgKGUpIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdHJpZ2dlcignc2hvdycpO1xuXHRcdH0sXG5cblx0XHRoaWRlOiBmdW5jdGlvbihlKXtcblx0XHRcdGlmKHRoaXMuaXNJbmxpbmUpIHJldHVybjtcblx0XHRcdGlmICghdGhpcy5waWNrZXIuaXMoJzp2aXNpYmxlJykpIHJldHVybjtcblx0XHRcdHRoaXMucGlja2VyLmhpZGUoKS5kZXRhY2goKTtcblx0XHRcdHRoaXMuX2RldGFjaFNlY29uZGFyeUV2ZW50cygpO1xuXHRcdFx0dGhpcy52aWV3TW9kZSA9IHRoaXMuby5zdGFydFZpZXc7XG5cdFx0XHR0aGlzLnNob3dNb2RlKCk7XG5cblx0XHRcdGlmIChcblx0XHRcdFx0dGhpcy5vLmZvcmNlUGFyc2UgJiZcblx0XHRcdFx0KFxuXHRcdFx0XHRcdHRoaXMuaXNJbnB1dCAmJiB0aGlzLmVsZW1lbnQudmFsKCkgfHxcblx0XHRcdFx0XHR0aGlzLmhhc0lucHV0ICYmIHRoaXMuZWxlbWVudC5maW5kKCdpbnB1dCcpLnZhbCgpXG5cdFx0XHRcdClcblx0XHRcdClcblx0XHRcdFx0dGhpcy5zZXRWYWx1ZSgpO1xuXHRcdFx0dGhpcy5fdHJpZ2dlcignaGlkZScpO1xuXHRcdH0sXG5cblx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5oaWRlKCk7XG5cdFx0XHR0aGlzLl9kZXRhY2hFdmVudHMoKTtcblx0XHRcdHRoaXMuX2RldGFjaFNlY29uZGFyeUV2ZW50cygpO1xuXHRcdFx0dGhpcy5waWNrZXIucmVtb3ZlKCk7XG5cdFx0XHRkZWxldGUgdGhpcy5lbGVtZW50LmRhdGEoKS5kYXRlcGlja2VyO1xuXHRcdFx0aWYgKCF0aGlzLmlzSW5wdXQpIHtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuZWxlbWVudC5kYXRhKCkuZGF0ZTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z2V0RGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZCA9IHRoaXMuZ2V0VVRDRGF0ZSgpO1xuXHRcdFx0cmV0dXJuIG5ldyBEYXRlKGQuZ2V0VGltZSgpICsgKGQuZ2V0VGltZXpvbmVPZmZzZXQoKSo2MDAwMCkpO1xuXHRcdH0sXG5cblx0XHRnZXRVVENEYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmRhdGU7XG5cdFx0fSxcblxuXHRcdHNldERhdGU6IGZ1bmN0aW9uKGQpIHtcblx0XHRcdHRoaXMuc2V0VVRDRGF0ZShuZXcgRGF0ZShkLmdldFRpbWUoKSAtIChkLmdldFRpbWV6b25lT2Zmc2V0KCkqNjAwMDApKSk7XG5cdFx0fSxcblxuXHRcdHNldFVUQ0RhdGU6IGZ1bmN0aW9uKGQpIHtcblx0XHRcdHRoaXMuZGF0ZSA9IGQ7XG5cdFx0XHR0aGlzLnNldFZhbHVlKCk7XG5cdFx0fSxcblxuXHRcdHNldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBmb3JtYXR0ZWQgPSB0aGlzLmdldEZvcm1hdHRlZERhdGUoKTtcblx0XHRcdGlmICghdGhpcy5pc0lucHV0KSB7XG5cdFx0XHRcdGlmICh0aGlzLmNvbXBvbmVudCl7XG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoJ2lucHV0JykudmFsKGZvcm1hdHRlZCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC52YWwoZm9ybWF0dGVkKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z2V0Rm9ybWF0dGVkRGF0ZTogZnVuY3Rpb24oZm9ybWF0KSB7XG5cdFx0XHRpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdGZvcm1hdCA9IHRoaXMuby5mb3JtYXQ7XG5cdFx0XHRyZXR1cm4gRFBHbG9iYWwuZm9ybWF0RGF0ZSh0aGlzLmRhdGUsIGZvcm1hdCwgdGhpcy5vLmxhbmd1YWdlKTtcblx0XHR9LFxuXG5cdFx0c2V0U3RhcnREYXRlOiBmdW5jdGlvbihzdGFydERhdGUpe1xuXHRcdFx0dGhpcy5fcHJvY2Vzc19vcHRpb25zKHtzdGFydERhdGU6IHN0YXJ0RGF0ZX0pO1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdHRoaXMudXBkYXRlTmF2QXJyb3dzKCk7XG5cdFx0fSxcblxuXHRcdHNldEVuZERhdGU6IGZ1bmN0aW9uKGVuZERhdGUpe1xuXHRcdFx0dGhpcy5fcHJvY2Vzc19vcHRpb25zKHtlbmREYXRlOiBlbmREYXRlfSk7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0dGhpcy51cGRhdGVOYXZBcnJvd3MoKTtcblx0XHR9LFxuXG5cdFx0c2V0RGF5c09mV2Vla0Rpc2FibGVkOiBmdW5jdGlvbihkYXlzT2ZXZWVrRGlzYWJsZWQpe1xuXHRcdFx0dGhpcy5fcHJvY2Vzc19vcHRpb25zKHtkYXlzT2ZXZWVrRGlzYWJsZWQ6IGRheXNPZldlZWtEaXNhYmxlZH0pO1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdHRoaXMudXBkYXRlTmF2QXJyb3dzKCk7XG5cdFx0fSxcblxuXHRcdHBsYWNlOiBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0aWYodGhpcy5pc0lubGluZSkgcmV0dXJuO1xuXHRcdFx0dmFyIHpJbmRleCA9IHBhcnNlSW50KHRoaXMuZWxlbWVudC5wYXJlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gJCh0aGlzKS5jc3MoJ3otaW5kZXgnKSAhPSAnYXV0byc7XG5cdFx0XHRcdFx0XHR9KS5maXJzdCgpLmNzcygnei1pbmRleCcpKSsxMDtcblx0XHRcdHZhciBvZmZzZXQgPSB0aGlzLmNvbXBvbmVudCA/IHRoaXMuY29tcG9uZW50LnBhcmVudCgpLm9mZnNldCgpIDogdGhpcy5lbGVtZW50Lm9mZnNldCgpO1xuXHRcdFx0dmFyIGhlaWdodCA9IHRoaXMuY29tcG9uZW50ID8gdGhpcy5jb21wb25lbnQub3V0ZXJIZWlnaHQodHJ1ZSkgOiB0aGlzLmVsZW1lbnQub3V0ZXJIZWlnaHQodHJ1ZSk7XG5cdFx0XHR0aGlzLnBpY2tlci5jc3Moe1xuXHRcdFx0XHR0b3A6IG9mZnNldC50b3AgKyBoZWlnaHQsXG5cdFx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0LFxuXHRcdFx0XHR6SW5kZXg6IHpJbmRleFxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdF9hbGxvd191cGRhdGU6IHRydWUsXG5cdFx0dXBkYXRlOiBmdW5jdGlvbigpe1xuXHRcdFx0aWYgKCF0aGlzLl9hbGxvd191cGRhdGUpIHJldHVybjtcblxuXHRcdFx0dmFyIGRhdGUsIGZyb21BcmdzID0gZmFsc2U7XG5cdFx0XHRpZihhcmd1bWVudHMgJiYgYXJndW1lbnRzLmxlbmd0aCAmJiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ3N0cmluZycgfHwgYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgRGF0ZSkpIHtcblx0XHRcdFx0ZGF0ZSA9IGFyZ3VtZW50c1swXTtcblx0XHRcdFx0ZnJvbUFyZ3MgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0ZSA9IHRoaXMuaXNJbnB1dCA/IHRoaXMuZWxlbWVudC52YWwoKSA6IHRoaXMuZWxlbWVudC5kYXRhKCdkYXRlJykgfHwgdGhpcy5lbGVtZW50LmZpbmQoJ2lucHV0JykudmFsKCk7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmVsZW1lbnQuZGF0YSgpLmRhdGU7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZGF0ZSA9IERQR2xvYmFsLnBhcnNlRGF0ZShkYXRlLCB0aGlzLm8uZm9ybWF0LCB0aGlzLm8ubGFuZ3VhZ2UpO1xuXG5cdFx0XHRpZihmcm9tQXJncykgdGhpcy5zZXRWYWx1ZSgpO1xuXG5cdFx0XHRpZiAodGhpcy5kYXRlIDwgdGhpcy5vLnN0YXJ0RGF0ZSkge1xuXHRcdFx0XHR0aGlzLnZpZXdEYXRlID0gbmV3IERhdGUodGhpcy5vLnN0YXJ0RGF0ZSk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuZGF0ZSA+IHRoaXMuby5lbmREYXRlKSB7XG5cdFx0XHRcdHRoaXMudmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLm8uZW5kRGF0ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnZpZXdEYXRlID0gbmV3IERhdGUodGhpcy5kYXRlKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZmlsbCgpO1xuXHRcdH0sXG5cblx0XHRmaWxsRG93OiBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIGRvd0NudCA9IHRoaXMuby53ZWVrU3RhcnQsXG5cdFx0XHRodG1sID0gJzx0cj4nO1xuXHRcdFx0aWYodGhpcy5vLmNhbGVuZGFyV2Vla3Mpe1xuXHRcdFx0XHR2YXIgY2VsbCA9ICc8dGggY2xhc3M9XCJjd1wiPiZuYnNwOzwvdGg+Jztcblx0XHRcdFx0aHRtbCArPSBjZWxsO1xuXHRcdFx0XHR0aGlzLnBpY2tlci5maW5kKCcuZGF0ZXBpY2tlci1kYXlzIHRoZWFkIHRyOmZpcnN0LWNoaWxkJykucHJlcGVuZChjZWxsKTtcblx0XHRcdH1cblx0XHRcdHdoaWxlIChkb3dDbnQgPCB0aGlzLm8ud2Vla1N0YXJ0ICsgNykge1xuXHRcdFx0XHRodG1sICs9ICc8dGggY2xhc3M9XCJkb3dcIj4nK2RhdGVzW3RoaXMuby5sYW5ndWFnZV0uZGF5c01pblsoZG93Q250KyspJTddKyc8L3RoPic7XG5cdFx0XHR9XG5cdFx0XHRodG1sICs9ICc8L3RyPic7XG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCcuZGF0ZXBpY2tlci1kYXlzIHRoZWFkJykuYXBwZW5kKGh0bWwpO1xuXHRcdH0sXG5cblx0XHRmaWxsTW9udGhzOiBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIGh0bWwgPSAnJyxcblx0XHRcdGkgPSAwO1xuXHRcdFx0d2hpbGUgKGkgPCAxMikge1xuXHRcdFx0XHRodG1sICs9ICc8c3BhbiBjbGFzcz1cIm1vbnRoXCI+JytkYXRlc1t0aGlzLm8ubGFuZ3VhZ2VdLm1vbnRoc1Nob3J0W2krK10rJzwvc3Bhbj4nO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLmRhdGVwaWNrZXItbW9udGhzIHRkJykuaHRtbChodG1sKTtcblx0XHR9LFxuXG5cdFx0c2V0UmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKXtcblx0XHRcdGlmICghcmFuZ2UgfHwgIXJhbmdlLmxlbmd0aClcblx0XHRcdFx0ZGVsZXRlIHRoaXMucmFuZ2U7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHRoaXMucmFuZ2UgPSAkLm1hcChyYW5nZSwgZnVuY3Rpb24oZCl7IHJldHVybiBkLnZhbHVlT2YoKTsgfSk7XG5cdFx0XHR0aGlzLmZpbGwoKTtcblx0XHR9LFxuXG5cdFx0Z2V0Q2xhc3NOYW1lczogZnVuY3Rpb24oZGF0ZSl7XG5cdFx0XHR2YXIgY2xzID0gW10sXG5cdFx0XHRcdHllYXIgPSB0aGlzLnZpZXdEYXRlLmdldFVUQ0Z1bGxZZWFyKCksXG5cdFx0XHRcdG1vbnRoID0gdGhpcy52aWV3RGF0ZS5nZXRVVENNb250aCgpLFxuXHRcdFx0XHRjdXJyZW50RGF0ZSA9IHRoaXMuZGF0ZS52YWx1ZU9mKCksXG5cdFx0XHRcdHRvZGF5ID0gbmV3IERhdGUoKTtcblx0XHRcdGlmIChkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgPCB5ZWFyIHx8IChkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgPT0geWVhciAmJiBkYXRlLmdldFVUQ01vbnRoKCkgPCBtb250aCkpIHtcblx0XHRcdFx0Y2xzLnB1c2goJ29sZCcpO1xuXHRcdFx0fSBlbHNlIGlmIChkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgPiB5ZWFyIHx8IChkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgPT0geWVhciAmJiBkYXRlLmdldFVUQ01vbnRoKCkgPiBtb250aCkpIHtcblx0XHRcdFx0Y2xzLnB1c2goJ25ldycpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQ29tcGFyZSBpbnRlcm5hbCBVVEMgZGF0ZSB3aXRoIGxvY2FsIHRvZGF5LCBub3QgVVRDIHRvZGF5XG5cdFx0XHRpZiAodGhpcy5vLnRvZGF5SGlnaGxpZ2h0ICYmXG5cdFx0XHRcdGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA9PSB0b2RheS5nZXRGdWxsWWVhcigpICYmXG5cdFx0XHRcdGRhdGUuZ2V0VVRDTW9udGgoKSA9PSB0b2RheS5nZXRNb250aCgpICYmXG5cdFx0XHRcdGRhdGUuZ2V0VVRDRGF0ZSgpID09IHRvZGF5LmdldERhdGUoKSkge1xuXHRcdFx0XHRjbHMucHVzaCgndG9kYXknKTtcblx0XHRcdH1cblx0XHRcdGlmIChjdXJyZW50RGF0ZSAmJiBkYXRlLnZhbHVlT2YoKSA9PSBjdXJyZW50RGF0ZSkge1xuXHRcdFx0XHRjbHMucHVzaCgnYWN0aXZlJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGF0ZS52YWx1ZU9mKCkgPCB0aGlzLm8uc3RhcnREYXRlIHx8IGRhdGUudmFsdWVPZigpID4gdGhpcy5vLmVuZERhdGUgfHxcblx0XHRcdFx0JC5pbkFycmF5KGRhdGUuZ2V0VVRDRGF5KCksIHRoaXMuby5kYXlzT2ZXZWVrRGlzYWJsZWQpICE9PSAtMSkge1xuXHRcdFx0XHRjbHMucHVzaCgnZGlzYWJsZWQnKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLnJhbmdlKXtcblx0XHRcdFx0aWYgKGRhdGUgPiB0aGlzLnJhbmdlWzBdICYmIGRhdGUgPCB0aGlzLnJhbmdlW3RoaXMucmFuZ2UubGVuZ3RoLTFdKXtcblx0XHRcdFx0XHRjbHMucHVzaCgncmFuZ2UnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoJC5pbkFycmF5KGRhdGUudmFsdWVPZigpLCB0aGlzLnJhbmdlKSAhPSAtMSl7XG5cdFx0XHRcdFx0Y2xzLnB1c2goJ3NlbGVjdGVkJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjbHM7XG5cdFx0fSxcblxuXHRcdGZpbGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGQgPSBuZXcgRGF0ZSh0aGlzLnZpZXdEYXRlKSxcblx0XHRcdFx0eWVhciA9IGQuZ2V0VVRDRnVsbFllYXIoKSxcblx0XHRcdFx0bW9udGggPSBkLmdldFVUQ01vbnRoKCksXG5cdFx0XHRcdHN0YXJ0WWVhciA9IHRoaXMuby5zdGFydERhdGUgIT09IC1JbmZpbml0eSA/IHRoaXMuby5zdGFydERhdGUuZ2V0VVRDRnVsbFllYXIoKSA6IC1JbmZpbml0eSxcblx0XHRcdFx0c3RhcnRNb250aCA9IHRoaXMuby5zdGFydERhdGUgIT09IC1JbmZpbml0eSA/IHRoaXMuby5zdGFydERhdGUuZ2V0VVRDTW9udGgoKSA6IC1JbmZpbml0eSxcblx0XHRcdFx0ZW5kWWVhciA9IHRoaXMuby5lbmREYXRlICE9PSBJbmZpbml0eSA/IHRoaXMuby5lbmREYXRlLmdldFVUQ0Z1bGxZZWFyKCkgOiBJbmZpbml0eSxcblx0XHRcdFx0ZW5kTW9udGggPSB0aGlzLm8uZW5kRGF0ZSAhPT0gSW5maW5pdHkgPyB0aGlzLm8uZW5kRGF0ZS5nZXRVVENNb250aCgpIDogSW5maW5pdHksXG5cdFx0XHRcdGN1cnJlbnREYXRlID0gdGhpcy5kYXRlICYmIHRoaXMuZGF0ZS52YWx1ZU9mKCksXG5cdFx0XHRcdHRvb2x0aXA7XG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCcuZGF0ZXBpY2tlci1kYXlzIHRoZWFkIHRoLmRhdGVwaWNrZXItc3dpdGNoJylcblx0XHRcdFx0XHRcdC50ZXh0KGRhdGVzW3RoaXMuby5sYW5ndWFnZV0ubW9udGhzW21vbnRoXSsnICcreWVhcik7XG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCd0Zm9vdCB0aC50b2RheScpXG5cdFx0XHRcdFx0XHQudGV4dChkYXRlc1t0aGlzLm8ubGFuZ3VhZ2VdLnRvZGF5KVxuXHRcdFx0XHRcdFx0LnRvZ2dsZSh0aGlzLm8udG9kYXlCdG4gIT09IGZhbHNlKTtcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJ3Rmb290IHRoLmNsZWFyJylcblx0XHRcdFx0XHRcdC50ZXh0KGRhdGVzW3RoaXMuby5sYW5ndWFnZV0uY2xlYXIpXG5cdFx0XHRcdFx0XHQudG9nZ2xlKHRoaXMuby5jbGVhckJ0biAhPT0gZmFsc2UpO1xuXHRcdFx0dGhpcy51cGRhdGVOYXZBcnJvd3MoKTtcblx0XHRcdHRoaXMuZmlsbE1vbnRocygpO1xuXHRcdFx0dmFyIHByZXZNb250aCA9IFVUQ0RhdGUoeWVhciwgbW9udGgtMSwgMjgsMCwwLDAsMCksXG5cdFx0XHRcdGRheSA9IERQR2xvYmFsLmdldERheXNJbk1vbnRoKHByZXZNb250aC5nZXRVVENGdWxsWWVhcigpLCBwcmV2TW9udGguZ2V0VVRDTW9udGgoKSk7XG5cdFx0XHRwcmV2TW9udGguc2V0VVRDRGF0ZShkYXkpO1xuXHRcdFx0cHJldk1vbnRoLnNldFVUQ0RhdGUoZGF5IC0gKHByZXZNb250aC5nZXRVVENEYXkoKSAtIHRoaXMuby53ZWVrU3RhcnQgKyA3KSU3KTtcblx0XHRcdHZhciBuZXh0TW9udGggPSBuZXcgRGF0ZShwcmV2TW9udGgpO1xuXHRcdFx0bmV4dE1vbnRoLnNldFVUQ0RhdGUobmV4dE1vbnRoLmdldFVUQ0RhdGUoKSArIDQyKTtcblx0XHRcdG5leHRNb250aCA9IG5leHRNb250aC52YWx1ZU9mKCk7XG5cdFx0XHR2YXIgaHRtbCA9IFtdO1xuXHRcdFx0dmFyIGNsc05hbWU7XG5cdFx0XHR3aGlsZShwcmV2TW9udGgudmFsdWVPZigpIDwgbmV4dE1vbnRoKSB7XG5cdFx0XHRcdGlmIChwcmV2TW9udGguZ2V0VVRDRGF5KCkgPT0gdGhpcy5vLndlZWtTdGFydCkge1xuXHRcdFx0XHRcdGh0bWwucHVzaCgnPHRyPicpO1xuXHRcdFx0XHRcdGlmKHRoaXMuby5jYWxlbmRhcldlZWtzKXtcblx0XHRcdFx0XHRcdC8vIElTTyA4NjAxOiBGaXJzdCB3ZWVrIGNvbnRhaW5zIGZpcnN0IHRodXJzZGF5LlxuXHRcdFx0XHRcdFx0Ly8gSVNPIGFsc28gc3RhdGVzIHdlZWsgc3RhcnRzIG9uIE1vbmRheSwgYnV0IHdlIGNhbiBiZSBtb3JlIGFic3RyYWN0IGhlcmUuXG5cdFx0XHRcdFx0XHR2YXJcblx0XHRcdFx0XHRcdFx0Ly8gU3RhcnQgb2YgY3VycmVudCB3ZWVrOiBiYXNlZCBvbiB3ZWVrc3RhcnQvY3VycmVudCBkYXRlXG5cdFx0XHRcdFx0XHRcdHdzID0gbmV3IERhdGUoK3ByZXZNb250aCArICh0aGlzLm8ud2Vla1N0YXJ0IC0gcHJldk1vbnRoLmdldFVUQ0RheSgpIC0gNykgJSA3ICogODY0ZTUpLFxuXHRcdFx0XHRcdFx0XHQvLyBUaHVyc2RheSBvZiB0aGlzIHdlZWtcblx0XHRcdFx0XHRcdFx0dGggPSBuZXcgRGF0ZSgrd3MgKyAoNyArIDQgLSB3cy5nZXRVVENEYXkoKSkgJSA3ICogODY0ZTUpLFxuXHRcdFx0XHRcdFx0XHQvLyBGaXJzdCBUaHVyc2RheSBvZiB5ZWFyLCB5ZWFyIGZyb20gdGh1cnNkYXlcblx0XHRcdFx0XHRcdFx0eXRoID0gbmV3IERhdGUoKyh5dGggPSBVVENEYXRlKHRoLmdldFVUQ0Z1bGxZZWFyKCksIDAsIDEpKSArICg3ICsgNCAtIHl0aC5nZXRVVENEYXkoKSklNyo4NjRlNSksXG5cdFx0XHRcdFx0XHRcdC8vIENhbGVuZGFyIHdlZWs6IG1zIGJldHdlZW4gdGh1cnNkYXlzLCBkaXYgbXMgcGVyIGRheSwgZGl2IDcgZGF5c1xuXHRcdFx0XHRcdFx0XHRjYWxXZWVrID0gICh0aCAtIHl0aCkgLyA4NjRlNSAvIDcgKyAxO1xuXHRcdFx0XHRcdFx0aHRtbC5wdXNoKCc8dGQgY2xhc3M9XCJjd1wiPicrIGNhbFdlZWsgKyc8L3RkPicpO1xuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNsc05hbWUgPSB0aGlzLmdldENsYXNzTmFtZXMocHJldk1vbnRoKTtcblx0XHRcdFx0Y2xzTmFtZS5wdXNoKCdkYXknKTtcblxuXHRcdFx0XHR2YXIgYmVmb3JlID0gdGhpcy5vLmJlZm9yZVNob3dEYXkocHJldk1vbnRoKTtcblx0XHRcdFx0aWYgKGJlZm9yZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGJlZm9yZSA9IHt9O1xuXHRcdFx0XHRlbHNlIGlmICh0eXBlb2YoYmVmb3JlKSA9PT0gJ2Jvb2xlYW4nKVxuXHRcdFx0XHRcdGJlZm9yZSA9IHtlbmFibGVkOiBiZWZvcmV9O1xuXHRcdFx0XHRlbHNlIGlmICh0eXBlb2YoYmVmb3JlKSA9PT0gJ3N0cmluZycpXG5cdFx0XHRcdFx0YmVmb3JlID0ge2NsYXNzZXM6IGJlZm9yZX07XG5cdFx0XHRcdGlmIChiZWZvcmUuZW5hYmxlZCA9PT0gZmFsc2UpXG5cdFx0XHRcdFx0Y2xzTmFtZS5wdXNoKCdkaXNhYmxlZCcpO1xuXHRcdFx0XHRpZiAoYmVmb3JlLmNsYXNzZXMpXG5cdFx0XHRcdFx0Y2xzTmFtZSA9IGNsc05hbWUuY29uY2F0KGJlZm9yZS5jbGFzc2VzLnNwbGl0KC9cXHMrLykpO1xuXHRcdFx0XHRpZiAoYmVmb3JlLnRvb2x0aXApXG5cdFx0XHRcdFx0dG9vbHRpcCA9IGJlZm9yZS50b29sdGlwO1xuXG5cdFx0XHRcdGNsc05hbWUgPSAkLnVuaXF1ZShjbHNOYW1lKTtcblx0XHRcdFx0aHRtbC5wdXNoKCc8dGQgY2xhc3M9XCInK2Nsc05hbWUuam9pbignICcpKydcIicgKyAodG9vbHRpcCA/ICcgdGl0bGU9XCInK3Rvb2x0aXArJ1wiJyA6ICcnKSArICc+JytwcmV2TW9udGguZ2V0VVRDRGF0ZSgpICsgJzwvdGQ+Jyk7XG5cdFx0XHRcdGlmIChwcmV2TW9udGguZ2V0VVRDRGF5KCkgPT0gdGhpcy5vLndlZWtFbmQpIHtcblx0XHRcdFx0XHRodG1sLnB1c2goJzwvdHI+Jyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHJldk1vbnRoLnNldFVUQ0RhdGUocHJldk1vbnRoLmdldFVUQ0RhdGUoKSsxKTtcblx0XHRcdH1cblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5kYXRlcGlja2VyLWRheXMgdGJvZHknKS5lbXB0eSgpLmFwcGVuZChodG1sLmpvaW4oJycpKTtcblx0XHRcdHZhciBjdXJyZW50WWVhciA9IHRoaXMuZGF0ZSAmJiB0aGlzLmRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcblxuXHRcdFx0dmFyIG1vbnRocyA9IHRoaXMucGlja2VyLmZpbmQoJy5kYXRlcGlja2VyLW1vbnRocycpXG5cdFx0XHRcdFx0XHQuZmluZCgndGg6ZXEoMSknKVxuXHRcdFx0XHRcdFx0XHQudGV4dCh5ZWFyKVxuXHRcdFx0XHRcdFx0XHQuZW5kKClcblx0XHRcdFx0XHRcdC5maW5kKCdzcGFuJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuXHRcdFx0aWYgKGN1cnJlbnRZZWFyICYmIGN1cnJlbnRZZWFyID09IHllYXIpIHtcblx0XHRcdFx0bW9udGhzLmVxKHRoaXMuZGF0ZS5nZXRVVENNb250aCgpKS5hZGRDbGFzcygnYWN0aXZlJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoeWVhciA8IHN0YXJ0WWVhciB8fCB5ZWFyID4gZW5kWWVhcikge1xuXHRcdFx0XHRtb250aHMuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoeWVhciA9PSBzdGFydFllYXIpIHtcblx0XHRcdFx0bW9udGhzLnNsaWNlKDAsIHN0YXJ0TW9udGgpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHllYXIgPT0gZW5kWWVhcikge1xuXHRcdFx0XHRtb250aHMuc2xpY2UoZW5kTW9udGgrMSkuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG5cdFx0XHR9XG5cblx0XHRcdGh0bWwgPSAnJztcblx0XHRcdHllYXIgPSBwYXJzZUludCh5ZWFyLzEwLCAxMCkgKiAxMDtcblx0XHRcdHZhciB5ZWFyQ29udCA9IHRoaXMucGlja2VyLmZpbmQoJy5kYXRlcGlja2VyLXllYXJzJylcblx0XHRcdFx0XHRcdFx0XHQuZmluZCgndGg6ZXEoMSknKVxuXHRcdFx0XHRcdFx0XHRcdFx0LnRleHQoeWVhciArICctJyArICh5ZWFyICsgOSkpXG5cdFx0XHRcdFx0XHRcdFx0XHQuZW5kKClcblx0XHRcdFx0XHRcdFx0XHQuZmluZCgndGQnKTtcblx0XHRcdHllYXIgLT0gMTtcblx0XHRcdGZvciAodmFyIGkgPSAtMTsgaSA8IDExOyBpKyspIHtcblx0XHRcdFx0aHRtbCArPSAnPHNwYW4gY2xhc3M9XCJ5ZWFyJysoaSA9PSAtMSA/ICcgb2xkJyA6IGkgPT0gMTAgPyAnIG5ldycgOiAnJykrKGN1cnJlbnRZZWFyID09IHllYXIgPyAnIGFjdGl2ZScgOiAnJykrKHllYXIgPCBzdGFydFllYXIgfHwgeWVhciA+IGVuZFllYXIgPyAnIGRpc2FibGVkJyA6ICcnKSsnXCI+Jyt5ZWFyKyc8L3NwYW4+Jztcblx0XHRcdFx0eWVhciArPSAxO1xuXHRcdFx0fVxuXHRcdFx0eWVhckNvbnQuaHRtbChodG1sKTtcblx0XHR9LFxuXG5cdFx0dXBkYXRlTmF2QXJyb3dzOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICghdGhpcy5fYWxsb3dfdXBkYXRlKSByZXR1cm47XG5cblx0XHRcdHZhciBkID0gbmV3IERhdGUodGhpcy52aWV3RGF0ZSksXG5cdFx0XHRcdHllYXIgPSBkLmdldFVUQ0Z1bGxZZWFyKCksXG5cdFx0XHRcdG1vbnRoID0gZC5nZXRVVENNb250aCgpO1xuXHRcdFx0c3dpdGNoICh0aGlzLnZpZXdNb2RlKSB7XG5cdFx0XHRcdGNhc2UgMDpcblx0XHRcdFx0XHRpZiAodGhpcy5vLnN0YXJ0RGF0ZSAhPT0gLUluZmluaXR5ICYmIHllYXIgPD0gdGhpcy5vLnN0YXJ0RGF0ZS5nZXRVVENGdWxsWWVhcigpICYmIG1vbnRoIDw9IHRoaXMuby5zdGFydERhdGUuZ2V0VVRDTW9udGgoKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLnByZXYnKS5jc3Moe3Zpc2liaWxpdHk6ICdoaWRkZW4nfSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5wcmV2JykuY3NzKHt2aXNpYmlsaXR5OiAndmlzaWJsZSd9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuby5lbmREYXRlICE9PSBJbmZpbml0eSAmJiB5ZWFyID49IHRoaXMuby5lbmREYXRlLmdldFVUQ0Z1bGxZZWFyKCkgJiYgbW9udGggPj0gdGhpcy5vLmVuZERhdGUuZ2V0VVRDTW9udGgoKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLm5leHQnKS5jc3Moe3Zpc2liaWxpdHk6ICdoaWRkZW4nfSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5uZXh0JykuY3NzKHt2aXNpYmlsaXR5OiAndmlzaWJsZSd9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdGlmICh0aGlzLm8uc3RhcnREYXRlICE9PSAtSW5maW5pdHkgJiYgeWVhciA8PSB0aGlzLm8uc3RhcnREYXRlLmdldFVUQ0Z1bGxZZWFyKCkpIHtcblx0XHRcdFx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5wcmV2JykuY3NzKHt2aXNpYmlsaXR5OiAnaGlkZGVuJ30pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5maW5kKCcucHJldicpLmNzcyh7dmlzaWJpbGl0eTogJ3Zpc2libGUnfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aGlzLm8uZW5kRGF0ZSAhPT0gSW5maW5pdHkgJiYgeWVhciA+PSB0aGlzLm8uZW5kRGF0ZS5nZXRVVENGdWxsWWVhcigpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5maW5kKCcubmV4dCcpLmNzcyh7dmlzaWJpbGl0eTogJ2hpZGRlbid9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLm5leHQnKS5jc3Moe3Zpc2liaWxpdHk6ICd2aXNpYmxlJ30pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Y2xpY2s6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHZhciB0YXJnZXQgPSAkKGUudGFyZ2V0KS5jbG9zZXN0KCdzcGFuLCB0ZCwgdGgnKTtcblx0XHRcdGlmICh0YXJnZXQubGVuZ3RoID09IDEpIHtcblx0XHRcdFx0c3dpdGNoKHRhcmdldFswXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0XHRcdFx0Y2FzZSAndGgnOlxuXHRcdFx0XHRcdFx0c3dpdGNoKHRhcmdldFswXS5jbGFzc05hbWUpIHtcblx0XHRcdFx0XHRcdFx0Y2FzZSAnZGF0ZXBpY2tlci1zd2l0Y2gnOlxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2hvd01vZGUoMSk7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3ByZXYnOlxuXHRcdFx0XHRcdFx0XHRjYXNlICduZXh0Jzpcblx0XHRcdFx0XHRcdFx0XHR2YXIgZGlyID0gRFBHbG9iYWwubW9kZXNbdGhpcy52aWV3TW9kZV0ubmF2U3RlcCAqICh0YXJnZXRbMF0uY2xhc3NOYW1lID09ICdwcmV2JyA/IC0xIDogMSk7XG5cdFx0XHRcdFx0XHRcdFx0c3dpdGNoKHRoaXMudmlld01vZGUpe1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLnZpZXdEYXRlID0gdGhpcy5tb3ZlTW9udGgodGhpcy52aWV3RGF0ZSwgZGlyKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMudmlld0RhdGUgPSB0aGlzLm1vdmVZZWFyKHRoaXMudmlld0RhdGUsIGRpcik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR0aGlzLmZpbGwoKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAndG9kYXknOlxuXHRcdFx0XHRcdFx0XHRcdHZhciBkYXRlID0gbmV3IERhdGUoKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRlID0gVVRDRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCksIDAsIDAsIDApO1xuXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zaG93TW9kZSgtMik7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHdoaWNoID0gdGhpcy5vLnRvZGF5QnRuID09ICdsaW5rZWQnID8gbnVsbCA6ICd2aWV3Jztcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zZXREYXRlKGRhdGUsIHdoaWNoKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAnY2xlYXInOlxuXHRcdFx0XHRcdFx0XHRcdHZhciBlbGVtZW50O1xuXHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLmlzSW5wdXQpXG5cdFx0XHRcdFx0XHRcdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXHRcdFx0XHRcdFx0XHRcdGVsc2UgaWYgKHRoaXMuY29tcG9uZW50KVxuXHRcdFx0XHRcdFx0XHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudC5maW5kKCdpbnB1dCcpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChlbGVtZW50KVxuXHRcdFx0XHRcdFx0XHRcdFx0ZWxlbWVudC52YWwoXCJcIikuY2hhbmdlKCk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fdHJpZ2dlcignY2hhbmdlRGF0ZScpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuby5hdXRvY2xvc2UpXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmhpZGUoKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3NwYW4nOlxuXHRcdFx0XHRcdFx0aWYgKCF0YXJnZXQuaXMoJy5kaXNhYmxlZCcpKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMudmlld0RhdGUuc2V0VVRDRGF0ZSgxKTtcblx0XHRcdFx0XHRcdFx0aWYgKHRhcmdldC5pcygnLm1vbnRoJykpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgZGF5ID0gMTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgbW9udGggPSB0YXJnZXQucGFyZW50KCkuZmluZCgnc3BhbicpLmluZGV4KHRhcmdldCk7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHllYXIgPSB0aGlzLnZpZXdEYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy52aWV3RGF0ZS5zZXRVVENNb250aChtb250aCk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fdHJpZ2dlcignY2hhbmdlTW9udGgnLCB0aGlzLnZpZXdEYXRlKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAodGhpcy5vLm1pblZpZXdNb2RlID09PSAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zZXREYXRlKFVUQ0RhdGUoeWVhciwgbW9udGgsIGRheSwwLDAsMCwwKSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHZhciB5ZWFyID0gcGFyc2VJbnQodGFyZ2V0LnRleHQoKSwgMTApfHwwO1xuXHRcdFx0XHRcdFx0XHRcdHZhciBkYXkgPSAxO1xuXHRcdFx0XHRcdFx0XHRcdHZhciBtb250aCA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy52aWV3RGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjaGFuZ2VZZWFyJywgdGhpcy52aWV3RGF0ZSk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuby5taW5WaWV3TW9kZSA9PT0gMikge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fc2V0RGF0ZShVVENEYXRlKHllYXIsIG1vbnRoLCBkYXksMCwwLDAsMCkpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0aGlzLnNob3dNb2RlKC0xKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5maWxsKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICd0ZCc6XG5cdFx0XHRcdFx0XHRpZiAodGFyZ2V0LmlzKCcuZGF5JykgJiYgIXRhcmdldC5pcygnLmRpc2FibGVkJykpe1xuXHRcdFx0XHRcdFx0XHR2YXIgZGF5ID0gcGFyc2VJbnQodGFyZ2V0LnRleHQoKSwgMTApfHwxO1xuXHRcdFx0XHRcdFx0XHR2YXIgeWVhciA9IHRoaXMudmlld0RhdGUuZ2V0VVRDRnVsbFllYXIoKSxcblx0XHRcdFx0XHRcdFx0XHRtb250aCA9IHRoaXMudmlld0RhdGUuZ2V0VVRDTW9udGgoKTtcblx0XHRcdFx0XHRcdFx0aWYgKHRhcmdldC5pcygnLm9sZCcpKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKG1vbnRoID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtb250aCA9IDExO1xuXHRcdFx0XHRcdFx0XHRcdFx0eWVhciAtPSAxO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtb250aCAtPSAxO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0YXJnZXQuaXMoJy5uZXcnKSkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChtb250aCA9PSAxMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bW9udGggPSAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0eWVhciArPSAxO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtb250aCArPSAxO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0aGlzLl9zZXREYXRlKFVUQ0RhdGUoeWVhciwgbW9udGgsIGRheSwwLDAsMCwwKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfc2V0RGF0ZTogZnVuY3Rpb24oZGF0ZSwgd2hpY2gpe1xuXHRcdFx0aWYgKCF3aGljaCB8fCB3aGljaCA9PSAnZGF0ZScpXG5cdFx0XHRcdHRoaXMuZGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuXHRcdFx0aWYgKCF3aGljaCB8fCB3aGljaCAgPT0gJ3ZpZXcnKVxuXHRcdFx0XHR0aGlzLnZpZXdEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG5cdFx0XHR0aGlzLmZpbGwoKTtcblx0XHRcdHRoaXMuc2V0VmFsdWUoKTtcblx0XHRcdHRoaXMuX3RyaWdnZXIoJ2NoYW5nZURhdGUnKTtcblx0XHRcdHZhciBlbGVtZW50O1xuXHRcdFx0aWYgKHRoaXMuaXNJbnB1dCkge1xuXHRcdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLmNvbXBvbmVudCl7XG5cdFx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQuZmluZCgnaW5wdXQnKTtcblx0XHRcdH1cblx0XHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRcdGVsZW1lbnQuY2hhbmdlKCk7XG5cdFx0XHRcdGlmICh0aGlzLm8uYXV0b2Nsb3NlICYmICghd2hpY2ggfHwgd2hpY2ggPT0gJ2RhdGUnKSkge1xuXHRcdFx0XHRcdHRoaXMuaGlkZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdG1vdmVNb250aDogZnVuY3Rpb24oZGF0ZSwgZGlyKXtcblx0XHRcdGlmICghZGlyKSByZXR1cm4gZGF0ZTtcblx0XHRcdHZhciBuZXdfZGF0ZSA9IG5ldyBEYXRlKGRhdGUudmFsdWVPZigpKSxcblx0XHRcdFx0ZGF5ID0gbmV3X2RhdGUuZ2V0VVRDRGF0ZSgpLFxuXHRcdFx0XHRtb250aCA9IG5ld19kYXRlLmdldFVUQ01vbnRoKCksXG5cdFx0XHRcdG1hZyA9IE1hdGguYWJzKGRpciksXG5cdFx0XHRcdG5ld19tb250aCwgdGVzdDtcblx0XHRcdGRpciA9IGRpciA+IDAgPyAxIDogLTE7XG5cdFx0XHRpZiAobWFnID09IDEpe1xuXHRcdFx0XHR0ZXN0ID0gZGlyID09IC0xXG5cdFx0XHRcdFx0Ly8gSWYgZ29pbmcgYmFjayBvbmUgbW9udGgsIG1ha2Ugc3VyZSBtb250aCBpcyBub3QgY3VycmVudCBtb250aFxuXHRcdFx0XHRcdC8vIChlZywgTWFyIDMxIC0+IEZlYiAzMSA9PSBGZWIgMjgsIG5vdCBNYXIgMDIpXG5cdFx0XHRcdFx0PyBmdW5jdGlvbigpeyByZXR1cm4gbmV3X2RhdGUuZ2V0VVRDTW9udGgoKSA9PSBtb250aDsgfVxuXHRcdFx0XHRcdC8vIElmIGdvaW5nIGZvcndhcmQgb25lIG1vbnRoLCBtYWtlIHN1cmUgbW9udGggaXMgYXMgZXhwZWN0ZWRcblx0XHRcdFx0XHQvLyAoZWcsIEphbiAzMSAtPiBGZWIgMzEgPT0gRmViIDI4LCBub3QgTWFyIDAyKVxuXHRcdFx0XHRcdDogZnVuY3Rpb24oKXsgcmV0dXJuIG5ld19kYXRlLmdldFVUQ01vbnRoKCkgIT0gbmV3X21vbnRoOyB9O1xuXHRcdFx0XHRuZXdfbW9udGggPSBtb250aCArIGRpcjtcblx0XHRcdFx0bmV3X2RhdGUuc2V0VVRDTW9udGgobmV3X21vbnRoKTtcblx0XHRcdFx0Ly8gRGVjIC0+IEphbiAoMTIpIG9yIEphbiAtPiBEZWMgKC0xKSAtLSBsaW1pdCBleHBlY3RlZCBkYXRlIHRvIDAtMTFcblx0XHRcdFx0aWYgKG5ld19tb250aCA8IDAgfHwgbmV3X21vbnRoID4gMTEpXG5cdFx0XHRcdFx0bmV3X21vbnRoID0gKG5ld19tb250aCArIDEyKSAlIDEyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gRm9yIG1hZ25pdHVkZXMgPjEsIG1vdmUgb25lIG1vbnRoIGF0IGEgdGltZS4uLlxuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8bWFnOyBpKyspXG5cdFx0XHRcdFx0Ly8gLi4ud2hpY2ggbWlnaHQgZGVjcmVhc2UgdGhlIGRheSAoZWcsIEphbiAzMSB0byBGZWIgMjgsIGV0YykuLi5cblx0XHRcdFx0XHRuZXdfZGF0ZSA9IHRoaXMubW92ZU1vbnRoKG5ld19kYXRlLCBkaXIpO1xuXHRcdFx0XHQvLyAuLi50aGVuIHJlc2V0IHRoZSBkYXksIGtlZXBpbmcgaXQgaW4gdGhlIG5ldyBtb250aFxuXHRcdFx0XHRuZXdfbW9udGggPSBuZXdfZGF0ZS5nZXRVVENNb250aCgpO1xuXHRcdFx0XHRuZXdfZGF0ZS5zZXRVVENEYXRlKGRheSk7XG5cdFx0XHRcdHRlc3QgPSBmdW5jdGlvbigpeyByZXR1cm4gbmV3X21vbnRoICE9IG5ld19kYXRlLmdldFVUQ01vbnRoKCk7IH07XG5cdFx0XHR9XG5cdFx0XHQvLyBDb21tb24gZGF0ZS1yZXNldHRpbmcgbG9vcCAtLSBpZiBkYXRlIGlzIGJleW9uZCBlbmQgb2YgbW9udGgsIG1ha2UgaXRcblx0XHRcdC8vIGVuZCBvZiBtb250aFxuXHRcdFx0d2hpbGUgKHRlc3QoKSl7XG5cdFx0XHRcdG5ld19kYXRlLnNldFVUQ0RhdGUoLS1kYXkpO1xuXHRcdFx0XHRuZXdfZGF0ZS5zZXRVVENNb250aChuZXdfbW9udGgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ld19kYXRlO1xuXHRcdH0sXG5cblx0XHRtb3ZlWWVhcjogZnVuY3Rpb24oZGF0ZSwgZGlyKXtcblx0XHRcdHJldHVybiB0aGlzLm1vdmVNb250aChkYXRlLCBkaXIqMTIpO1xuXHRcdH0sXG5cblx0XHRkYXRlV2l0aGluUmFuZ2U6IGZ1bmN0aW9uKGRhdGUpe1xuXHRcdFx0cmV0dXJuIGRhdGUgPj0gdGhpcy5vLnN0YXJ0RGF0ZSAmJiBkYXRlIDw9IHRoaXMuby5lbmREYXRlO1xuXHRcdH0sXG5cblx0XHRrZXlkb3duOiBmdW5jdGlvbihlKXtcblx0XHRcdGlmICh0aGlzLnBpY2tlci5pcygnOm5vdCg6dmlzaWJsZSknKSl7XG5cdFx0XHRcdGlmIChlLmtleUNvZGUgPT0gMjcpIC8vIGFsbG93IGVzY2FwZSB0byBoaWRlIGFuZCByZS1zaG93IHBpY2tlclxuXHRcdFx0XHRcdHRoaXMuc2hvdygpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgZGF0ZUNoYW5nZWQgPSBmYWxzZSxcblx0XHRcdFx0ZGlyLCBkYXksIG1vbnRoLFxuXHRcdFx0XHRuZXdEYXRlLCBuZXdWaWV3RGF0ZTtcblx0XHRcdHN3aXRjaChlLmtleUNvZGUpe1xuXHRcdFx0XHRjYXNlIDI3OiAvLyBlc2NhcGVcblx0XHRcdFx0XHR0aGlzLmhpZGUoKTtcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMzc6IC8vIGxlZnRcblx0XHRcdFx0Y2FzZSAzOTogLy8gcmlnaHRcblx0XHRcdFx0XHRpZiAoIXRoaXMuby5rZXlib2FyZE5hdmlnYXRpb24pIGJyZWFrO1xuXHRcdFx0XHRcdGRpciA9IGUua2V5Q29kZSA9PSAzNyA/IC0xIDogMTtcblx0XHRcdFx0XHRpZiAoZS5jdHJsS2V5KXtcblx0XHRcdFx0XHRcdG5ld0RhdGUgPSB0aGlzLm1vdmVZZWFyKHRoaXMuZGF0ZSwgZGlyKTtcblx0XHRcdFx0XHRcdG5ld1ZpZXdEYXRlID0gdGhpcy5tb3ZlWWVhcih0aGlzLnZpZXdEYXRlLCBkaXIpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZS5zaGlmdEtleSl7XG5cdFx0XHRcdFx0XHRuZXdEYXRlID0gdGhpcy5tb3ZlTW9udGgodGhpcy5kYXRlLCBkaXIpO1xuXHRcdFx0XHRcdFx0bmV3Vmlld0RhdGUgPSB0aGlzLm1vdmVNb250aCh0aGlzLnZpZXdEYXRlLCBkaXIpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRuZXdEYXRlID0gbmV3IERhdGUodGhpcy5kYXRlKTtcblx0XHRcdFx0XHRcdG5ld0RhdGUuc2V0VVRDRGF0ZSh0aGlzLmRhdGUuZ2V0VVRDRGF0ZSgpICsgZGlyKTtcblx0XHRcdFx0XHRcdG5ld1ZpZXdEYXRlID0gbmV3IERhdGUodGhpcy52aWV3RGF0ZSk7XG5cdFx0XHRcdFx0XHRuZXdWaWV3RGF0ZS5zZXRVVENEYXRlKHRoaXMudmlld0RhdGUuZ2V0VVRDRGF0ZSgpICsgZGlyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuZGF0ZVdpdGhpblJhbmdlKG5ld0RhdGUpKXtcblx0XHRcdFx0XHRcdHRoaXMuZGF0ZSA9IG5ld0RhdGU7XG5cdFx0XHRcdFx0XHR0aGlzLnZpZXdEYXRlID0gbmV3Vmlld0RhdGU7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFZhbHVlKCk7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0ZGF0ZUNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAzODogLy8gdXBcblx0XHRcdFx0Y2FzZSA0MDogLy8gZG93blxuXHRcdFx0XHRcdGlmICghdGhpcy5vLmtleWJvYXJkTmF2aWdhdGlvbikgYnJlYWs7XG5cdFx0XHRcdFx0ZGlyID0gZS5rZXlDb2RlID09IDM4ID8gLTEgOiAxO1xuXHRcdFx0XHRcdGlmIChlLmN0cmxLZXkpe1xuXHRcdFx0XHRcdFx0bmV3RGF0ZSA9IHRoaXMubW92ZVllYXIodGhpcy5kYXRlLCBkaXIpO1xuXHRcdFx0XHRcdFx0bmV3Vmlld0RhdGUgPSB0aGlzLm1vdmVZZWFyKHRoaXMudmlld0RhdGUsIGRpcik7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChlLnNoaWZ0S2V5KXtcblx0XHRcdFx0XHRcdG5ld0RhdGUgPSB0aGlzLm1vdmVNb250aCh0aGlzLmRhdGUsIGRpcik7XG5cdFx0XHRcdFx0XHRuZXdWaWV3RGF0ZSA9IHRoaXMubW92ZU1vbnRoKHRoaXMudmlld0RhdGUsIGRpcik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5ld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLmRhdGUpO1xuXHRcdFx0XHRcdFx0bmV3RGF0ZS5zZXRVVENEYXRlKHRoaXMuZGF0ZS5nZXRVVENEYXRlKCkgKyBkaXIgKiA3KTtcblx0XHRcdFx0XHRcdG5ld1ZpZXdEYXRlID0gbmV3IERhdGUodGhpcy52aWV3RGF0ZSk7XG5cdFx0XHRcdFx0XHRuZXdWaWV3RGF0ZS5zZXRVVENEYXRlKHRoaXMudmlld0RhdGUuZ2V0VVRDRGF0ZSgpICsgZGlyICogNyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aGlzLmRhdGVXaXRoaW5SYW5nZShuZXdEYXRlKSl7XG5cdFx0XHRcdFx0XHR0aGlzLmRhdGUgPSBuZXdEYXRlO1xuXHRcdFx0XHRcdFx0dGhpcy52aWV3RGF0ZSA9IG5ld1ZpZXdEYXRlO1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRWYWx1ZSgpO1xuXHRcdFx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdGRhdGVDaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMTM6IC8vIGVudGVyXG5cdFx0XHRcdFx0dGhpcy5oaWRlKCk7XG5cdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDk6IC8vIHRhYlxuXHRcdFx0XHRcdHRoaXMuaGlkZSgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRhdGVDaGFuZ2VkKXtcblx0XHRcdFx0dGhpcy5fdHJpZ2dlcignY2hhbmdlRGF0ZScpO1xuXHRcdFx0XHR2YXIgZWxlbWVudDtcblx0XHRcdFx0aWYgKHRoaXMuaXNJbnB1dCkge1xuXHRcdFx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5jb21wb25lbnQpe1xuXHRcdFx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQuZmluZCgnaW5wdXQnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0XHRcdGVsZW1lbnQuY2hhbmdlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2hvd01vZGU6IGZ1bmN0aW9uKGRpcikge1xuXHRcdFx0aWYgKGRpcikge1xuXHRcdFx0XHR0aGlzLnZpZXdNb2RlID0gTWF0aC5tYXgodGhpcy5vLm1pblZpZXdNb2RlLCBNYXRoLm1pbigyLCB0aGlzLnZpZXdNb2RlICsgZGlyKSk7XG5cdFx0XHR9XG5cdFx0XHQvKlxuXHRcdFx0XHR2aXRhbGV0czogZml4aW5nIGJ1ZyBvZiB2ZXJ5IHNwZWNpYWwgY29uZGl0aW9uczpcblx0XHRcdFx0anF1ZXJ5IDEuNy4xICsgd2Via2l0ICsgc2hvdyBpbmxpbmUgZGF0ZXBpY2tlciBpbiBib290c3RyYXAgcG9wb3Zlci5cblx0XHRcdFx0TWV0aG9kIHNob3coKSBkb2VzIG5vdCBzZXQgZGlzcGxheSBjc3MgY29ycmVjdGx5IGFuZCBkYXRlcGlja2VyIGlzIG5vdCBzaG93bi5cblx0XHRcdFx0Q2hhbmdlZCB0byAuY3NzKCdkaXNwbGF5JywgJ2Jsb2NrJykgc29sdmUgdGhlIHByb2JsZW0uXG5cdFx0XHRcdFNlZSBodHRwczovL2dpdGh1Yi5jb20vdml0YWxldHMveC1lZGl0YWJsZS9pc3N1ZXMvMzdcblxuXHRcdFx0XHRJbiBqcXVlcnkgMS43LjIrIGV2ZXJ5dGhpbmcgd29ya3MgZmluZS5cblx0XHRcdCovXG5cdFx0XHQvL3RoaXMucGlja2VyLmZpbmQoJz5kaXYnKS5oaWRlKCkuZmlsdGVyKCcuZGF0ZXBpY2tlci0nK0RQR2xvYmFsLm1vZGVzW3RoaXMudmlld01vZGVdLmNsc05hbWUpLnNob3coKTtcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJz5kaXYnKS5oaWRlKCkuZmlsdGVyKCcuZGF0ZXBpY2tlci0nK0RQR2xvYmFsLm1vZGVzW3RoaXMudmlld01vZGVdLmNsc05hbWUpLmNzcygnZGlzcGxheScsICdibG9jaycpO1xuXHRcdFx0dGhpcy51cGRhdGVOYXZBcnJvd3MoKTtcblx0XHR9XG5cdH07XG5cblx0dmFyIERhdGVSYW5nZVBpY2tlciA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpe1xuXHRcdHRoaXMuZWxlbWVudCA9ICQoZWxlbWVudCk7XG5cdFx0dGhpcy5pbnB1dHMgPSAkLm1hcChvcHRpb25zLmlucHV0cywgZnVuY3Rpb24oaSl7IHJldHVybiBpLmpxdWVyeSA/IGlbMF0gOiBpOyB9KTtcblx0XHRkZWxldGUgb3B0aW9ucy5pbnB1dHM7XG5cblx0XHQkKHRoaXMuaW5wdXRzKVxuXHRcdFx0LmRhdGVwaWNrZXIob3B0aW9ucylcblx0XHRcdC5iaW5kKCdjaGFuZ2VEYXRlJywgJC5wcm94eSh0aGlzLmRhdGVVcGRhdGVkLCB0aGlzKSk7XG5cblx0XHR0aGlzLnBpY2tlcnMgPSAkLm1hcCh0aGlzLmlucHV0cywgZnVuY3Rpb24oaSl7IHJldHVybiAkKGkpLmRhdGEoJ2RhdGVwaWNrZXInKTsgfSk7XG5cdFx0dGhpcy51cGRhdGVEYXRlcygpO1xuXHR9O1xuXHREYXRlUmFuZ2VQaWNrZXIucHJvdG90eXBlID0ge1xuXHRcdHVwZGF0ZURhdGVzOiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5kYXRlcyA9ICQubWFwKHRoaXMucGlja2VycywgZnVuY3Rpb24oaSl7IHJldHVybiBpLmRhdGU7IH0pO1xuXHRcdFx0dGhpcy51cGRhdGVSYW5nZXMoKTtcblx0XHR9LFxuXHRcdHVwZGF0ZVJhbmdlczogZnVuY3Rpb24oKXtcblx0XHRcdHZhciByYW5nZSA9ICQubWFwKHRoaXMuZGF0ZXMsIGZ1bmN0aW9uKGQpeyByZXR1cm4gZC52YWx1ZU9mKCk7IH0pO1xuXHRcdFx0JC5lYWNoKHRoaXMucGlja2VycywgZnVuY3Rpb24oaSwgcCl7XG5cdFx0XHRcdHAuc2V0UmFuZ2UocmFuZ2UpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRkYXRlVXBkYXRlZDogZnVuY3Rpb24oZSl7XG5cdFx0XHR2YXIgZHAgPSAkKGUudGFyZ2V0KS5kYXRhKCdkYXRlcGlja2VyJyksXG5cdFx0XHRcdG5ld19kYXRlID0gZHAuZ2V0VVRDRGF0ZSgpLFxuXHRcdFx0XHRpID0gJC5pbkFycmF5KGUudGFyZ2V0LCB0aGlzLmlucHV0cyksXG5cdFx0XHRcdGwgPSB0aGlzLmlucHV0cy5sZW5ndGg7XG5cdFx0XHRpZiAoaSA9PSAtMSkgcmV0dXJuO1xuXG5cdFx0XHRpZiAobmV3X2RhdGUgPCB0aGlzLmRhdGVzW2ldKXtcblx0XHRcdFx0Ly8gRGF0ZSBiZWluZyBtb3ZlZCBlYXJsaWVyL2xlZnRcblx0XHRcdFx0d2hpbGUgKGk+PTAgJiYgbmV3X2RhdGUgPCB0aGlzLmRhdGVzW2ldKXtcblx0XHRcdFx0XHR0aGlzLnBpY2tlcnNbaS0tXS5zZXRVVENEYXRlKG5ld19kYXRlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAobmV3X2RhdGUgPiB0aGlzLmRhdGVzW2ldKXtcblx0XHRcdFx0Ly8gRGF0ZSBiZWluZyBtb3ZlZCBsYXRlci9yaWdodFxuXHRcdFx0XHR3aGlsZSAoaTxsICYmIG5ld19kYXRlID4gdGhpcy5kYXRlc1tpXSl7XG5cdFx0XHRcdFx0dGhpcy5waWNrZXJzW2krK10uc2V0VVRDRGF0ZShuZXdfZGF0ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMudXBkYXRlRGF0ZXMoKTtcblx0XHR9LFxuXHRcdHJlbW92ZTogZnVuY3Rpb24oKXtcblx0XHRcdCQubWFwKHRoaXMucGlja2VycywgZnVuY3Rpb24ocCl7IHAucmVtb3ZlKCk7IH0pO1xuXHRcdFx0ZGVsZXRlIHRoaXMuZWxlbWVudC5kYXRhKCkuZGF0ZXBpY2tlcjtcblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gb3B0c19mcm9tX2VsKGVsLCBwcmVmaXgpe1xuXHRcdC8vIERlcml2ZSBvcHRpb25zIGZyb20gZWxlbWVudCBkYXRhLWF0dHJzXG5cdFx0dmFyIGRhdGEgPSAkKGVsKS5kYXRhKCksXG5cdFx0XHRvdXQgPSB7fSwgaW5rZXksXG5cdFx0XHRyZXBsYWNlID0gbmV3IFJlZ0V4cCgnXicgKyBwcmVmaXgudG9Mb3dlckNhc2UoKSArICcoW0EtWl0pJyksXG5cdFx0XHRwcmVmaXggPSBuZXcgUmVnRXhwKCdeJyArIHByZWZpeC50b0xvd2VyQ2FzZSgpKTtcblx0XHRmb3IgKHZhciBrZXkgaW4gZGF0YSlcblx0XHRcdGlmIChwcmVmaXgudGVzdChrZXkpKXtcblx0XHRcdFx0aW5rZXkgPSBrZXkucmVwbGFjZShyZXBsYWNlLCBmdW5jdGlvbihfLGEpeyByZXR1cm4gYS50b0xvd2VyQ2FzZSgpOyB9KTtcblx0XHRcdFx0b3V0W2lua2V5XSA9IGRhdGFba2V5XTtcblx0XHRcdH1cblx0XHRyZXR1cm4gb3V0O1xuXHR9XG5cblx0ZnVuY3Rpb24gb3B0c19mcm9tX2xvY2FsZShsYW5nKXtcblx0XHQvLyBEZXJpdmUgb3B0aW9ucyBmcm9tIGxvY2FsZSBwbHVnaW5zXG5cdFx0dmFyIG91dCA9IHt9O1xuXHRcdC8vIENoZWNrIGlmIFwiZGUtREVcIiBzdHlsZSBkYXRlIGlzIGF2YWlsYWJsZSwgaWYgbm90IGxhbmd1YWdlIHNob3VsZFxuXHRcdC8vIGZhbGxiYWNrIHRvIDIgbGV0dGVyIGNvZGUgZWcgXCJkZVwiXG5cdFx0aWYgKCFkYXRlc1tsYW5nXSkge1xuXHRcdFx0bGFuZyA9IGxhbmcuc3BsaXQoJy0nKVswXVxuXHRcdFx0aWYgKCFkYXRlc1tsYW5nXSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgZCA9IGRhdGVzW2xhbmddO1xuXHRcdCQuZWFjaChsb2NhbGVfb3B0cywgZnVuY3Rpb24oaSxrKXtcblx0XHRcdGlmIChrIGluIGQpXG5cdFx0XHRcdG91dFtrXSA9IGRba107XG5cdFx0fSk7XG5cdFx0cmV0dXJuIG91dDtcblx0fVxuXG5cdHZhciBvbGQgPSAkLmZuLmRhdGVwaWNrZXI7XG5cdHZhciBkYXRlcGlja2VyID0gJC5mbi5kYXRlcGlja2VyID0gZnVuY3Rpb24gKCBvcHRpb24gKSB7XG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXHRcdGFyZ3Muc2hpZnQoKTtcblx0XHR2YXIgaW50ZXJuYWxfcmV0dXJuLFxuXHRcdFx0dGhpc19yZXR1cm47XG5cdFx0dGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciAkdGhpcyA9ICQodGhpcyksXG5cdFx0XHRcdGRhdGEgPSAkdGhpcy5kYXRhKCdkYXRlcGlja2VyJyksXG5cdFx0XHRcdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvbjtcblx0XHRcdGlmICghZGF0YSkge1xuXHRcdFx0XHR2YXIgZWxvcHRzID0gb3B0c19mcm9tX2VsKHRoaXMsICdkYXRlJyksXG5cdFx0XHRcdFx0Ly8gUHJlbGltaW5hcnkgb3Rpb25zXG5cdFx0XHRcdFx0eG9wdHMgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdHMsIGVsb3B0cywgb3B0aW9ucyksXG5cdFx0XHRcdFx0bG9jb3B0cyA9IG9wdHNfZnJvbV9sb2NhbGUoeG9wdHMubGFuZ3VhZ2UpLFxuXHRcdFx0XHRcdC8vIE9wdGlvbnMgcHJpb3JpdHk6IGpzIGFyZ3MsIGRhdGEtYXR0cnMsIGxvY2FsZXMsIGRlZmF1bHRzXG5cdFx0XHRcdFx0b3B0cyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgbG9jb3B0cywgZWxvcHRzLCBvcHRpb25zKTtcblx0XHRcdFx0aWYgKCR0aGlzLmlzKCcuaW5wdXQtZGF0ZXJhbmdlJykgfHwgb3B0cy5pbnB1dHMpe1xuXHRcdFx0XHRcdHZhciByb3B0cyA9IHtcblx0XHRcdFx0XHRcdGlucHV0czogb3B0cy5pbnB1dHMgfHwgJHRoaXMuZmluZCgnaW5wdXQnKS50b0FycmF5KClcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdCR0aGlzLmRhdGEoJ2RhdGVwaWNrZXInLCAoZGF0YSA9IG5ldyBEYXRlUmFuZ2VQaWNrZXIodGhpcywgJC5leHRlbmQob3B0cywgcm9wdHMpKSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2V7XG5cdFx0XHRcdFx0JHRoaXMuZGF0YSgnZGF0ZXBpY2tlcicsIChkYXRhID0gbmV3IERhdGVwaWNrZXIodGhpcywgb3B0cykpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycgJiYgdHlwZW9mIGRhdGFbb3B0aW9uXSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGludGVybmFsX3JldHVybiA9IGRhdGFbb3B0aW9uXS5hcHBseShkYXRhLCBhcmdzKTtcblx0XHRcdFx0aWYgKGludGVybmFsX3JldHVybiAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRpZiAoaW50ZXJuYWxfcmV0dXJuICE9PSB1bmRlZmluZWQpXG5cdFx0XHRyZXR1cm4gaW50ZXJuYWxfcmV0dXJuO1xuXHRcdGVsc2Vcblx0XHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdHZhciBkZWZhdWx0cyA9ICQuZm4uZGF0ZXBpY2tlci5kZWZhdWx0cyA9IHtcblx0XHRhdXRvY2xvc2U6IGZhbHNlLFxuXHRcdGJlZm9yZVNob3dEYXk6ICQubm9vcCxcblx0XHRjYWxlbmRhcldlZWtzOiBmYWxzZSxcblx0XHRjbGVhckJ0bjogZmFsc2UsXG5cdFx0ZGF5c09mV2Vla0Rpc2FibGVkOiBbXSxcblx0XHRlbmREYXRlOiBJbmZpbml0eSxcblx0XHRmb3JjZVBhcnNlOiB0cnVlLFxuXHRcdGZvcm1hdDogJ21tL2RkL3l5eXknLFxuXHRcdGtleWJvYXJkTmF2aWdhdGlvbjogdHJ1ZSxcblx0XHRsYW5ndWFnZTogJ2VuJyxcblx0XHRtaW5WaWV3TW9kZTogMCxcblx0XHRydGw6IGZhbHNlLFxuXHRcdHN0YXJ0RGF0ZTogLUluZmluaXR5LFxuXHRcdHN0YXJ0VmlldzogMCxcblx0XHR0b2RheUJ0bjogZmFsc2UsXG5cdFx0dG9kYXlIaWdobGlnaHQ6IGZhbHNlLFxuXHRcdHdlZWtTdGFydDogMFxuXHR9O1xuXHR2YXIgbG9jYWxlX29wdHMgPSAkLmZuLmRhdGVwaWNrZXIubG9jYWxlX29wdHMgPSBbXG5cdFx0J2Zvcm1hdCcsXG5cdFx0J3J0bCcsXG5cdFx0J3dlZWtTdGFydCdcblx0XTtcblx0JC5mbi5kYXRlcGlja2VyLkNvbnN0cnVjdG9yID0gRGF0ZXBpY2tlcjtcblx0dmFyIGRhdGVzID0gJC5mbi5kYXRlcGlja2VyLmRhdGVzID0ge1xuXHRcdGVuOiB7XG5cdFx0XHRkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiLCBcIlN1bmRheVwiXSxcblx0XHRcdGRheXNTaG9ydDogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCIsIFwiU3VuXCJdLFxuXHRcdFx0ZGF5c01pbjogW1wiU3VcIiwgXCJNb1wiLCBcIlR1XCIsIFwiV2VcIiwgXCJUaFwiLCBcIkZyXCIsIFwiU2FcIiwgXCJTdVwiXSxcblx0XHRcdG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXG5cdFx0XHRtb250aHNTaG9ydDogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdLFxuXHRcdFx0dG9kYXk6IFwiVG9kYXlcIixcblx0XHRcdGNsZWFyOiBcIkNsZWFyXCJcblx0XHR9XG5cdH07XG5cblx0dmFyIERQR2xvYmFsID0ge1xuXHRcdG1vZGVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdGNsc05hbWU6ICdkYXlzJyxcblx0XHRcdFx0bmF2Rm5jOiAnTW9udGgnLFxuXHRcdFx0XHRuYXZTdGVwOiAxXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRjbHNOYW1lOiAnbW9udGhzJyxcblx0XHRcdFx0bmF2Rm5jOiAnRnVsbFllYXInLFxuXHRcdFx0XHRuYXZTdGVwOiAxXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRjbHNOYW1lOiAneWVhcnMnLFxuXHRcdFx0XHRuYXZGbmM6ICdGdWxsWWVhcicsXG5cdFx0XHRcdG5hdlN0ZXA6IDEwXG5cdFx0fV0sXG5cdFx0aXNMZWFwWWVhcjogZnVuY3Rpb24gKHllYXIpIHtcblx0XHRcdHJldHVybiAoKCh5ZWFyICUgNCA9PT0gMCkgJiYgKHllYXIgJSAxMDAgIT09IDApKSB8fCAoeWVhciAlIDQwMCA9PT0gMCkpO1xuXHRcdH0sXG5cdFx0Z2V0RGF5c0luTW9udGg6IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuXHRcdFx0cmV0dXJuIFszMSwgKERQR2xvYmFsLmlzTGVhcFllYXIoeWVhcikgPyAyOSA6IDI4KSwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdW21vbnRoXTtcblx0XHR9LFxuXHRcdHZhbGlkUGFydHM6IC9kZD98REQ/fG1tP3xNTT98eXkoPzp5eSk/L2csXG5cdFx0bm9ucHVuY3R1YXRpb246IC9bXiAtXFwvOi1AXFxbXFx1MzQwMC1cXHU5ZmZmLWB7LX5cXHRcXG5cXHJdKy9nLFxuXHRcdHBhcnNlRm9ybWF0OiBmdW5jdGlvbihmb3JtYXQpe1xuXHRcdFx0Ly8gSUUgdHJlYXRzIFxcMCBhcyBhIHN0cmluZyBlbmQgaW4gaW5wdXRzICh0cnVuY2F0aW5nIHRoZSB2YWx1ZSksXG5cdFx0XHQvLyBzbyBpdCdzIGEgYmFkIGZvcm1hdCBkZWxpbWl0ZXIsIGFueXdheVxuXHRcdFx0dmFyIHNlcGFyYXRvcnMgPSBmb3JtYXQucmVwbGFjZSh0aGlzLnZhbGlkUGFydHMsICdcXDAnKS5zcGxpdCgnXFwwJyksXG5cdFx0XHRcdHBhcnRzID0gZm9ybWF0Lm1hdGNoKHRoaXMudmFsaWRQYXJ0cyk7XG5cdFx0XHRpZiAoIXNlcGFyYXRvcnMgfHwgIXNlcGFyYXRvcnMubGVuZ3RoIHx8ICFwYXJ0cyB8fCBwYXJ0cy5sZW5ndGggPT09IDApe1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGUgZm9ybWF0LlwiKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7c2VwYXJhdG9yczogc2VwYXJhdG9ycywgcGFydHM6IHBhcnRzfTtcblx0XHR9LFxuXHRcdHBhcnNlRGF0ZTogZnVuY3Rpb24oZGF0ZSwgZm9ybWF0LCBsYW5ndWFnZSkge1xuXHRcdFx0aWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gZGF0ZTtcblx0XHRcdGlmICh0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJylcblx0XHRcdFx0Zm9ybWF0ID0gRFBHbG9iYWwucGFyc2VGb3JtYXQoZm9ybWF0KTtcblx0XHRcdGlmICgvXltcXC0rXVxcZCtbZG13eV0oW1xccyxdK1tcXC0rXVxcZCtbZG13eV0pKiQvLnRlc3QoZGF0ZSkpIHtcblx0XHRcdFx0dmFyIHBhcnRfcmUgPSAvKFtcXC0rXVxcZCspKFtkbXd5XSkvLFxuXHRcdFx0XHRcdHBhcnRzID0gZGF0ZS5tYXRjaCgvKFtcXC0rXVxcZCspKFtkbXd5XSkvZyksXG5cdFx0XHRcdFx0cGFydCwgZGlyO1xuXHRcdFx0XHRkYXRlID0gbmV3IERhdGUoKTtcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHBhcnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0cGFydCA9IHBhcnRfcmUuZXhlYyhwYXJ0c1tpXSk7XG5cdFx0XHRcdFx0ZGlyID0gcGFyc2VJbnQocGFydFsxXSk7XG5cdFx0XHRcdFx0c3dpdGNoKHBhcnRbMl0pe1xuXHRcdFx0XHRcdFx0Y2FzZSAnZCc6XG5cdFx0XHRcdFx0XHRcdGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIGRpcik7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnbSc6XG5cdFx0XHRcdFx0XHRcdGRhdGUgPSBEYXRlcGlja2VyLnByb3RvdHlwZS5tb3ZlTW9udGguY2FsbChEYXRlcGlja2VyLnByb3RvdHlwZSwgZGF0ZSwgZGlyKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICd3Jzpcblx0XHRcdFx0XHRcdFx0ZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgZGlyICogNyk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAneSc6XG5cdFx0XHRcdFx0XHRcdGRhdGUgPSBEYXRlcGlja2VyLnByb3RvdHlwZS5tb3ZlWWVhci5jYWxsKERhdGVwaWNrZXIucHJvdG90eXBlLCBkYXRlLCBkaXIpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIFVUQ0RhdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpLCBkYXRlLmdldFVUQ01vbnRoKCksIGRhdGUuZ2V0VVRDRGF0ZSgpLCAwLCAwLCAwKTtcblx0XHRcdH1cblx0XHRcdHZhciBwYXJ0cyA9IGRhdGUgJiYgZGF0ZS5tYXRjaCh0aGlzLm5vbnB1bmN0dWF0aW9uKSB8fCBbXSxcblx0XHRcdFx0ZGF0ZSA9IG5ldyBEYXRlKCksXG5cdFx0XHRcdHBhcnNlZCA9IHt9LFxuXHRcdFx0XHRzZXR0ZXJzX29yZGVyID0gWyd5eXl5JywgJ3l5JywgJ00nLCAnTU0nLCAnbScsICdtbScsICdkJywgJ2RkJ10sXG5cdFx0XHRcdHNldHRlcnNfbWFwID0ge1xuXHRcdFx0XHRcdHl5eXk6IGZ1bmN0aW9uKGQsdil7IHJldHVybiBkLnNldFVUQ0Z1bGxZZWFyKHYpOyB9LFxuXHRcdFx0XHRcdHl5OiBmdW5jdGlvbihkLHYpeyByZXR1cm4gZC5zZXRVVENGdWxsWWVhcigyMDAwK3YpOyB9LFxuXHRcdFx0XHRcdG06IGZ1bmN0aW9uKGQsdil7XG5cdFx0XHRcdFx0XHR2IC09IDE7XG5cdFx0XHRcdFx0XHR3aGlsZSAodjwwKSB2ICs9IDEyO1xuXHRcdFx0XHRcdFx0diAlPSAxMjtcblx0XHRcdFx0XHRcdGQuc2V0VVRDTW9udGgodik7XG5cdFx0XHRcdFx0XHR3aGlsZSAoZC5nZXRVVENNb250aCgpICE9IHYpXG5cdFx0XHRcdFx0XHRcdGQuc2V0VVRDRGF0ZShkLmdldFVUQ0RhdGUoKS0xKTtcblx0XHRcdFx0XHRcdHJldHVybiBkO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0ZDogZnVuY3Rpb24oZCx2KXsgcmV0dXJuIGQuc2V0VVRDRGF0ZSh2KTsgfVxuXHRcdFx0XHR9LFxuXHRcdFx0XHR2YWwsIGZpbHRlcmVkLCBwYXJ0O1xuXHRcdFx0c2V0dGVyc19tYXBbJ00nXSA9IHNldHRlcnNfbWFwWydNTSddID0gc2V0dGVyc19tYXBbJ21tJ10gPSBzZXR0ZXJzX21hcFsnbSddO1xuXHRcdFx0c2V0dGVyc19tYXBbJ2RkJ10gPSBzZXR0ZXJzX21hcFsnZCddO1xuXHRcdFx0ZGF0ZSA9IFVUQ0RhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpLCAwLCAwLCAwKTtcblx0XHRcdHZhciBmcGFydHMgPSBmb3JtYXQucGFydHMuc2xpY2UoKTtcblx0XHRcdC8vIFJlbW92ZSBub29wIHBhcnRzXG5cdFx0XHRpZiAocGFydHMubGVuZ3RoICE9IGZwYXJ0cy5sZW5ndGgpIHtcblx0XHRcdFx0ZnBhcnRzID0gJChmcGFydHMpLmZpbHRlcihmdW5jdGlvbihpLHApe1xuXHRcdFx0XHRcdHJldHVybiAkLmluQXJyYXkocCwgc2V0dGVyc19vcmRlcikgIT09IC0xO1xuXHRcdFx0XHR9KS50b0FycmF5KCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBQcm9jZXNzIHJlbWFpbmRlclxuXHRcdFx0aWYgKHBhcnRzLmxlbmd0aCA9PSBmcGFydHMubGVuZ3RoKSB7XG5cdFx0XHRcdGZvciAodmFyIGk9MCwgY250ID0gZnBhcnRzLmxlbmd0aDsgaSA8IGNudDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFsID0gcGFyc2VJbnQocGFydHNbaV0sIDEwKTtcblx0XHRcdFx0XHRwYXJ0ID0gZnBhcnRzW2ldO1xuXHRcdFx0XHRcdGlmIChpc05hTih2YWwpKSB7XG5cdFx0XHRcdFx0XHRzd2l0Y2gocGFydCkge1xuXHRcdFx0XHRcdFx0XHRjYXNlICdNTSc6XG5cdFx0XHRcdFx0XHRcdFx0ZmlsdGVyZWQgPSAkKGRhdGVzW2xhbmd1YWdlXS5tb250aHMpLmZpbHRlcihmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIG0gPSB0aGlzLnNsaWNlKDAsIHBhcnRzW2ldLmxlbmd0aCksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHAgPSBwYXJ0c1tpXS5zbGljZSgwLCBtLmxlbmd0aCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbSA9PSBwO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdHZhbCA9ICQuaW5BcnJheShmaWx0ZXJlZFswXSwgZGF0ZXNbbGFuZ3VhZ2VdLm1vbnRocykgKyAxO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlICdNJzpcblx0XHRcdFx0XHRcdFx0XHRmaWx0ZXJlZCA9ICQoZGF0ZXNbbGFuZ3VhZ2VdLm1vbnRoc1Nob3J0KS5maWx0ZXIoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBtID0gdGhpcy5zbGljZSgwLCBwYXJ0c1tpXS5sZW5ndGgpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwID0gcGFydHNbaV0uc2xpY2UoMCwgbS5sZW5ndGgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIG0gPT0gcDtcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHR2YWwgPSAkLmluQXJyYXkoZmlsdGVyZWRbMF0sIGRhdGVzW2xhbmd1YWdlXS5tb250aHNTaG9ydCkgKyAxO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwYXJzZWRbcGFydF0gPSB2YWw7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yICh2YXIgaT0wLCBzOyBpPHNldHRlcnNfb3JkZXIubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRcdHMgPSBzZXR0ZXJzX29yZGVyW2ldO1xuXHRcdFx0XHRcdGlmIChzIGluIHBhcnNlZCAmJiAhaXNOYU4ocGFyc2VkW3NdKSlcblx0XHRcdFx0XHRcdHNldHRlcnNfbWFwW3NdKGRhdGUsIHBhcnNlZFtzXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBkYXRlO1xuXHRcdH0sXG5cdFx0Zm9ybWF0RGF0ZTogZnVuY3Rpb24oZGF0ZSwgZm9ybWF0LCBsYW5ndWFnZSl7XG5cdFx0XHRpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ3N0cmluZycpXG5cdFx0XHRcdGZvcm1hdCA9IERQR2xvYmFsLnBhcnNlRm9ybWF0KGZvcm1hdCk7XG5cdFx0XHR2YXIgdmFsID0ge1xuXHRcdFx0XHRkOiBkYXRlLmdldFVUQ0RhdGUoKSxcblx0XHRcdFx0RDogZGF0ZXNbbGFuZ3VhZ2VdLmRheXNTaG9ydFtkYXRlLmdldFVUQ0RheSgpXSxcblx0XHRcdFx0REQ6IGRhdGVzW2xhbmd1YWdlXS5kYXlzW2RhdGUuZ2V0VVRDRGF5KCldLFxuXHRcdFx0XHRtOiBkYXRlLmdldFVUQ01vbnRoKCkgKyAxLFxuXHRcdFx0XHRNOiBkYXRlc1tsYW5ndWFnZV0ubW9udGhzU2hvcnRbZGF0ZS5nZXRVVENNb250aCgpXSxcblx0XHRcdFx0TU06IGRhdGVzW2xhbmd1YWdlXS5tb250aHNbZGF0ZS5nZXRVVENNb250aCgpXSxcblx0XHRcdFx0eXk6IGRhdGUuZ2V0VVRDRnVsbFllYXIoKS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcblx0XHRcdFx0eXl5eTogZGF0ZS5nZXRVVENGdWxsWWVhcigpXG5cdFx0XHR9O1xuXHRcdFx0dmFsLmRkID0gKHZhbC5kIDwgMTAgPyAnMCcgOiAnJykgKyB2YWwuZDtcblx0XHRcdHZhbC5tbSA9ICh2YWwubSA8IDEwID8gJzAnIDogJycpICsgdmFsLm07XG5cdFx0XHR2YXIgZGF0ZSA9IFtdLFxuXHRcdFx0XHRzZXBzID0gJC5leHRlbmQoW10sIGZvcm1hdC5zZXBhcmF0b3JzKTtcblx0XHRcdGZvciAodmFyIGk9MCwgY250ID0gZm9ybWF0LnBhcnRzLmxlbmd0aDsgaSA8PSBjbnQ7IGkrKykge1xuXHRcdFx0XHRpZiAoc2Vwcy5sZW5ndGgpXG5cdFx0XHRcdFx0ZGF0ZS5wdXNoKHNlcHMuc2hpZnQoKSk7XG5cdFx0XHRcdGRhdGUucHVzaCh2YWxbZm9ybWF0LnBhcnRzW2ldXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGF0ZS5qb2luKCcnKTtcblx0XHR9LFxuXHRcdGhlYWRUZW1wbGF0ZTogJzx0aGVhZD4nK1xuXHRcdFx0XHRcdFx0XHQnPHRyPicrXG5cdFx0XHRcdFx0XHRcdFx0Jzx0aCBjbGFzcz1cInByZXZcIj48aSBjbGFzcz1cImljb24tYXJyb3ctbGVmdFwiLz48L3RoPicrXG5cdFx0XHRcdFx0XHRcdFx0Jzx0aCBjb2xzcGFuPVwiNVwiIGNsYXNzPVwiZGF0ZXBpY2tlci1zd2l0Y2hcIj48L3RoPicrXG5cdFx0XHRcdFx0XHRcdFx0Jzx0aCBjbGFzcz1cIm5leHRcIj48aSBjbGFzcz1cImljb24tYXJyb3ctcmlnaHRcIi8+PC90aD4nK1xuXHRcdFx0XHRcdFx0XHQnPC90cj4nK1xuXHRcdFx0XHRcdFx0JzwvdGhlYWQ+Jyxcblx0XHRjb250VGVtcGxhdGU6ICc8dGJvZHk+PHRyPjx0ZCBjb2xzcGFuPVwiN1wiPjwvdGQ+PC90cj48L3Rib2R5PicsXG5cdFx0Zm9vdFRlbXBsYXRlOiAnPHRmb290Pjx0cj48dGggY29sc3Bhbj1cIjdcIiBjbGFzcz1cInRvZGF5XCI+PC90aD48L3RyPjx0cj48dGggY29sc3Bhbj1cIjdcIiBjbGFzcz1cImNsZWFyXCI+PC90aD48L3RyPjwvdGZvb3Q+J1xuXHR9O1xuXHREUEdsb2JhbC50ZW1wbGF0ZSA9ICc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlclwiPicrXG5cdFx0XHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1kYXlzXCI+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRhYmxlIGNsYXNzPVwiIHRhYmxlLWNvbmRlbnNlZFwiPicrXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5oZWFkVGVtcGxhdGUrXG5cdFx0XHRcdFx0XHRcdFx0XHQnPHRib2R5PjwvdGJvZHk+Jytcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmZvb3RUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHQnPC90YWJsZT4nK1xuXHRcdFx0XHRcdFx0XHQnPC9kaXY+Jytcblx0XHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLW1vbnRoc1wiPicrXG5cdFx0XHRcdFx0XHRcdFx0Jzx0YWJsZSBjbGFzcz1cInRhYmxlLWNvbmRlbnNlZFwiPicrXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5oZWFkVGVtcGxhdGUrXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5jb250VGVtcGxhdGUrXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5mb290VGVtcGxhdGUrXG5cdFx0XHRcdFx0XHRcdFx0JzwvdGFibGU+Jytcblx0XHRcdFx0XHRcdFx0JzwvZGl2PicrXG5cdFx0XHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci15ZWFyc1wiPicrXG5cdFx0XHRcdFx0XHRcdFx0Jzx0YWJsZSBjbGFzcz1cInRhYmxlLWNvbmRlbnNlZFwiPicrXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5oZWFkVGVtcGxhdGUrXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5jb250VGVtcGxhdGUrXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5mb290VGVtcGxhdGUrXG5cdFx0XHRcdFx0XHRcdFx0JzwvdGFibGU+Jytcblx0XHRcdFx0XHRcdFx0JzwvZGl2PicrXG5cdFx0XHRcdFx0XHQnPC9kaXY+JztcblxuXHQkLmZuLmRhdGVwaWNrZXIuRFBHbG9iYWwgPSBEUEdsb2JhbDtcblxuXG5cdC8qIERBVEVQSUNLRVIgTk8gQ09ORkxJQ1Rcblx0KiA9PT09PT09PT09PT09PT09PT09ICovXG5cblx0JC5mbi5kYXRlcGlja2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpe1xuXHRcdCQuZm4uZGF0ZXBpY2tlciA9IG9sZDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXG5cdC8qIERBVEVQSUNLRVIgREFUQS1BUElcblx0KiA9PT09PT09PT09PT09PT09PT0gKi9cblxuXHQkKGRvY3VtZW50KS5vbihcblx0XHQnZm9jdXMuZGF0ZXBpY2tlci5kYXRhLWFwaSBjbGljay5kYXRlcGlja2VyLmRhdGEtYXBpJyxcblx0XHQnW2RhdGEtcHJvdmlkZT1cImRhdGVwaWNrZXJcIl0nLFxuXHRcdGZ1bmN0aW9uKGUpe1xuXHRcdFx0dmFyICR0aGlzID0gJCh0aGlzKTtcblx0XHRcdGlmICgkdGhpcy5kYXRhKCdkYXRlcGlja2VyJykpIHJldHVybjtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdC8vIGNvbXBvbmVudCBjbGljayByZXF1aXJlcyB1cyB0byBleHBsaWNpdGx5IHNob3cgaXRcblx0XHRcdGRhdGVwaWNrZXIuY2FsbCgkdGhpcywgJ3Nob3cnKTtcblx0XHR9XG5cdCk7XG5cdCQoZnVuY3Rpb24oKXtcblx0XHQvLyQoJ1tkYXRhLXByb3ZpZGU9XCJkYXRlcGlja2VyLWlubGluZVwiXScpLmRhdGVwaWNrZXIoKTtcbiAgICAgICAgLy92aXQ6IGNoYW5nZWQgdG8gc3VwcG9ydCBub0NvbmZsaWN0KClcbiAgICAgICAgZGF0ZXBpY2tlci5jYWxsKCQoJ1tkYXRhLXByb3ZpZGU9XCJkYXRlcGlja2VyLWlubGluZVwiXScpKTtcblx0fSk7XG5cbn0oIHdpbmRvdy5qUXVlcnkgKSk7XG5cbi8qKlxuQm9vdHN0cmFwLWRhdGVwaWNrZXIuICBcbkRlc2NyaXB0aW9uIGFuZCBleGFtcGxlczogaHR0cHM6Ly9naXRodWIuY29tL2V0ZXJuaWNvZGUvYm9vdHN0cmFwLWRhdGVwaWNrZXIuICBcbkZvciAqKmkxOG4qKiB5b3Ugc2hvdWxkIGluY2x1ZGUganMgZmlsZSBmcm9tIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGVybmljb2RlL2Jvb3RzdHJhcC1kYXRlcGlja2VyL3RyZWUvbWFzdGVyL2pzL2xvY2FsZXNcbmFuZCBzZXQgYGxhbmd1YWdlYCBvcHRpb24uICBcblNpbmNlIDEuNC4wIGRhdGUgaGFzIGRpZmZlcmVudCBhcHBlYXJhbmNlIGluICoqcG9wdXAqKiBhbmQgKippbmxpbmUqKiBtb2Rlcy4gXG5cbkBjbGFzcyBkYXRlXG5AZXh0ZW5kcyBhYnN0cmFjdGlucHV0XG5AZmluYWxcbkBleGFtcGxlXG48YSBocmVmPVwiI1wiIGlkPVwiZG9iXCIgZGF0YS10eXBlPVwiZGF0ZVwiIGRhdGEtcGs9XCIxXCIgZGF0YS11cmw9XCIvcG9zdFwiIGRhdGEtdGl0bGU9XCJTZWxlY3QgZGF0ZVwiPjE1LzA1LzE5ODQ8L2E+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgICQoJyNkb2InKS5lZGl0YWJsZSh7XG4gICAgICAgIGZvcm1hdDogJ3l5eXktbW0tZGQnLCAgICBcbiAgICAgICAgdmlld2Zvcm1hdDogJ2RkL21tL3l5eXknLCAgICBcbiAgICAgICAgZGF0ZXBpY2tlcjoge1xuICAgICAgICAgICAgICAgIHdlZWtTdGFydDogMVxuICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuPC9zY3JpcHQ+XG4qKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIFxuICAgIC8vc3RvcmUgYm9vdHN0cmFwLWRhdGVwaWNrZXIgYXMgYmRhdGVpY2tlciB0byBleGNsdWRlIGNvbmZsaWN0IHdpdGggalF1ZXJ5IFVJIG9uZVxuICAgICQuZm4uYmRhdGVwaWNrZXIgPSAkLmZuLmRhdGVwaWNrZXIubm9Db25mbGljdCgpO1xuICAgIGlmKCEkLmZuLmRhdGVwaWNrZXIpIHsgLy9pZiB0aGVyZSB3ZXJlIG5vIG90aGVyIGRhdGVwaWNrZXJzLCBrZWVwIGFsc28gb3JpZ2luYWwgbmFtZVxuICAgICAgICAkLmZuLmRhdGVwaWNrZXIgPSAkLmZuLmJkYXRlcGlja2VyOyAgICBcbiAgICB9ICAgIFxuICAgIFxuICAgIHZhciBEYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCdkYXRlJywgb3B0aW9ucywgRGF0ZS5kZWZhdWx0cyk7XG4gICAgICAgIHRoaXMuaW5pdFBpY2tlcihvcHRpb25zLCBEYXRlLmRlZmF1bHRzKTtcbiAgICB9O1xuXG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoRGF0ZSwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQpOyAgICBcbiAgICBcbiAgICAkLmV4dGVuZChEYXRlLnByb3RvdHlwZSwge1xuICAgICAgICBpbml0UGlja2VyOiBmdW5jdGlvbihvcHRpb25zLCBkZWZhdWx0cykge1xuICAgICAgICAgICAgLy8nZm9ybWF0JyBpcyBzZXQgZGlyZWN0bHkgZnJvbSBzZXR0aW5ncyBvciBkYXRhLSogYXR0cmlidXRlc1xuXG4gICAgICAgICAgICAvL2J5IGRlZmF1bHQgdmlld2Zvcm1hdCBlcXVhbHMgdG8gZm9ybWF0XG4gICAgICAgICAgICBpZighdGhpcy5vcHRpb25zLnZpZXdmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCA9IHRoaXMub3B0aW9ucy5mb3JtYXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vdHJ5IHBhcnNlIGRhdGVwaWNrZXIgY29uZmlnIGRlZmluZWQgYXMganNvbiBzdHJpbmcgaW4gZGF0YS1kYXRlcGlja2VyXG4gICAgICAgICAgICBvcHRpb25zLmRhdGVwaWNrZXIgPSAkLmZuLmVkaXRhYmxldXRpbHMudHJ5UGFyc2VKc29uKG9wdGlvbnMuZGF0ZXBpY2tlciwgdHJ1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vb3ZlcnJpZGluZyBkYXRlcGlja2VyIGNvbmZpZyAoYXMgYnkgZGVmYXVsdCBqUXVlcnkgZXh0ZW5kKCkgaXMgbm90IHJlY3Vyc2l2ZSlcbiAgICAgICAgICAgIC8vc2luY2UgMS40IGRhdGVwaWNrZXIgaW50ZXJuYWxseSB1c2VzIHZpZXdmb3JtYXQgaW5zdGVhZCBvZiBmb3JtYXQuIEZvcm1hdCBpcyBmb3Igc3VibWl0IG9ubHlcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kYXRlcGlja2VyID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLmRhdGVwaWNrZXIsIG9wdGlvbnMuZGF0ZXBpY2tlciwge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogdGhpcy5vcHRpb25zLnZpZXdmb3JtYXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2xhbmd1YWdlXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZGF0ZXBpY2tlci5sYW5ndWFnZSA9IHRoaXMub3B0aW9ucy5kYXRlcGlja2VyLmxhbmd1YWdlIHx8ICdlbic7IFxuXG4gICAgICAgICAgICAvL3N0b3JlIERQZ2xvYmFsXG4gICAgICAgICAgICB0aGlzLmRwZyA9ICQuZm4uYmRhdGVwaWNrZXIuRFBHbG9iYWw7IFxuXG4gICAgICAgICAgICAvL3N0b3JlIHBhcnNlZCBmb3JtYXRzXG4gICAgICAgICAgICB0aGlzLnBhcnNlZEZvcm1hdCA9IHRoaXMuZHBnLnBhcnNlRm9ybWF0KHRoaXMub3B0aW9ucy5mb3JtYXQpO1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRWaWV3Rm9ybWF0ID0gdGhpcy5kcGcucGFyc2VGb3JtYXQodGhpcy5vcHRpb25zLnZpZXdmb3JtYXQpOyAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5iZGF0ZXBpY2tlcih0aGlzLm9wdGlvbnMuZGF0ZXBpY2tlcik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vXCJjbGVhclwiIGxpbmtcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5jbGVhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuJGNsZWFyID0gJCgnPGEgaHJlZj1cIiNcIj48L2E+JykuaHRtbCh0aGlzLm9wdGlvbnMuY2xlYXIpLmNsaWNrKCQucHJveHkoZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLiR0cGwucGFyZW50KCkuYXBwZW5kKCQoJzxkaXYgY2xhc3M9XCJlZGl0YWJsZS1jbGVhclwiPicpLmFwcGVuZCh0aGlzLiRjbGVhcikpOyAgXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgdmFsdWUyaHRtbDogZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgdmFyIHRleHQgPSB2YWx1ZSA/IHRoaXMuZHBnLmZvcm1hdERhdGUodmFsdWUsIHRoaXMucGFyc2VkVmlld0Zvcm1hdCwgdGhpcy5vcHRpb25zLmRhdGVwaWNrZXIubGFuZ3VhZ2UpIDogJyc7XG4gICAgICAgICAgIERhdGUuc3VwZXJjbGFzcy52YWx1ZTJodG1sLmNhbGwodGhpcywgdGV4dCwgZWxlbWVudCk7IFxuICAgICAgICB9LFxuXG4gICAgICAgIGh0bWwydmFsdWU6IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRGF0ZShodG1sLCB0aGlzLnBhcnNlZFZpZXdGb3JtYXQpO1xuICAgICAgICB9LCAgIFxuXG4gICAgICAgIHZhbHVlMnN0cjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/IHRoaXMuZHBnLmZvcm1hdERhdGUodmFsdWUsIHRoaXMucGFyc2VkRm9ybWF0LCB0aGlzLm9wdGlvbnMuZGF0ZXBpY2tlci5sYW5ndWFnZSkgOiAnJztcbiAgICAgICAgfSwgXG5cbiAgICAgICAgc3RyMnZhbHVlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRGF0ZShzdHIsIHRoaXMucGFyc2VkRm9ybWF0KTtcbiAgICAgICAgfSwgXG5cbiAgICAgICAgdmFsdWUyc3VibWl0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUyc3RyKHZhbHVlKTtcbiAgICAgICAgfSwgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQuYmRhdGVwaWNrZXIoJ3VwZGF0ZScsIHZhbHVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbnB1dDJ2YWx1ZTogZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGlucHV0LmRhdGEoJ2RhdGVwaWNrZXInKS5kYXRlO1xuICAgICAgICB9LCAgICAgICBcblxuICAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXI6ICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LmRhdGEoJ2RhdGVwaWNrZXInKS5kYXRlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LmZpbmQoJy5hY3RpdmUnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICBpZighdGhpcy5vcHRpb25zLnNob3didXR0b25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5wdXQuY2xvc2VzdCgnZm9ybScpLnN1Ym1pdCgpOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhdXRvc3VibWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0Lm9uKCdtb3VzZXVwJywgJy5kYXknLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICBpZigkKGUuY3VycmVudFRhcmdldCkuaXMoJy5vbGQnKSB8fCAkKGUuY3VycmVudFRhcmdldCkuaXMoJy5uZXcnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciAkZm9ybSA9ICQodGhpcykuY2xvc2VzdCgnZm9ybScpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRmb3JtLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgLy9jaGFuZ2VkYXRlIGlzIG5vdCBzdWl0YWJsZSBhcyBpdCB0cmlnZ2VyZWQgd2hlbiBzaG93aW5nIGRhdGVwaWNrZXIuIHNlZSAjMTQ5XG4gICAgICAgICAgIC8qXG4gICAgICAgICAgIHRoaXMuJGlucHV0Lm9uKCdjaGFuZ2VEYXRlJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICB2YXIgJGZvcm0gPSAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKTtcbiAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgJGZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgICB9KTtcbiAgICAgICAgICAgKi9cbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIC8qXG4gICAgICAgIEZvciBpbmNvcnJlY3QgZGF0ZSBib290c3RyYXAtZGF0ZXBpY2tlciByZXR1cm5zIGN1cnJlbnQgZGF0ZSB0aGF0IGlzIG5vdCBzdWl0YWJsZVxuICAgICAgICBmb3IgZGF0ZWZpZWxkLlxuICAgICAgICBUaGlzIGZ1bmN0aW9uIHJldHVybnMgbnVsbCBmb3IgaW5jb3JyZWN0IGRhdGUuICBcbiAgICAgICAqL1xuICAgICAgIHBhcnNlRGF0ZTogZnVuY3Rpb24oc3RyLCBmb3JtYXQpIHtcbiAgICAgICAgICAgdmFyIGRhdGUgPSBudWxsLCBmb3JtYXR0ZWRCYWNrO1xuICAgICAgICAgICBpZihzdHIpIHtcbiAgICAgICAgICAgICAgIGRhdGUgPSB0aGlzLmRwZy5wYXJzZURhdGUoc3RyLCBmb3JtYXQsIHRoaXMub3B0aW9ucy5kYXRlcGlja2VyLmxhbmd1YWdlKTtcbiAgICAgICAgICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkQmFjayA9IHRoaXMuZHBnLmZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCB0aGlzLm9wdGlvbnMuZGF0ZXBpY2tlci5sYW5ndWFnZSk7XG4gICAgICAgICAgICAgICAgICAgaWYoc3RyICE9PSBmb3JtYXR0ZWRCYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIGRhdGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIERhdGUuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQuZGVmYXVsdHMsIHtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSB0cGwgXG4gICAgICAgIEBkZWZhdWx0IDxkaXY+PC9kaXY+XG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICB0cGw6JzxkaXYgY2xhc3M9XCJlZGl0YWJsZS1kYXRlIHdlbGxcIj48L2Rpdj4nLFxuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IGlucHV0Y2xhc3MgXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovXG4gICAgICAgIGlucHV0Y2xhc3M6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBGb3JtYXQgdXNlZCBmb3Igc2VuZGluZyB2YWx1ZSB0byBzZXJ2ZXIuIEFsc28gYXBwbGllZCB3aGVuIGNvbnZlcnRpbmcgZGF0ZSBmcm9tIDxjb2RlPmRhdGEtdmFsdWU8L2NvZGU+IGF0dHJpYnV0ZS48YnI+XG4gICAgICAgIFBvc3NpYmxlIHRva2VucyBhcmU6IDxjb2RlPmQsIGRkLCBtLCBtbSwgeXksIHl5eXk8L2NvZGU+ICBcblxuICAgICAgICBAcHJvcGVydHkgZm9ybWF0IFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgeXl5eS1tbS1kZFxuICAgICAgICAqKi9cbiAgICAgICAgZm9ybWF0Oid5eXl5LW1tLWRkJyxcbiAgICAgICAgLyoqXG4gICAgICAgIEZvcm1hdCB1c2VkIGZvciBkaXNwbGF5aW5nIGRhdGUuIEFsc28gYXBwbGllZCB3aGVuIGNvbnZlcnRpbmcgZGF0ZSBmcm9tIGVsZW1lbnQncyB0ZXh0IG9uIGluaXQuICAgXG4gICAgICAgIElmIG5vdCBzcGVjaWZpZWQgZXF1YWxzIHRvIDxjb2RlPmZvcm1hdDwvY29kZT5cblxuICAgICAgICBAcHJvcGVydHkgdmlld2Zvcm1hdCBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovXG4gICAgICAgIHZpZXdmb3JtYXQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBDb25maWd1cmF0aW9uIG9mIGRhdGVwaWNrZXIuXG4gICAgICAgIEZ1bGwgbGlzdCBvZiBvcHRpb25zOiBodHRwOi8vYm9vdHN0cmFwLWRhdGVwaWNrZXIucmVhZHRoZWRvY3Mub3JnL2VuL2xhdGVzdC9vcHRpb25zLmh0bWxcblxuICAgICAgICBAcHJvcGVydHkgZGF0ZXBpY2tlciBcbiAgICAgICAgQHR5cGUgb2JqZWN0XG4gICAgICAgIEBkZWZhdWx0IHtcbiAgICAgICAgICAgIHdlZWtTdGFydDogMCxcbiAgICAgICAgICAgIHN0YXJ0VmlldzogMCxcbiAgICAgICAgICAgIG1pblZpZXdNb2RlOiAwLFxuICAgICAgICAgICAgYXV0b2Nsb3NlOiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgICoqL1xuICAgICAgICBkYXRlcGlja2VyOntcbiAgICAgICAgICAgIHdlZWtTdGFydDogMCxcbiAgICAgICAgICAgIHN0YXJ0VmlldzogMCxcbiAgICAgICAgICAgIG1pblZpZXdNb2RlOiAwLFxuICAgICAgICAgICAgYXV0b2Nsb3NlOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgVGV4dCBzaG93biBhcyBjbGVhciBkYXRlIGJ1dHRvbi4gXG4gICAgICAgIElmIDxjb2RlPmZhbHNlPC9jb2RlPiBjbGVhciBidXR0b24gd2lsbCBub3QgYmUgcmVuZGVyZWQuXG5cbiAgICAgICAgQHByb3BlcnR5IGNsZWFyIFxuICAgICAgICBAdHlwZSBib29sZWFufHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCAneCBjbGVhcidcbiAgICAgICAgKiovXG4gICAgICAgIGNsZWFyOiAnJnRpbWVzOyBjbGVhcidcbiAgICB9KTtcblxuICAgICQuZm4uZWRpdGFibGV0eXBlcy5kYXRlID0gRGF0ZTtcblxufSh3aW5kb3cualF1ZXJ5KSk7XG5cbi8qKlxuQm9vdHN0cmFwIGRhdGVmaWVsZCBpbnB1dCAtIG1vZGlmaWNhdGlvbiBmb3IgaW5saW5lIG1vZGUuXG5TaG93cyBub3JtYWwgPGlucHV0IHR5cGU9XCJ0ZXh0XCI+IGFuZCBiaW5kcyBwb3B1cCBkYXRlcGlja2VyLiAgXG5BdXRvbWF0aWNhbGx5IHNob3duIGluIGlubGluZSBtb2RlLlxuXG5AY2xhc3MgZGF0ZWZpZWxkXG5AZXh0ZW5kcyBkYXRlXG5cbkBzaW5jZSAxLjQuMFxuKiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBcbiAgICB2YXIgRGF0ZUZpZWxkID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCdkYXRlZmllbGQnLCBvcHRpb25zLCBEYXRlRmllbGQuZGVmYXVsdHMpO1xuICAgICAgICB0aGlzLmluaXRQaWNrZXIob3B0aW9ucywgRGF0ZUZpZWxkLmRlZmF1bHRzKTtcbiAgICB9O1xuXG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoRGF0ZUZpZWxkLCAkLmZuLmVkaXRhYmxldHlwZXMuZGF0ZSk7ICAgIFxuICAgIFxuICAgICQuZXh0ZW5kKERhdGVGaWVsZC5wcm90b3R5cGUsIHtcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dCA9IHRoaXMuJHRwbC5maW5kKCdpbnB1dCcpO1xuICAgICAgICAgICAgdGhpcy5zZXRDbGFzcygpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdwbGFjZWhvbGRlcicpO1xuICAgIFxuICAgICAgICAgICAgLy9ib290c3RyYXAtZGF0ZXBpY2tlciBpcyBzZXQgYGJkYXRlaWNrZXJgIHRvIGV4Y2x1ZGUgY29uZmxpY3Qgd2l0aCBqUXVlcnkgVUkgb25lLiAoaW4gZGF0ZS5qcykgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kdHBsLmJkYXRlcGlja2VyKHRoaXMub3B0aW9ucy5kYXRlcGlja2VyKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9uZWVkIHRvIGRpc2FibGUgb3JpZ2luYWwgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgICAgIHRoaXMuJGlucHV0Lm9mZignZm9jdXMga2V5ZG93bicpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3VwZGF0ZSB2YWx1ZSBvZiBkYXRlcGlja2VyXG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5rZXl1cCgkLnByb3h5KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICB0aGlzLiR0cGwucmVtb3ZlRGF0YSgnZGF0ZScpO1xuICAgICAgICAgICAgICAgdGhpcy4kdHBsLmJkYXRlcGlja2VyKCd1cGRhdGUnKTtcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgIFxuICAgICAgICB9LCAgIFxuICAgICAgICBcbiAgICAgICB2YWx1ZTJpbnB1dDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgdGhpcy4kaW5wdXQudmFsKHZhbHVlID8gdGhpcy5kcGcuZm9ybWF0RGF0ZSh2YWx1ZSwgdGhpcy5wYXJzZWRWaWV3Rm9ybWF0LCB0aGlzLm9wdGlvbnMuZGF0ZXBpY2tlci5sYW5ndWFnZSkgOiAnJyk7XG4gICAgICAgICAgIHRoaXMuJHRwbC5iZGF0ZXBpY2tlcigndXBkYXRlJyk7XG4gICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgaW5wdXQydmFsdWU6IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuaHRtbDJ2YWx1ZSh0aGlzLiRpbnB1dC52YWwoKSk7XG4gICAgICAgfSwgICAgICAgICAgICAgIFxuICAgICAgICBcbiAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICQuZm4uZWRpdGFibGV0eXBlcy50ZXh0LnByb3RvdHlwZS5hY3RpdmF0ZS5jYWxsKHRoaXMpO1xuICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgYXV0b3N1Ym1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAvL3Jlc2V0IGF1dG9zdWJtaXQgdG8gZW1wdHkgIFxuICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBEYXRlRmllbGQuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGUuZGVmYXVsdHMsIHtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSB0cGwgXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICB0cGw6JzxkaXYgY2xhc3M9XCJpbnB1dC1hcHBlbmQgZGF0ZVwiPjxpbnB1dCB0eXBlPVwidGV4dFwiLz48c3BhbiBjbGFzcz1cImFkZC1vblwiPjxpIGNsYXNzPVwiaWNvbi10aFwiPjwvaT48L3NwYW4+PC9kaXY+JyxcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBpbnB1dGNsYXNzIFxuICAgICAgICBAZGVmYXVsdCAnaW5wdXQtc21hbGwnXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBpbnB1dGNsYXNzOiAnaW5wdXQtc21hbGwnLFxuICAgICAgICBcbiAgICAgICAgLyogZGF0ZXBpY2tlciBjb25maWcgKi9cbiAgICAgICAgZGF0ZXBpY2tlcjoge1xuICAgICAgICAgICAgd2Vla1N0YXJ0OiAwLFxuICAgICAgICAgICAgc3RhcnRWaWV3OiAwLFxuICAgICAgICAgICAgbWluVmlld01vZGU6IDAsXG4gICAgICAgICAgICBhdXRvY2xvc2U6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgICQuZm4uZWRpdGFibGV0eXBlcy5kYXRlZmllbGQgPSBEYXRlRmllbGQ7XG5cbn0od2luZG93LmpRdWVyeSkpO1xuLyoqXG5Cb290c3RyYXAtZGF0ZXRpbWVwaWNrZXIuICBcbkJhc2VkIG9uIFtzbWFsb3QgYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyIHBsdWdpbl0oaHR0cHM6Ly9naXRodWIuY29tL3NtYWxvdC9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIpLiBcbkJlZm9yZSB1c2FnZSB5b3Ugc2hvdWxkIG1hbnVhbGx5IGluY2x1ZGUgZGVwZW5kZW50IGpzIGFuZCBjc3M6XG5cbiAgICA8bGluayBocmVmPVwiY3NzL2RhdGV0aW1lcGlja2VyLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIiB0eXBlPVwidGV4dC9jc3NcIj48L2xpbms+IFxuICAgIDxzY3JpcHQgc3JjPVwianMvYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLmpzXCI+PC9zY3JpcHQ+XG5cbkZvciAqKmkxOG4qKiB5b3Ugc2hvdWxkIGluY2x1ZGUganMgZmlsZSBmcm9tIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9zbWFsb3QvYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyL3RyZWUvbWFzdGVyL2pzL2xvY2FsZXNcbmFuZCBzZXQgYGxhbmd1YWdlYCBvcHRpb24uICBcblxuQGNsYXNzIGRhdGV0aW1lXG5AZXh0ZW5kcyBhYnN0cmFjdGlucHV0XG5AZmluYWxcbkBzaW5jZSAxLjQuNFxuQGV4YW1wbGVcbjxhIGhyZWY9XCIjXCIgaWQ9XCJsYXN0X3NlZW5cIiBkYXRhLXR5cGU9XCJkYXRldGltZVwiIGRhdGEtcGs9XCIxXCIgZGF0YS11cmw9XCIvcG9zdFwiIHRpdGxlPVwiU2VsZWN0IGRhdGUgJiB0aW1lXCI+MTUvMDMvMjAxMyAxMjo0NTwvYT5cbjxzY3JpcHQ+XG4kKGZ1bmN0aW9uKCl7XG4gICAgJCgnI2xhc3Rfc2VlbicpLmVkaXRhYmxlKHtcbiAgICAgICAgZm9ybWF0OiAneXl5eS1tbS1kZCBoaDppaScsICAgIFxuICAgICAgICB2aWV3Zm9ybWF0OiAnZGQvbW0veXl5eSBoaDppaScsICAgIFxuICAgICAgICBkYXRldGltZXBpY2tlcjoge1xuICAgICAgICAgICAgICAgIHdlZWtTdGFydDogMVxuICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuPC9zY3JpcHQ+XG4qKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIERhdGVUaW1lID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCdkYXRldGltZScsIG9wdGlvbnMsIERhdGVUaW1lLmRlZmF1bHRzKTtcbiAgICAgICAgdGhpcy5pbml0UGlja2VyKG9wdGlvbnMsIERhdGVUaW1lLmRlZmF1bHRzKTtcbiAgICB9O1xuXG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoRGF0ZVRpbWUsICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0KTtcblxuICAgICQuZXh0ZW5kKERhdGVUaW1lLnByb3RvdHlwZSwge1xuICAgICAgICBpbml0UGlja2VyOiBmdW5jdGlvbihvcHRpb25zLCBkZWZhdWx0cykge1xuICAgICAgICAgICAgLy8nZm9ybWF0JyBpcyBzZXQgZGlyZWN0bHkgZnJvbSBzZXR0aW5ncyBvciBkYXRhLSogYXR0cmlidXRlc1xuXG4gICAgICAgICAgICAvL2J5IGRlZmF1bHQgdmlld2Zvcm1hdCBlcXVhbHMgdG8gZm9ybWF0XG4gICAgICAgICAgICBpZighdGhpcy5vcHRpb25zLnZpZXdmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCA9IHRoaXMub3B0aW9ucy5mb3JtYXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vdHJ5IHBhcnNlIGRhdGV0aW1lcGlja2VyIGNvbmZpZyBkZWZpbmVkIGFzIGpzb24gc3RyaW5nIGluIGRhdGEtZGF0ZXRpbWVwaWNrZXJcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0ZXRpbWVwaWNrZXIgPSAkLmZuLmVkaXRhYmxldXRpbHMudHJ5UGFyc2VKc29uKG9wdGlvbnMuZGF0ZXRpbWVwaWNrZXIsIHRydWUpO1xuXG4gICAgICAgICAgICAvL292ZXJyaWRpbmcgZGF0ZXRpbWVwaWNrZXIgY29uZmlnIChhcyBieSBkZWZhdWx0IGpRdWVyeSBleHRlbmQoKSBpcyBub3QgcmVjdXJzaXZlKVxuICAgICAgICAgICAgLy9zaW5jZSAxLjQgZGF0ZXRpbWVwaWNrZXIgaW50ZXJuYWxseSB1c2VzIHZpZXdmb3JtYXQgaW5zdGVhZCBvZiBmb3JtYXQuIEZvcm1hdCBpcyBmb3Igc3VibWl0IG9ubHlcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kYXRldGltZXBpY2tlciA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cy5kYXRldGltZXBpY2tlciwgb3B0aW9ucy5kYXRldGltZXBpY2tlciwge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogdGhpcy5vcHRpb25zLnZpZXdmb3JtYXRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvL2xhbmd1YWdlXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZGF0ZXRpbWVwaWNrZXIubGFuZ3VhZ2UgPSB0aGlzLm9wdGlvbnMuZGF0ZXRpbWVwaWNrZXIubGFuZ3VhZ2UgfHwgJ2VuJzsgXG5cbiAgICAgICAgICAgIC8vc3RvcmUgRFBnbG9iYWxcbiAgICAgICAgICAgIHRoaXMuZHBnID0gJC5mbi5kYXRldGltZXBpY2tlci5EUEdsb2JhbDsgXG5cbiAgICAgICAgICAgIC8vc3RvcmUgcGFyc2VkIGZvcm1hdHNcbiAgICAgICAgICAgIHRoaXMucGFyc2VkRm9ybWF0ID0gdGhpcy5kcGcucGFyc2VGb3JtYXQodGhpcy5vcHRpb25zLmZvcm1hdCwgdGhpcy5vcHRpb25zLmZvcm1hdFR5cGUpO1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRWaWV3Rm9ybWF0ID0gdGhpcy5kcGcucGFyc2VGb3JtYXQodGhpcy5vcHRpb25zLnZpZXdmb3JtYXQsIHRoaXMub3B0aW9ucy5mb3JtYXRUeXBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LmRhdGV0aW1lcGlja2VyKHRoaXMub3B0aW9ucy5kYXRldGltZXBpY2tlcik7XG5cbiAgICAgICAgICAgIC8vYWRqdXN0IGNvbnRhaW5lciBwb3NpdGlvbiB3aGVuIHZpZXdNb2RlIGNoYW5nZXNcbiAgICAgICAgICAgIC8vc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zbWFsb3QvYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyL3B1bGwvODBcbiAgICAgICAgICAgIHRoaXMuJGlucHV0Lm9uKCdjaGFuZ2VNb2RlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHZhciBmID0gJCh0aGlzKS5jbG9zZXN0KCdmb3JtJykucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgLy90aW1lb3V0IGhlcmUsIG90aGVyd2lzZSBjb250YWluZXIgY2hhbmdlcyBwb3NpdGlvbiBiZWZvcmUgZm9ybSBoYXMgbmV3IHNpemVcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIGYudHJpZ2dlckhhbmRsZXIoJ3Jlc2l6ZScpO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vXCJjbGVhclwiIGxpbmtcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5jbGVhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuJGNsZWFyID0gJCgnPGEgaHJlZj1cIiNcIj48L2E+JykuaHRtbCh0aGlzLm9wdGlvbnMuY2xlYXIpLmNsaWNrKCQucHJveHkoZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuJHRwbC5wYXJlbnQoKS5hcHBlbmQoJCgnPGRpdiBjbGFzcz1cImVkaXRhYmxlLWNsZWFyXCI+JykuYXBwZW5kKHRoaXMuJGNsZWFyKSk7ICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB2YWx1ZTJodG1sOiBmdW5jdGlvbih2YWx1ZSwgZWxlbWVudCkge1xuICAgICAgICAgICAgLy9mb3JtYXREYXRlIHdvcmtzIHdpdGggVVRDRGF0ZSFcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdmFsdWUgPyB0aGlzLmRwZy5mb3JtYXREYXRlKHRoaXMudG9VVEModmFsdWUpLCB0aGlzLnBhcnNlZFZpZXdGb3JtYXQsIHRoaXMub3B0aW9ucy5kYXRldGltZXBpY2tlci5sYW5ndWFnZSwgdGhpcy5vcHRpb25zLmZvcm1hdFR5cGUpIDogJyc7XG4gICAgICAgICAgICBpZihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgRGF0ZVRpbWUuc3VwZXJjbGFzcy52YWx1ZTJodG1sLmNhbGwodGhpcywgdGV4dCwgZWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGh0bWwydmFsdWU6IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgICAgICAgIC8vcGFyc2VEYXRlIHJldHVybiB1dGMgZGF0ZSFcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMucGFyc2VEYXRlKGh0bWwsIHRoaXMucGFyc2VkVmlld0Zvcm1hdCk7IFxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gdGhpcy5mcm9tVVRDKHZhbHVlKSA6IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFsdWUyc3RyOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgLy9mb3JtYXREYXRlIHdvcmtzIHdpdGggVVRDRGF0ZSFcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/IHRoaXMuZHBnLmZvcm1hdERhdGUodGhpcy50b1VUQyh2YWx1ZSksIHRoaXMucGFyc2VkRm9ybWF0LCB0aGlzLm9wdGlvbnMuZGF0ZXRpbWVwaWNrZXIubGFuZ3VhZ2UsIHRoaXMub3B0aW9ucy5mb3JtYXRUeXBlKSA6ICcnO1xuICAgICAgIH0sXG5cbiAgICAgICBzdHIydmFsdWU6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAvL3BhcnNlRGF0ZSByZXR1cm4gdXRjIGRhdGUhXG4gICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMucGFyc2VEYXRlKHN0ciwgdGhpcy5wYXJzZWRGb3JtYXQpO1xuICAgICAgICAgICByZXR1cm4gdmFsdWUgPyB0aGlzLmZyb21VVEModmFsdWUpIDogbnVsbDtcbiAgICAgICB9LFxuXG4gICAgICAgdmFsdWUyc3VibWl0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTJzdHIodmFsdWUpO1xuICAgICAgIH0sXG5cbiAgICAgICB2YWx1ZTJpbnB1dDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgaWYodmFsdWUpIHtcbiAgICAgICAgICAgICB0aGlzLiRpbnB1dC5kYXRhKCdkYXRldGltZXBpY2tlcicpLnNldERhdGUodmFsdWUpO1xuICAgICAgICAgICB9XG4gICAgICAgfSxcblxuICAgICAgIGlucHV0MnZhbHVlOiBmdW5jdGlvbigpIHsgXG4gICAgICAgICAgIC8vZGF0ZSBtYXkgYmUgY2xlYXJlZCwgaW4gdGhhdCBjYXNlIGdldERhdGUoKSB0cmlnZ2VycyBlcnJvclxuICAgICAgICAgICB2YXIgZHQgPSB0aGlzLiRpbnB1dC5kYXRhKCdkYXRldGltZXBpY2tlcicpO1xuICAgICAgICAgICByZXR1cm4gZHQuZGF0ZSA/IGR0LmdldERhdGUoKSA6IG51bGw7XG4gICAgICAgfSxcblxuICAgICAgIGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICB9LFxuXG4gICAgICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuJGlucHV0LmRhdGEoJ2RhdGV0aW1lcGlja2VyJykuZGF0ZSA9IG51bGw7XG4gICAgICAgICAgdGhpcy4kaW5wdXQuZmluZCgnLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICBpZighdGhpcy5vcHRpb25zLnNob3didXR0b25zKSB7XG4gICAgICAgICAgICAgdGhpcy4kaW5wdXQuY2xvc2VzdCgnZm9ybScpLnN1Ym1pdCgpOyBcbiAgICAgICAgICB9ICAgICAgICAgIFxuICAgICAgIH0sXG5cbiAgICAgICBhdXRvc3VibWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgdGhpcy4kaW5wdXQub24oJ21vdXNldXAnLCAnLm1pbnV0ZScsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgICAgdmFyICRmb3JtID0gJCh0aGlzKS5jbG9zZXN0KCdmb3JtJyk7XG4gICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICRmb3JtLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgICAgfSk7XG4gICAgICAgfSxcblxuICAgICAgIC8vY29udmVydCBkYXRlIGZyb20gbG9jYWwgdG8gdXRjXG4gICAgICAgdG9VVEM6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICByZXR1cm4gdmFsdWUgPyBuZXcgRGF0ZSh2YWx1ZS52YWx1ZU9mKCkgLSB2YWx1ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDApIDogdmFsdWU7ICBcbiAgICAgICB9LFxuXG4gICAgICAgLy9jb252ZXJ0IGRhdGUgZnJvbSB1dGMgdG8gbG9jYWxcbiAgICAgICBmcm9tVVRDOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgcmV0dXJuIHZhbHVlID8gbmV3IERhdGUodmFsdWUudmFsdWVPZigpICsgdmFsdWUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwKSA6IHZhbHVlOyAgXG4gICAgICAgfSxcblxuICAgICAgIC8qXG4gICAgICAgIEZvciBpbmNvcnJlY3QgZGF0ZSBib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIgcmV0dXJucyBjdXJyZW50IGRhdGUgdGhhdCBpcyBub3Qgc3VpdGFibGVcbiAgICAgICAgZm9yIGRhdGV0aW1lZmllbGQuXG4gICAgICAgIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBudWxsIGZvciBpbmNvcnJlY3QgZGF0ZS4gIFxuICAgICAgICovXG4gICAgICAgcGFyc2VEYXRlOiBmdW5jdGlvbihzdHIsIGZvcm1hdCkge1xuICAgICAgICAgICB2YXIgZGF0ZSA9IG51bGwsIGZvcm1hdHRlZEJhY2s7XG4gICAgICAgICAgIGlmKHN0cikge1xuICAgICAgICAgICAgICAgZGF0ZSA9IHRoaXMuZHBnLnBhcnNlRGF0ZShzdHIsIGZvcm1hdCwgdGhpcy5vcHRpb25zLmRhdGV0aW1lcGlja2VyLmxhbmd1YWdlLCB0aGlzLm9wdGlvbnMuZm9ybWF0VHlwZSk7XG4gICAgICAgICAgICAgICBpZih0eXBlb2Ygc3RyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZEJhY2sgPSB0aGlzLmRwZy5mb3JtYXREYXRlKGRhdGUsIGZvcm1hdCwgdGhpcy5vcHRpb25zLmRhdGV0aW1lcGlja2VyLmxhbmd1YWdlLCB0aGlzLm9wdGlvbnMuZm9ybWF0VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgaWYoc3RyICE9PSBmb3JtYXR0ZWRCYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIGRhdGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBEYXRlVGltZS5kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dC5kZWZhdWx0cywge1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IHRwbCBcbiAgICAgICAgQGRlZmF1bHQgPGRpdj48L2Rpdj5cbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHRwbDonPGRpdiBjbGFzcz1cImVkaXRhYmxlLWRhdGUgd2VsbFwiPjwvZGl2PicsXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgaW5wdXRjbGFzcyBcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi9cbiAgICAgICAgaW5wdXRjbGFzczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIEZvcm1hdCB1c2VkIGZvciBzZW5kaW5nIHZhbHVlIHRvIHNlcnZlci4gQWxzbyBhcHBsaWVkIHdoZW4gY29udmVydGluZyBkYXRlIGZyb20gPGNvZGU+ZGF0YS12YWx1ZTwvY29kZT4gYXR0cmlidXRlLjxicj5cbiAgICAgICAgUG9zc2libGUgdG9rZW5zIGFyZTogPGNvZGU+ZCwgZGQsIG0sIG1tLCB5eSwgeXl5eSwgaCwgaTwvY29kZT4gIFxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IGZvcm1hdCBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IHl5eXktbW0tZGQgaGg6aWlcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGZvcm1hdDoneXl5eS1tbS1kZCBoaDppaScsXG4gICAgICAgIGZvcm1hdFR5cGU6J3N0YW5kYXJkJyxcbiAgICAgICAgLyoqXG4gICAgICAgIEZvcm1hdCB1c2VkIGZvciBkaXNwbGF5aW5nIGRhdGUuIEFsc28gYXBwbGllZCB3aGVuIGNvbnZlcnRpbmcgZGF0ZSBmcm9tIGVsZW1lbnQncyB0ZXh0IG9uIGluaXQuICAgXG4gICAgICAgIElmIG5vdCBzcGVjaWZpZWQgZXF1YWxzIHRvIDxjb2RlPmZvcm1hdDwvY29kZT5cbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSB2aWV3Zm9ybWF0IFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi9cbiAgICAgICAgdmlld2Zvcm1hdDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIENvbmZpZ3VyYXRpb24gb2YgZGF0ZXRpbWVwaWNrZXIuXG4gICAgICAgIEZ1bGwgbGlzdCBvZiBvcHRpb25zOiBodHRwczovL2dpdGh1Yi5jb20vc21hbG90L2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlclxuXG4gICAgICAgIEBwcm9wZXJ0eSBkYXRldGltZXBpY2tlciBcbiAgICAgICAgQHR5cGUgb2JqZWN0XG4gICAgICAgIEBkZWZhdWx0IHsgfVxuICAgICAgICAqKi9cbiAgICAgICAgZGF0ZXRpbWVwaWNrZXI6e1xuICAgICAgICAgICAgdG9kYXlIaWdobGlnaHQ6IGZhbHNlLFxuICAgICAgICAgICAgYXV0b2Nsb3NlOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgVGV4dCBzaG93biBhcyBjbGVhciBkYXRlIGJ1dHRvbi4gXG4gICAgICAgIElmIDxjb2RlPmZhbHNlPC9jb2RlPiBjbGVhciBidXR0b24gd2lsbCBub3QgYmUgcmVuZGVyZWQuXG5cbiAgICAgICAgQHByb3BlcnR5IGNsZWFyIFxuICAgICAgICBAdHlwZSBib29sZWFufHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCAneCBjbGVhcidcbiAgICAgICAgKiovXG4gICAgICAgIGNsZWFyOiAnJnRpbWVzOyBjbGVhcidcbiAgICB9KTtcblxuICAgICQuZm4uZWRpdGFibGV0eXBlcy5kYXRldGltZSA9IERhdGVUaW1lO1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcbi8qKlxuQm9vdHN0cmFwIGRhdGV0aW1lZmllbGQgaW5wdXQgLSBkYXRldGltZSBpbnB1dCBmb3IgaW5saW5lIG1vZGUuXG5TaG93cyBub3JtYWwgPGlucHV0IHR5cGU9XCJ0ZXh0XCI+IGFuZCBiaW5kcyBwb3B1cCBkYXRldGltZXBpY2tlci4gIFxuQXV0b21hdGljYWxseSBzaG93biBpbiBpbmxpbmUgbW9kZS5cblxuQGNsYXNzIGRhdGV0aW1lZmllbGRcbkBleHRlbmRzIGRhdGV0aW1lXG5cbioqL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgXG4gICAgdmFyIERhdGVUaW1lRmllbGQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ2RhdGV0aW1lZmllbGQnLCBvcHRpb25zLCBEYXRlVGltZUZpZWxkLmRlZmF1bHRzKTtcbiAgICAgICAgdGhpcy5pbml0UGlja2VyKG9wdGlvbnMsIERhdGVUaW1lRmllbGQuZGVmYXVsdHMpO1xuICAgIH07XG5cbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChEYXRlVGltZUZpZWxkLCAkLmZuLmVkaXRhYmxldHlwZXMuZGF0ZXRpbWUpO1xuICAgIFxuICAgICQuZXh0ZW5kKERhdGVUaW1lRmllbGQucHJvdG90eXBlLCB7XG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQgPSB0aGlzLiR0cGwuZmluZCgnaW5wdXQnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3MoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cigncGxhY2Vob2xkZXInKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kdHBsLmRhdGV0aW1lcGlja2VyKHRoaXMub3B0aW9ucy5kYXRldGltZXBpY2tlcik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vbmVlZCB0byBkaXNhYmxlIG9yaWdpbmFsIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5vZmYoJ2ZvY3VzIGtleWRvd24nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy91cGRhdGUgdmFsdWUgb2YgZGF0ZXBpY2tlclxuICAgICAgICAgICAgdGhpcy4kaW5wdXQua2V5dXAoJC5wcm94eShmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgdGhpcy4kdHBsLnJlbW92ZURhdGEoJ2RhdGUnKTtcbiAgICAgICAgICAgICAgIHRoaXMuJHRwbC5kYXRldGltZXBpY2tlcigndXBkYXRlJyk7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgfSwgICBcbiAgICAgIFxuICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICB0aGlzLiRpbnB1dC52YWwodGhpcy52YWx1ZTJodG1sKHZhbHVlKSk7XG4gICAgICAgICAgIHRoaXMuJHRwbC5kYXRldGltZXBpY2tlcigndXBkYXRlJyk7XG4gICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgaW5wdXQydmFsdWU6IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuaHRtbDJ2YWx1ZSh0aGlzLiRpbnB1dC52YWwoKSk7XG4gICAgICAgfSwgICAgICAgICAgICAgIFxuICAgICAgICBcbiAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICQuZm4uZWRpdGFibGV0eXBlcy50ZXh0LnByb3RvdHlwZS5hY3RpdmF0ZS5jYWxsKHRoaXMpO1xuICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgYXV0b3N1Ym1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAvL3Jlc2V0IGF1dG9zdWJtaXQgdG8gZW1wdHkgIFxuICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBEYXRlVGltZUZpZWxkLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5kYXRldGltZS5kZWZhdWx0cywge1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IHRwbCBcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHRwbDonPGRpdiBjbGFzcz1cImlucHV0LWFwcGVuZCBkYXRlXCI+PGlucHV0IHR5cGU9XCJ0ZXh0XCIvPjxzcGFuIGNsYXNzPVwiYWRkLW9uXCI+PGkgY2xhc3M9XCJpY29uLXRoXCI+PC9pPjwvc3Bhbj48L2Rpdj4nLFxuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IGlucHV0Y2xhc3MgXG4gICAgICAgIEBkZWZhdWx0ICdpbnB1dC1tZWRpdW0nXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBpbnB1dGNsYXNzOiAnaW5wdXQtbWVkaXVtJyxcbiAgICAgICAgXG4gICAgICAgIC8qIGRhdGV0aW1lcGlja2VyIGNvbmZpZyAqL1xuICAgICAgICBkYXRldGltZXBpY2tlcjp7XG4gICAgICAgICAgICB0b2RheUhpZ2hsaWdodDogZmFsc2UsXG4gICAgICAgICAgICBhdXRvY2xvc2U6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgICQuZm4uZWRpdGFibGV0eXBlcy5kYXRldGltZWZpZWxkID0gRGF0ZVRpbWVGaWVsZDtcblxufSh3aW5kb3cualF1ZXJ5KSk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./Modules/Translation/node_modules/x-editable/dist/bootstrap3-editable/js/bootstrap-editable.js\n");

/***/ }),

/***/ 17:
/*!*********************************************************************!*\
  !*** multi ./Modules/Translation/Resources/assets/admin/js/main.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! /var/www/html/Amp/Modules/Translation/Resources/assets/admin/js/main.js */"./Modules/Translation/Resources/assets/admin/js/main.js");


/***/ })

/******/ });